diff -ru ffmpeg2theora/configure.ac ffmpeg2theora-kate/configure.ac
--- ffmpeg2theora/configure.ac	2008-04-13 19:50:53.000000000 +0100
+++ ffmpeg2theora-kate/configure.ac	2008-04-13 19:24:00.000000000 +0100
@@ -29,8 +29,8 @@
 AC_SUBST(XIPH_CFLAGS)
 AC_SUBST(XIPH_LIBS)
 
-export PKG_CONFIG_PATH=./libkate/pkg/pkgconfig:$PKG_CONFIG_PATH
-PKG_CHECK_MODULES(KATE,oggkate, 
+export PKG_CONFIG_PATH=./libkate/misc/pkgconfig:$PKG_CONFIG_PATH
+PKG_CHECK_MODULES(KATE,oggkate >= 0.1.2,
                   KATE_CFLAGS="-DHAVE_KATE -DHAVE_OGGKATE $KATE_CFLAGS",
                   [AC_MSG_RESULT(
 
diff -ru ffmpeg2theora/ffmpeg2theora.c ffmpeg2theora-kate/ffmpeg2theora.c
--- ffmpeg2theora/ffmpeg2theora.c	2008-04-13 19:50:53.000000000 +0100
+++ ffmpeg2theora-kate/ffmpeg2theora.c	2008-04-13 20:00:41.000000000 +0100
@@ -56,6 +56,7 @@
   OPTIMIZE_FLAG,
   SYNC_FLAG,
   NOSOUND_FLAG,
+  NOSPU_FLAG,
   CROPTOP_FLAG,
   CROPBOTTOM_FLAG,
   CROPRIGHT_FLAG,
@@ -67,6 +68,7 @@
   SUBTITLES_ENCODING_FLAG,
   SUBTITLES_LANGUAGE_FLAG,
   SUBTITLES_CATEGORY_FLAG,
+  SPUSTREAM_FLAG,
   VHOOK_FLAG,
   FRONTEND_FLAG,
   SPEEDLEVEL_FLAG,
@@ -110,11 +112,15 @@
 } ff2theora_subtitle;
 
 typedef struct ff2theora_kate_stream{
+    int stream_id; /* from input file, -1 if external */
+
+    /* this block only valid for external streams */
     const char *filename;
     size_t num_subtitles;
     ff2theora_subtitle *subtitles;
     size_t subtitles_count; /* total subtitles output so far */
     F2T_ENCODING subtitles_encoding;
+
     char subtitles_language[16];
     char subtitles_category[16];
 } ff2theora_kate_stream;
@@ -123,6 +129,7 @@
     AVFormatContext *context;
     int video_index;
     int audio_index;
+    int spu_index;
 
     int deinterlace;
     int vhook;
@@ -177,6 +184,9 @@
 
     size_t n_kate_streams;
     ff2theora_kate_stream *kate_streams;
+
+    int spustream;
+    int disable_spu;
 }
 *ff2theora;
 
@@ -493,6 +503,7 @@
     ff2theora_kate_stream *ks;
     this->kate_streams=(ff2theora_kate_stream*)realloc(this->kate_streams,(this->n_kate_streams+1)*sizeof(ff2theora_kate_stream));
     ks=&this->kate_streams[this->n_kate_streams++];
+    ks->stream_id = -1;
     ks->filename = NULL;
     ks->num_subtitles = 0;
     ks->subtitles = 0;
@@ -553,6 +564,18 @@
 }
 
 /**
+  * finds the index of a kate stream from its input file stream id
+  */
+static int find_kate_stream_from_stream_id(ff2theora this,int stream_id){
+  size_t n;
+  for (n=0; n<this->n_kate_streams;++n) {
+    if (this->kate_streams[n].stream_id==stream_id) return n;
+  }
+  /* oops, not found */
+  return -1;
+}
+
+/**
  * initialize ff2theora with default values
  * @return ff2theora struct
  */
@@ -560,8 +583,10 @@
     ff2theora this = calloc (1, sizeof (*this));
     if (this != NULL){
         this->disable_audio=0;
+        this->disable_spu=0;
         this->video_index = -1;
         this->audio_index = -1;
+        this->spu_index = -1;
         this->start_time=0;
         this->end_time=0; /* 0 denotes no end time set */
 
@@ -594,22 +619,58 @@
         this->frame_leftBand=0;
         this->frame_rightBand=0;
 
+        // subtitles
         this->n_kate_streams=0;
         this->kate_streams=NULL;
+        this->spustream=-1;
 
         this->pix_fmt = PIX_FMT_YUV420P;
     }
     return this;
 }
 
+static void resize_kate_bitmap(ff2theora this, kate_bitmap *kb, int width, int height) {
+    uint8_t *pixels;
+    int x,y,n;
+    double fx,fy;
+    int nw,nh;
+
+    if (this->picture_width==0 && this->picture_height==0) return;
+    if (this->picture_width==width && this->picture_height==height) return;
+   
+    fx=width/(double)(this->picture_width?this->picture_width:width);
+    fy=height/(double)(this->picture_height?this->picture_height:height);
+    nw=kb->width/fx;
+    nh=kb->height/fy;
+    pixels=malloc(nw*nh);
+
+    /* brute force, should be insignificant compared to the video decoding/encoding */
+    n=0;
+    for (y=0;y<nh;++y) {
+      for (x=0;x<nw;++x) {
+        int xx=(int)(x*fx+0.49);
+        int yy=(int)(y*fy+0.49);
+        pixels[n++]=kb->pixels[xx+yy*kb->width];
+      }
+    }
+
+    free(kb->pixels);
+    kb->pixels=pixels;
+    kb->width=nw;
+    kb->height=nh;
+}
+
 void ff2theora_output(ff2theora this) {
-    int i;
+    int i, n;
     AVCodecContext *aenc = NULL;
     AVCodecContext *venc = NULL;
+    AVCodecContext *senc = NULL;
     AVStream *astream = NULL;
     AVStream *vstream = NULL;
+    AVStream *sstream = NULL;
     AVCodec *acodec = NULL;
     AVCodec *vcodec = NULL;
+    AVCodec *scodec = NULL;
     pp_mode_t *ppMode = NULL;
     pp_context_t *ppContext = NULL;
     float frame_aspect;
@@ -626,6 +687,18 @@
         }
     }
 
+    if(this->spustream >= 0 && this->context->nb_streams > this->spustream) {
+        AVCodecContext *enc = this->context->streams[this->spustream]->codec;
+        if (enc->codec_type == CODEC_TYPE_SUBTITLE) {
+            this->spu_index = this->spustream;
+            info.with_kate = 1;
+            fprintf(stderr,"  Using stream #0.%d as spu input\n",this->spu_index);
+        }
+        else {
+            fprintf(stderr,"  The selected stream is not spu, falling back to automatic selection\n");
+        }
+    }
+
     for (i = 0; i < this->context->nb_streams; i++){
         AVCodecContext *enc = this->context->streams[i]->codec;
         switch (enc->codec_type){
@@ -637,11 +710,40 @@
                 if (this->audio_index < 0 && !this->disable_audio)
                     this->audio_index = i;
                 break;
+            case CODEC_TYPE_SUBTITLE:
+                if (this->spu_index < 0 && !this->disable_spu) {
+                    this->spu_index = i;
+                    info.with_kate=1;
+                }
+                break;
             default:
                 break;
         }
     }
 
+    /* if muxing from input, add an extra kate stream */
+    if (this->spu_index >= 0) {
+      add_kate_stream(this);
+      this->kate_streams[this->n_kate_streams-1].stream_id = this->spu_index;
+    }
+
+    oggmux_setup_kate_streams(&info, this->n_kate_streams);
+
+    for (n=0; n<this->n_kate_streams; ++n) {
+        ff2theora_kate_stream *ks=this->kate_streams+n;
+        if (ks->stream_id >= 0) {
+          printf("Muxing Kate stream %d from input file stream %d\n", n, ks->stream_id);
+        }
+        else {
+          if (load_subtitles(ks)>=0) {
+            printf("Muxing Kate stream %d from %s as %s %s\n",
+                n,ks->filename,
+                ks->subtitles_language[0]?ks->subtitles_language:"<unknown language>",
+                ks->subtitles_category[0]?ks->subtitles_category:"subtitles");
+          }
+        }
+    }
+
     if (this->video_index >= 0){
         vstream = this->context->streams[this->video_index];
         venc = this->context->streams[this->video_index]->codec;
@@ -899,6 +1001,18 @@
         }
     }
 
+    if (this->spu_index >= 0){
+        sstream = this->context->streams[this->spu_index];
+        senc = this->context->streams[this->spu_index]->codec;
+        scodec = avcodec_find_decoder (senc->codec_id);
+        /* language cannot be known for spu :( */
+        if (scodec != NULL && avcodec_open (senc, scodec) >= 0){
+        }
+        else{
+            this->spu_index = -1;
+        }
+    }
+
     if (this->video_index >= 0 || this->audio_index >=0){
         AVFrame *frame=NULL;
         AVFrame *frame_tmp=NULL;
@@ -911,6 +1025,7 @@
         int len;
         int len1;
         int got_picture;
+        int got_spu;
         int first = 1;
         int e_o_s = 0;
         int ret;
@@ -1010,7 +1125,7 @@
         for (i=0; i<this->n_kate_streams; ++i) {
             ff2theora_kate_stream *ks = this->kate_streams+i;
             kate_info *ki = &info.kate_streams[i].ki;
-            if (ks->num_subtitles > 0) {
+            if (ks->num_subtitles > 0 || ks->stream_id >= 0) {
                 kate_info_init(ki);
                 kate_info_set_language(ki, ks->subtitles_language);
                 kate_info_set_category(ki, ks->subtitles_category[0]?ks->subtitles_category:"subtitles");
@@ -1042,6 +1157,7 @@
              but end after it */
           for (i=0; i<this->n_kate_streams; ++i) {
               ff2theora_kate_stream *ks=this->kate_streams+i;
+              if (ks->stream_id>=0) continue;
               while (ks->subtitles_count < ks->num_subtitles && ks->subtitles[ks->subtitles_count].t1 <= this->start_time) {
                   /* printf("skipping subtitle %u\n", ks->subtitles_count); */
                   ks->subtitles_count++;
@@ -1261,9 +1377,93 @@
                 double avtime = info.audio_only ? info.audiotime :
                     info.video_only ? info.videotime :
                     info.audiotime < info.videotime ? info.audiotime : info.videotime;
+
+                /* add the subs from ffmpeg */
+                if(e_o_s || (ret >= 0 && pkt.stream_index == this->spu_index)) {
+                  while (e_o_s || len > 0) {
+                    if (len>0) {
+                      AVSubtitle sub;
+                      int bytes = avcodec_decode_subtitle(sstream->codec, &sub, &got_spu, ptr, len);
+                      if (bytes < 0) {
+                        /* error */
+                      }
+                      else {
+                        /* libavcodec says 0 is gfx, but I get non zero, and it *is* gfx,
+                           so ignore that flag for now */
+                        /* oh well, it turns out they don't even set it, must be "left for
+                           future expansion" or something. ignore it doubly */
+                        if (/*sub.format == 0 ||*/ 1) {
+                          /* A list of bitmaps */
+                          float t0 = avtime+sub.start_display_time/1000.0;
+                          float t1 = avtime+sub.end_display_time/1000.0;
+                          int n, ret, c, y;
+
+                          for (n=0; n<sub.num_rects; ++n) {
+                            AVSubtitleRect *rect = sub.rects+n;
+                            kate_region kr;
+                            kate_bitmap kb;
+                            kate_palette kp;
+                            int width=venc->width-this->frame_leftBand-this->frame_rightBand;
+                            int height=venc->height-this->frame_topBand-this->frame_bottomBand;
+                            int idx;
+
+                            /* fill region */
+                            kr.metric = kate_percentage;
+                            kr.x = 100*rect->x/width;
+                            kr.y = 100*rect->y/height;
+                            kr.w = 100*rect->w/width;
+                            kr.h = 100*rect->h/height;
+                            kr.style = -1;
+
+                            /* fill palette */
+                            kp.ncolors = rect->nb_colors;
+                            kp.colors = (kate_color*)malloc(kp.ncolors*sizeof(kate_color));
+                            for (c=0; c<rect->nb_colors; ++c) {
+                              kp.colors[c].b = (rect->rgba_palette[c]>>0)&0xff;
+                              kp.colors[c].g = (rect->rgba_palette[c]>>8)&0xff;
+                              kp.colors[c].r = (rect->rgba_palette[c]>>16)&0xff;
+                              kp.colors[c].a = (rect->rgba_palette[c]>>24)&0xff;
+                            }
+
+                            /* fill bitmap */
+                            kb.width = rect->w;
+                            kb.height = rect->h;
+                            kb.bpp = 1;
+                            while (kb.bpp<8 && (1<<kb.bpp)<kp.ncolors)
+                              ++kb.bpp;
+                            kb.palette = -1;
+                            kb.pixels=(unsigned char*)malloc(kb.width*kb.height);
+                            for (y=0; y<kb.height; ++y) {
+                              memcpy(kb.pixels+kb.width*y,rect->bitmap+y*rect->linesize,kb.width);
+                            }
+
+                            resize_kate_bitmap(this, &kb, width, height);
+
+                            idx = find_kate_stream_from_stream_id(this, this->spu_index);
+                            oggmux_add_kate_bitmap(&info, idx, t0, t1, &kr, &kb, &kp, 0);
+
+                            /* free temp memory */
+                            free(kb.pixels);
+                            free(kp.colors);
+                          }
+                        }
+                        else {
+                          fprintf(stderr, "SPU is not a bitmap (format %d), ignored\n", sub.format);
+                        }
+                      }
+                      len -= bytes;
+                      ptr += bytes;
+                    }
+                    if(e_o_s && len <= 0){
+                        break;
+                    }
+                  }
+                }
+
+                /* add the subs from external sources */
                 for (i=0; i<this->n_kate_streams; ++i) {
                     ff2theora_kate_stream *ks = this->kate_streams+i;
-                    if (ks->num_subtitles > 0) {
+                    if (ks->stream_id<0 && ks->num_subtitles > 0) {
                         ff2theora_subtitle *sub = ks->subtitles+ks->subtitles_count;
                         /* we encode a bit in advance so we're sure to hit the time, the packet will
                            be held till the right time. If we don't do that, we can insert late and
@@ -1286,7 +1486,7 @@
 
         for (i=0; i<this->n_kate_streams; ++i) {
             ff2theora_kate_stream *ks = this->kate_streams+i;
-            if (ks->num_subtitles > 0 && ks->subtitles_count<ks->num_subtitles) {
+            if ((ks->num_subtitles > 0 && ks->subtitles_count<ks->num_subtitles) || ks->stream_id>=0) {
                 double t = (info.videotime<info.audiotime?info.audiotime:info.videotime)+this->start_time;
                 oggmux_add_kate_end_packet(&info, i, t);
                 oggmux_flush (&info, e_o_s);
@@ -1495,6 +1695,8 @@
         "             supported are " SUPPORTED_ENCODINGS "\n"
         "      --subtitles-language language    set subtitles language (de, en_GB, etc)\n"
         "      --subtitles-category category    set subtitles category (default \"subtitles\")\n"
+        "      --spustream id                   set the input spu stream to use (autodected otherwise)\n"
+        "      --nospu                          disable the spu from input\n"
         "\n"
 #endif
         "Metadata options:\n"
@@ -1517,7 +1719,7 @@
         "Examples:\n"
         "  ffmpeg2theora videoclip.avi (will write output to videoclip.ogv)\n"
         "\n"
-        "  ffmpeg2theora videoclip.avi subtitles.srt (same, with subtitles)\n"
+        "  ffmpeg2theora videoclip.avi --subtitles subtitles.srt (same, with subtitles)\n"
         "\n"
         "  cat something.dv | ffmpeg2theora -f dv -o output.ogv -\n"
         "\n"
@@ -1580,6 +1782,7 @@
       {"contrast",required_argument,NULL,'C'},
       {"saturation",required_argument,NULL,'Z'},
       {"nosound",0,&flag,NOSOUND_FLAG},
+      {"nospu",0,&flag,NOSPU_FLAG},
       {"vhook",required_argument,&flag,VHOOK_FLAG},
       {"framerate",required_argument,NULL,'F'},
       {"aspect",required_argument,&flag,ASPECT_FLAG},
@@ -1595,6 +1798,7 @@
       {"subtitles-encoding",required_argument,&flag,SUBTITLES_ENCODING_FLAG},
       {"subtitles-language",required_argument,&flag,SUBTITLES_LANGUAGE_FLAG},
       {"subtitles-category",required_argument,&flag,SUBTITLES_CATEGORY_FLAG},
+      {"spustream",required_argument,&flag,SPUSTREAM_FLAG},
       {"starttime",required_argument,NULL,'s'},
       {"endtime",required_argument,NULL,'e'},
       {"sync",0,&flag,SYNC_FLAG},
@@ -1664,6 +1868,10 @@
                             convert->disable_audio = 1;
                             flag = -1;
                             break;
+                        case NOSPU_FLAG:
+                            convert->disable_spu = 1;
+                            flag = -1;
+                            break;
                         case OPTIMIZE_FLAG:
                             info.speed_level = 0;
                             flag = -1;
@@ -1736,11 +1944,16 @@
                             set_subtitles_category(convert,optarg);
                             flag = -1;
                             break;
+                        case SPUSTREAM_FLAG:
+                            convert->spustream = atoi(optarg);
+                            flag = -1;
+                            break;
 #else
                         case SUBTITLES_FLAG:
                         case SUBTITLES_ENCODING_FLAG:
                         case SUBTITLES_LANGUAGE_FLAG:
                         case SUBTITLES_CATEGORY_FLAG:
+                        case SPUSTREAM_FLAG:
                             fprintf(stderr, "WARNING - Kate support not compiled in, subtitles will not be output\n"
                                             "        - install libkate and rebuild ffmpeg2theora for subtitle support\n");
                             break;
@@ -2029,18 +2242,6 @@
         }
     }
 
-    oggmux_setup_kate_streams(&info, convert->n_kate_streams);
-
-    for (n=0; n<convert->n_kate_streams; ++n) {
-        ff2theora_kate_stream *ks=convert->kate_streams+n;
-        if (load_subtitles(ks)>=0) {
-          printf("Muxing Kate stream %d from %s as %s %s\n",
-              n,ks->filename,
-              ks->subtitles_language[0]?ks->subtitles_language:"<unknown language>",
-              ks->subtitles_category[0]?ks->subtitles_category:"subtitles");
-        }
-    }
-
     if (av_open_input_file(&convert->context, inputfile_name, input_fmt, 0, formatParams) >= 0){
         if (av_find_stream_info (convert->context) >= 0){
 #ifdef WIN32
@@ -2066,6 +2267,9 @@
                 if(convert->disable_audio){
                     fprintf(stderr,"  [audio disabled].\n");
                 }
+                if(convert->disable_spu){
+                    fprintf(stderr,"  [spu disabled].\n");
+                }
                 if(convert->sync){
                     fprintf(stderr,"  Use A/V Sync from input container.\n");
                 }
@@ -2083,7 +2287,7 @@
                   info.duration = convert->context->duration / AV_TIME_BASE;
                 }
                 ff2theora_output (convert);
-                convert->audio_index =convert->video_index = -1;
+                convert->audio_index = convert->video_index = convert->spu_index -1;
             }
             else{
               if(info.frontend)
diff -ru ffmpeg2theora/subtitles.txt ffmpeg2theora-kate/subtitles.txt
--- ffmpeg2theora/subtitles.txt	2008-04-13 19:50:54.000000000 +0100
+++ ffmpeg2theora-kate/subtitles.txt	2008-04-07 20:43:09.000000000 +0100
@@ -15,7 +15,7 @@
 information on converting SubRip files with other encodings to utf-8.
 
 Subtitles support requires libkate, available from:
-http://code.google.com/p/libkate
+http://libkate.googlecode.com/
 
 A subtitles input file is given with the --subtitles option.
 The language of subtitles in a file is given by the --subtitles-language
diff -ru ffmpeg2theora/theorautils.c ffmpeg2theora-kate/theorautils.c
--- ffmpeg2theora/theorautils.c	2008-04-13 19:50:54.000000000 +0100
+++ ffmpeg2theora-kate/theorautils.c	2008-04-05 12:06:08.000000000 +0100
@@ -573,6 +573,56 @@
 }
     
 /**    
+ * adds a subtitles bitmap to the encoding sink
+ * if e_o_s is 1 the end of the logical bitstream will be marked.
+ * @param info oggmux_info
+ * @param idx which kate stream to output to
+ * @param t0 the show time of the text
+ * @param t1 the hide time of the text
+ * @param kb the bitmap to add
+ * @param kp the palette to interpret the bitmap colors
+ * @param e_o_s 1 indicates end of stream
+ */
+void oggmux_add_kate_bitmap (oggmux_info *info, int idx, double t0, double t1, const kate_region *kr, const kate_bitmap *kb, const kate_palette *kp, int e_o_s){
+#ifdef HAVE_KATE
+    ogg_packet op;
+    oggmux_kate_stream *ks=info->kate_streams+idx;
+    int ret;
+    ret = kate_encode_set_region(&ks->k, kr);
+    if (ret < 0) {
+      fprintf(stderr, "Failed to set region: %d\n", ret);
+    }
+    ret = kate_encode_set_palette(&ks->k, kp);
+    if (ret < 0) {
+      fprintf(stderr, "Failed to set palette: %d\n", ret);
+    }
+    ret = kate_encode_set_bitmap(&ks->k, kb);
+    if (ret < 0) {
+      fprintf(stderr, "Failed to set bitmap: %d\n", ret);
+    }
+    ret = kate_ogg_encode_text(&ks->k, t0, t1, "", 0, &op);
+    if (ret>=0) {
+        ogg_stream_packetin (&ks->ko, &op);
+        info->k_pkg++;
+    }
+    else {
+        fprintf(stderr, "Failed to encode kate data packet (%f --> %f): %d",
+            t0, t1, ret);
+    }
+    if(e_o_s) {
+        ret = kate_ogg_encode_finish(&ks->k, -1, &op);
+        if (ret>=0) {
+            ogg_stream_packetin (&ks->ko, &op);
+            info->k_pkg++;
+        }
+        else {
+            fprintf(stderr, "Failed to encode kate end packet: %d", ret);
+        }
+    }
+#endif
+}
+    
+/**    
  * adds a kate end packet to the encoding sink
  * @param info oggmux_info
  * @param idx which kate stream to output to
diff -ru ffmpeg2theora/theorautils.h ffmpeg2theora-kate/theorautils.h
--- ffmpeg2theora/theorautils.h	2008-04-13 19:50:54.000000000 +0100
+++ ffmpeg2theora-kate/theorautils.h	2008-04-06 11:09:34.000000000 +0100
@@ -133,6 +133,7 @@
 extern void oggmux_add_video (oggmux_info *info, yuv_buffer *yuv, int e_o_s);
 extern void oggmux_add_audio (oggmux_info *info, int16_t * readbuffer, int bytesread, int samplesread,int e_o_s);
 extern void oggmux_add_kate_text (oggmux_info *info, int idx, double t0, double t1, const char *text, size_t len,int e_o_s);
+extern void oggmux_add_kate_bitmap (oggmux_info *info, int idx, double t0, double t1, const kate_region *kr, const kate_bitmap *kb, const kate_palette *kp,int e_o_s);
 extern void oggmux_add_kate_end_packet (oggmux_info *info, int idx, double t);
 extern void oggmux_flush (oggmux_info *info, int e_o_s);
 extern void oggmux_close (oggmux_info *info);
