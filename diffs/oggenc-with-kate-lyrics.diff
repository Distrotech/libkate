=== modified file 'README'
--- README	2007-05-28 08:47:18 +0000
+++ README	2008-09-12 07:20:45 +0000
@@ -26,7 +26,7 @@
 with the header files).  Additionally, ogg123 requires libao, libcurl,
 and a POSIX-compatible thread library.  Ogg123 can optionally compiled
 to use libFLAC, libOggFLAC, and libspeex.  Oggenc can be optionally
-compiled with libFLAC and libOggFLAC.  The libraries libogg,
+compiled with libFLAC, libOggFLAC, and libkate.  The libraries libogg,
 libvorbis, and libao are all available at
   http://www.vorbis.com/download.psp
 
@@ -40,6 +40,9 @@
 Speex is available at:
   http://www.speex.org/
 
+libkate is available at:
+  http://libkate.googlecode.com/
+
 CONTACT:
 
 The Ogg Vorbis homepage is located at 'http://www.vorbis.com'. Up to

=== modified file 'configure.ac'
--- configure.ac	2008-08-24 08:22:58 +0000
+++ configure.ac	2008-09-14 14:28:05 +0000
@@ -406,7 +406,7 @@
 will NOT be built with http support.])
     fi
     if test "x$HAVE_KATE" != xyes; then
-        AC_MSG_WARN([Kate libraries and/or headers missing, ogginfo 
-will be built with LIMITED Kate read support.])
+        AC_MSG_WARN([Kate libraries and/or headers missing, oggenc 
+will NOT be built with Kate lyrics support.])
     fi
 fi

=== modified file 'oggenc/Makefile.am'
--- oggenc/Makefile.am	2007-11-15 08:33:06 +0000
+++ oggenc/Makefile.am	2008-09-10 10:46:38 +0000
@@ -13,16 +13,16 @@
 
 bin_PROGRAMS = oggenc
 
-INCLUDES = @SHARE_CFLAGS@ @OGG_CFLAGS@ @VORBIS_CFLAGS@ @I18N_CFLAGS@
+INCLUDES = @SHARE_CFLAGS@ @OGG_CFLAGS@ @VORBIS_CFLAGS@ @KATE_CFLAGS@ @I18N_CFLAGS@
 
 oggenc_LDADD = @SHARE_LIBS@ \
-	       @VORBISENC_LIBS@ @VORBIS_LIBS@ @OGG_LIBS@ \
+	       @VORBISENC_LIBS@ @VORBIS_LIBS@ @KATE_LIBS@ @OGG_LIBS@ \
 	       @LIBICONV@ @I18N_LIBS@ @FLAC_LIBS@
 
 oggenc_DEPENDENCIES = @SHARE_LIBS@
 
 oggenc_SOURCES = $(flac_sources) \
-                 oggenc.c audio.c encode.c platform.c \
+                 oggenc.c audio.c encode.c platform.c lyrics.c \
                  audio.h encode.h platform.h resample.c resample.h skeleton.c skeleton.h
 
 

=== modified file 'oggenc/encode.c'
--- oggenc/encode.c	2008-02-15 04:57:33 +0000
+++ oggenc/encode.c	2008-09-18 20:33:55 +0000
@@ -25,6 +25,11 @@
 #include "i18n.h"
 #include "skeleton.h"
 
+#ifdef HAVE_KATE
+#include "lyrics.h"
+#include <kate/oggkate.h>
+#endif
+
 #define READSIZE 1024
 
 
@@ -116,7 +121,7 @@
 #endif
 }
 
-void add_fishead_packet (ogg_stream_state *os) {
+static void add_fishead_packet (ogg_stream_state *os) {
 
    fishead_packet fp;
 
@@ -130,9 +135,9 @@
 }
 
 /*
- * Adds the fishead packets in the skeleton output stream along with the e_o_s packet
+ * Adds the fishead packets in the skeleton output stream
  */
-void add_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt) {
+static void add_vorbis_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt) {
 
    fisbone_packet fp;
 
@@ -150,11 +155,53 @@
    add_fisbone_to_stream(os, &fp);
 }
 
+#ifdef HAVE_KATE
+static void add_kate_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt, kate_info *ki) {
+
+   fisbone_packet fp;
+
+   memset(&fp, 0, sizeof(fp));
+   fp.serial_no = opt->kate_serialno;
+   fp.nr_header_packet = ki->num_headers;
+   fp.granule_rate_n = ki->gps_numerator;
+   fp.granule_rate_d = ki->gps_denominator;
+   fp.start_granule = 0;
+   fp.preroll = 0;
+   fp.granule_shift = ki->granule_shift;
+
+   add_message_header_field(&fp, "Content-Type", "application/x-kate");
+
+   add_fisbone_to_stream(os, &fp);
+}
+#endif
+
+#ifdef HAVE_KATE
+static void add_kate_karaoke_style(kate_info *ki,unsigned char r,unsigned char g,unsigned char b,unsigned char a)
+{
+    kate_style *ks;
+    int ret;
+
+    if (!ki) return;
+
+    ks=(kate_style*)malloc(sizeof(kate_style));
+    kate_style_init(ks);
+    ks->text_color.r = r;
+    ks->text_color.g = g;
+    ks->text_color.b = b;
+    ks->text_color.a = a;
+    ret=kate_info_add_style(ki,ks);
+    if (ret<0) {
+      fprintf(stderr, _("WARNING - failed to add Kate karaoke style\n"));
+    }
+}
+#endif
+
 int oe_encode(oe_enc_opt *opt)
 {
 
     ogg_stream_state os;
     ogg_stream_state so; /* stream for skeleton bitstream */
+    ogg_stream_state ko; /* stream for kate bitstream */
     ogg_page         og;
     ogg_packet       op;
 
@@ -162,6 +209,15 @@
     vorbis_block     vb;
     vorbis_info      vi;
 
+#ifdef HAVE_KATE
+    kate_info        ki;
+    kate_comment     kc;
+    kate_state       k;
+    oe_lyrics        *lyrics=NULL;
+    size_t           lyrics_index=0;
+    double           vorbis_time = 0.0;
+#endif
+
     long samplesdone=0;
     int eos;
     long bytes_written = 0, packetsdone=0;
@@ -293,9 +349,37 @@
     vorbis_analysis_init(&vd,&vi);
     vorbis_block_init(&vd,&vb);
 
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        /* load lyrics */
+        lyrics=load_lyrics(opt->lyrics, oe_encoding_UTF8);
+        /* if it fails, don't do anything else for lyrics */
+        if (!lyrics) {
+            opt->lyrics = NULL;
+        } else {
+            /* init kate for encoding */
+            kate_info_init(&ki);
+            kate_info_set_category(&ki, "lyrics");
+            if (opt->lyrics_language)
+              kate_info_set_language(&ki, opt->lyrics_language);
+            else
+              fprintf(stderr, _("WARNING - no language specified for %s\n"), opt->lyrics);
+            kate_comment_init(&kc);
+            kate_encode_init(&k,&ki);
+
+            /* if we're in karaoke mode (we have syllable level timing info),
+               add style info in case some graphical player is used */
+            add_kate_karaoke_style(&ki, 255, 255, 255, 255);
+            add_kate_karaoke_style(&ki, 255, 128, 128, 255);
+        }
+    }
+#endif
+
     ogg_stream_init(&os, opt->serialno);
-    if (opt->with_skeleton) 
+    if (opt->with_skeleton)
         ogg_stream_init(&so, opt->skeleton_serialno);
+    if (opt->lyrics)
+        ogg_stream_init(&ko, opt->kate_serialno);
 
     /* create the skeleton fishead packet and output it */ 
     if (opt->with_skeleton) { 
@@ -319,7 +403,7 @@
                 &header_main,&header_comments,&header_codebooks);
 
         /* And stream them out */
-        /* output the vorbis bos first, then the fisbone packets */
+        /* output the vorbis bos first, then the kate bos, then the fisbone packets */
         ogg_stream_packetin(&os,&header_main);
 	while((result = ogg_stream_flush(&os, &og)))
         {
@@ -333,13 +417,48 @@
             }
         }
 
+#ifdef HAVE_KATE
+        if (opt->lyrics) {
+            ogg_packet kate_op;
+            ret = kate_ogg_encode_headers(&k, &kc, &kate_op);
+            if (ret < 0) {
+                opt->error("Failed encoding Kate header\n");
+                goto cleanup; 
+            }
+            ogg_stream_packetin(&ko,&kate_op);
+	    while((result = ogg_stream_flush(&ko, &og)))
+            {
+                if(!result) break;
+                ret = oe_write_page(&og, opt->out);
+                if(ret != og.header_len + og.body_len)
+                {
+                    opt->error(_("Failed writing header to output stream\n"));
+                    ret = 1;
+                    goto cleanup; /* Bail and try to clean up stuff */
+                }
+            }
+            ogg_packet_clear(&kate_op);
+        }
+#endif
+
         if (opt->with_skeleton) {
-            add_fisbone_packet(&so, opt);
+            add_vorbis_fisbone_packet(&so, opt);
             if ((ret = flush_ogg_stream_to_file(&so, opt->out))) {
                 opt->error("Failed writing fisbone header packet to output stream\n");
                 goto cleanup; 
-           }
+            }
+#ifdef HAVE_KATE
+            if (opt->lyrics) {
+                add_kate_fisbone_packet(&so, opt, &ki);
+                if ((ret = flush_ogg_stream_to_file(&so, opt->out))) {
+                    opt->error("Failed writing fisbone header packet to output stream\n");
+                    goto cleanup; 
+                }
+            }
+#endif
         }
+
+        /* write the next Vorbis headers */
         ogg_stream_packetin(&os,&header_comments);
         ogg_stream_packetin(&os,&header_codebooks);
 
@@ -356,6 +475,27 @@
         }
     }
 
+    /* build kate headers if requested */
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        while (kate_ogg_encode_headers(&k,&kc,&op)==0) {
+          ogg_stream_packetin(&ko,&op);
+          ogg_packet_clear(&op);
+        }
+        while((result = ogg_stream_flush(&ko, &og)))
+        {
+            if(!result) break;
+            ret = oe_write_page(&og, opt->out);
+            if(ret != og.header_len + og.body_len)
+            {
+                opt->error(_("Failed writing header to output stream\n"));
+                ret = 1;
+                goto cleanup; /* Bail and try to clean up stuff */
+            }
+        }
+    }
+#endif
+
     if (opt->with_skeleton) { 
         add_eos_packet_to_stream(&so); 
         if ((ret = flush_ogg_stream_to_file(&so, opt->out))) { 
@@ -420,6 +560,53 @@
                     int result = ogg_stream_pageout(&os,&og);
                     if(!result) break;
 
+                    /* now that we have a new Vorbis page, we scan lyrics for any that is due */
+#ifdef HAVE_KATE
+                    if (opt->lyrics && ogg_page_granulepos(&og)>=0) {
+                        vorbis_time = vorbis_granule_time(&vd, ogg_page_granulepos(&og));
+                        const oe_lyrics_item *item;
+                        while ((item = get_lyrics(lyrics, vorbis_time, &lyrics_index))) {
+                            ogg_packet kate_op;
+                            if (item->km) {
+                                ret = kate_encode_set_style_index(&k, 0);
+                                if (ret < 0) {
+                                    opt->error(_("Failed encoding karaoke style - continuing anyway\n"));
+                                }
+                                ret = kate_encode_set_secondary_style_index(&k, 1);
+                                if (ret < 0) {
+                                    opt->error(_("Failed encoding karaoke style - continuing anyway\n"));
+                                }
+                                ret = kate_encode_add_motion(&k, item->km, 0);
+                                if (ret < 0) {
+                                    opt->error(_("Failed encoding karaoke motion - continuing anyway\n"));
+                                }
+                            }
+                            ret = kate_ogg_encode_text(&k, item->t0, item->t1, item->text, strlen(item->text)+1, &kate_op);
+                            if (ret < 0) {
+                                opt->error(_("Failed encoding lyrics - continuing anyway\n"));
+                            }
+                            else {
+                                ogg_stream_packetin(&ko, &kate_op);
+                                ogg_packet_clear(&kate_op);
+                                while (1) {
+                                    ogg_page ogk;
+                                    int result=ogg_stream_flush(&ko,&ogk);
+                                    if (!result) break;
+                                    ret = oe_write_page(&ogk, opt->out);
+                                    if(ret != ogk.header_len + ogk.body_len)
+                                    {
+                                        opt->error(_("Failed writing data to output stream\n"));
+                                        ret = 1;
+                                        goto cleanup; /* Bail */
+                                    }
+                                    else
+                                        bytes_written += ret; 
+                                }
+                            }
+                        }
+                    }
+#endif
+
                     ret = oe_write_page(&og, opt->out);
                     if(ret != og.header_len + og.body_len)
                     {
@@ -437,12 +624,58 @@
         }
     }
 
+    /* if encoding lyrics, signal EOS and cleanup the kate state */
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        ogg_packet kate_op;
+        ret = kate_ogg_encode_finish(&k, vorbis_time, &kate_op);
+        if (ret < 0) {
+            opt->error(_("Failed encoding Kate EOS packet\n"));
+        }
+        else {
+            ogg_stream_packetin(&ko,&kate_op);
+            packetsdone++;
+            ogg_packet_clear(&kate_op);
+
+            eos = 0;
+            while(!eos)
+            {
+                int result = ogg_stream_pageout(&ko,&og);
+                if(!result) break;
+
+                ret = oe_write_page(&og, opt->out);
+                if(ret != og.header_len + og.body_len)
+                {
+                    opt->error(_("Failed writing data to output stream\n"));
+                    ret = 1;
+                    goto cleanup; /* Bail */
+                }
+                else
+                    bytes_written += ret; 
+
+                if(ogg_page_eos(&og))
+                    eos = 1;
+            }
+        }
+    }
+#endif
+
     ret = 0; /* Success, set return value to 0 since other things reuse it
               * for nefarious purposes. */
 
     /* Cleanup time */
 cleanup:
 
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        ogg_stream_clear(&ko);
+        kate_clear(&k);
+        kate_info_clear(&ki);
+        kate_comment_clear(&kc);
+        free_lyrics(lyrics);
+    }
+#endif
+
     ogg_stream_clear(&os);
 
     vorbis_block_clear(&vb);

=== modified file 'oggenc/encode.h'
--- oggenc/encode.h	2008-06-09 00:59:51 +0000
+++ oggenc/encode.h	2008-09-14 14:34:53 +0000
@@ -54,14 +54,18 @@
     int date_count;
     char **genre;
     int genre_count;
+    char **lyrics;
+    int lyrics_count;
+    char **lyrics_language;
+    int lyrics_language_count;
     adv_opt *advopt;
     int advopt_count;
+
     int copy_comments;
     int with_skeleton;
-
     int quiet;
-
     int rawmode;
+
     int raw_samplesize;
     int raw_samplerate;
     int raw_channels;
@@ -70,6 +74,7 @@
     char *namefmt;
     char *namefmt_remove;
     char *namefmt_replace;
+
     char *outfile;
 
     /* All 3 in kbps */
@@ -88,7 +93,8 @@
 
     unsigned int serial;
     unsigned int skeleton_serial;
-        int fixedserial;
+    unsigned int kate_serial;
+    int fixedserial;
     int ignorelength;
 } oe_options;
 
@@ -97,6 +103,7 @@
     vorbis_comment *comments;
     unsigned int serialno;
     unsigned int skeleton_serialno;
+    unsigned int kate_serialno;
 
     audio_read_func read_samples;
     progress_func progress_update;
@@ -129,6 +136,9 @@
     char *filename;
     char *infilename;
     int ignorelength;
+
+    char *lyrics;
+    char *lyrics_language;
 } oe_enc_opt;
 
 

=== added file 'oggenc/lyrics.c'
--- oggenc/lyrics.c	1970-01-01 00:00:00 +0000
+++ oggenc/lyrics.c	2008-09-18 20:36:29 +0000
@@ -0,0 +1,513 @@
+/* OggEnc
+ **
+ ** This program is distributed under the GNU General Public License, version 2.
+ ** A copy of this license is included with this source.
+ **
+ ** This particular file may also be distributed under (at your option) any
+ ** later version of the GNU General Public License.
+ **
+ ** Copyright 2008, ogg.k.ogg.k <ogg.k.ogg.k@googlemail.com>
+ **
+ ** Portions from ffmpeg2theora, (c) j <j@v2v.cc>
+ **/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <malloc.h>
+#include <string.h>
+#include <errno.h>
+
+#ifdef HAVE_KATE
+#include <kate/oggkate.h>
+#endif
+
+#include "lyrics.h"
+#include "i18n.h"
+
+typedef enum {
+  lf_unknown,
+  lf_srt,
+  lf_lrc,
+} lyrics_format;
+
+#ifdef HAVE_KATE
+
+static char *fgets2(char *s,size_t sz,FILE *f)
+{
+    char *ret = fgets(s, sz, f);
+    if (ret) {
+      /* fixup DOS newline character */
+      char *ptr=strchr(ret, '\r');
+      if (ptr) {
+        *ptr='\n';
+        *(ptr+1)=0;
+      }
+    }
+    return ret;
+}
+
+static double hmsms2s(int h,int m,int s,int ms)
+{
+    return h*3600+m*60+s+ms/1000.0;
+}
+
+/* very simple implementation when no iconv */
+static void convert_subtitle_to_utf8(oe_encoding encoding,char *text)
+{
+  size_t nbytes;
+  char *ptr,*newtext;
+
+  if (!text || !*text) return;
+
+  switch (encoding) {
+    case oe_encoding_unset:
+      /* we don't know what encoding this is, assume utf-8 and we'll yell if it ain't */
+      break;
+    case oe_encoding_UTF8:
+      /* nothing to do, already in utf-8 */
+      break;
+    case oe_encoding_ISO_8859_1:
+      /* simple, characters above 0x7f are broken in two,
+         and code points map to the iso-8859-1 8 bit codes */
+      nbytes=0;
+      for (ptr=text;*ptr;++ptr) {
+        nbytes++;
+        if (0x80&*(unsigned char*)ptr) nbytes++;
+      }
+      newtext=(char*)malloc(1+nbytes);
+      if (!newtext) {
+        fprintf(stderr, _("Memory allocation failed - cannot convert text\n"));
+        return;
+      }
+      nbytes=0;
+      for (ptr=text;*ptr;++ptr) {
+        if (0x80&*(unsigned char*)ptr) {
+          newtext[nbytes++]=0xc0|((*(unsigned char*)ptr)>>6);
+          newtext[nbytes++]=0x80|((*(unsigned char*)ptr)&0x3f);
+        }
+        else {
+          newtext[nbytes++]=*ptr;
+        }
+      }
+      newtext[nbytes++]=0;
+      memcpy(text,newtext,nbytes);
+      free(newtext);
+      break;
+    default:
+      fprintf(stderr, _("ERROR: encoding %d not handled in conversion!\n"), encoding);
+      break;
+  }
+}
+
+static int add_lyrics(oe_lyrics *lyrics, char *text, kate_motion *km, oe_encoding encoding,double t0,double t1)
+{
+  size_t len;
+  int ret;
+
+  convert_subtitle_to_utf8(encoding,text);
+  len = strlen(text);
+  lyrics->lyrics = (oe_lyrics_item*)realloc(lyrics->lyrics, (lyrics->count+1)*sizeof(oe_lyrics_item));
+  if (!lyrics->lyrics) {
+    fprintf(stderr, _("Out of memory\n"));
+    return -1;
+  }
+  ret=kate_text_validate(kate_utf8,text,len+1);
+  if (ret<0) {
+    fprintf(stderr,_("WARNING: subtitle %s is not valid utf-8\n"),text);
+  }
+  else {
+    /* kill off trailing \n characters */
+    while (len>0) {
+      if (text[len-1]=='\n') text[--len]=0; else break;
+    }
+    lyrics->lyrics[lyrics->count].text = (char*)malloc(len+1);
+    if (!lyrics->lyrics[lyrics->count].text) {
+      fprintf(stderr, _("Out of memory\n"));
+      return -1;
+    }
+    else {
+      memcpy(lyrics->lyrics[lyrics->count].text, text, len+1);
+      lyrics->lyrics[lyrics->count].len = len;
+      lyrics->lyrics[lyrics->count].t0 = t0;
+      lyrics->lyrics[lyrics->count].t1 = t1;
+      lyrics->lyrics[lyrics->count].km = km;
+      lyrics->count++;
+    }
+  }
+  return 0;
+}
+
+static int is_line_empty(const char *s)
+{
+  /* will work fine with UTF-8 despite the appearance */
+  if (s) while (*s) {
+    if (!strchr(" \t\r\n",*s)) return 0;
+    ++s;
+  }
+  return 1;
+}
+
+static oe_lyrics *load_srt_lyrics(FILE *f, oe_encoding encoding)
+{
+    enum { need_id, need_timing, need_text };
+    int need = need_id;
+    int last_seen_id=0;
+    int ret;
+    int id;
+    static char text[4096];
+    static char str[4096];
+    int h0,m0,s0,ms0,h1,m1,s1,ms1;
+    double t0=0.0;
+    double t1=0.0;
+    oe_lyrics *lyrics;
+    unsigned int line=0;
+
+    if (!f) return NULL;
+
+    lyrics=(oe_lyrics*)malloc(sizeof(oe_lyrics));
+    if (!lyrics) return NULL;
+    lyrics->count = 0;
+    lyrics->lyrics = NULL;
+    lyrics->karaoke = 0;
+
+    fgets2(str,sizeof(str),f);
+    ++line;
+    while (!feof(f)) {
+      switch (need) {
+        case need_id:
+          if (is_line_empty(str)) {
+            /* be nice and ignore extra empty lines between records */
+          }
+          else {
+            ret=sscanf(str,"%d\n",&id);
+            if (ret!=1 || id<0) {
+              fprintf(stderr,_("WARNING - line %u: Syntax error: %s\n"),line,str);
+              free_lyrics(lyrics);
+              return NULL;
+            }
+            if (id!=last_seen_id+1) {
+              fprintf(stderr,_("WARNING - line %u: non consecutive ids: %s - pretending not to have noticed\n"),line,str);
+            }
+            last_seen_id=id;
+            need=need_timing;
+            strcpy(text,"");
+          }
+          break;
+        case need_timing:
+          /* we could use %u, but glibc accepts minus signs for %u for some reason */
+          ret=sscanf(str,"%d:%d:%d%*[.,]%d --> %d:%d:%d%*[.,]%d\n",&h0,&m0,&s0,&ms0,&h1,&m1,&s1,&ms1);
+          if (ret!=8 || (h0|m0|s0|ms0)<0 || (h1|m1|s1|ms1)<0) {
+            fprintf(stderr,_("WARNING - line %u: Syntax error: %s\n"),line,str);
+            free_lyrics(lyrics);
+            return NULL;
+          }
+          else if (t1<t0) {
+            fprintf(stderr,_("WARNING - line %u: end time must not be less than start time: %s\n"),line,str);
+            free_lyrics(lyrics);
+            return NULL;
+          }
+          else {
+            t0=hmsms2s(h0,m0,s0,ms0);
+            t1=hmsms2s(h1,m1,s1,ms1);
+          }
+          need=need_text;
+          break;
+        case need_text:
+          if (str[0]=='\n') {
+            if (add_lyrics(lyrics,text,NULL,encoding,t0,t1) < 0) {
+              free_lyrics(lyrics);
+              return NULL;
+            }
+            need=need_id;
+          }
+          else {
+            /* in case of very long lines */
+            size_t len=strlen(text);
+            if (len+strlen(str) >= sizeof(text)) {
+              fprintf(stderr, _("WARNING - line %u: text is too long - truncated\n"),line);
+            }
+            strncpy(text+len,str,sizeof(text)-len);
+            text[sizeof(text)-1]=0;
+          }
+          break;
+      }
+      fgets2(str,sizeof(str),f);
+      ++line;
+    }
+
+    if (need!=need_id) {
+      /* shouldn't be a problem though, but warn */
+      fprintf(stderr, ("WARNING - line %u: missing data in - truncated file ?\n"),line);
+    }
+
+    return lyrics;
+}
+
+static void add_kate_karaoke_tag(kate_motion *km,kate_float dt,const char *str,size_t len,int line)
+{
+  kate_curve *kc;
+  kate_float ptr=(kate_float)-0.5;
+  int ret;
+
+  if (dt<0) {
+    fprintf(stderr, _("WARNING - line %d: lyrics times must not be decreasing\n"), line);
+    return;
+  }
+
+  /* work out how many glyphs we have */
+  while (len>0) {
+    ret=kate_text_get_character(kate_utf8,&str,&len);
+    if (ret<0) {
+      fprintf(stderr, _("WARNING - line %d: failed to get UTF-8 glyph from string\n"), line);
+      return;
+    }
+    ptr+=(kate_float)1.0;
+  }
+  /* ptr now points to the middle of the glyph we're at */
+
+  kc=(kate_curve*)malloc(sizeof(kate_curve));
+  kate_curve_init(kc);
+  kc->type=kate_curve_static;
+  kc->npts=1;
+  kc->pts=(kate_float*)malloc(2*sizeof(kate_float));
+  kc->pts[0]=ptr;
+  kc->pts[1]=(kate_float)0;
+
+  km->ncurves++;
+  km->curves=(kate_curve**)realloc(km->curves,km->ncurves*sizeof(kate_curve*));
+  km->durations=(kate_float*)realloc(km->durations,km->ncurves*sizeof(kate_float));
+  km->curves[km->ncurves-1]=kc;
+  km->durations[km->ncurves-1]=dt;
+}
+
+static kate_motion *process_enhanced_lrc_tags(char *str,kate_float start_time,kate_float end_time,int line)
+{
+  char *start,*end;
+  int ret;
+  int m,s,cs;
+  kate_motion *km=NULL;
+  kate_float current_time = start_time;
+
+  if (!str) return NULL;
+
+  start=str;
+  while (1) {
+    start=strchr(start,'<');
+    if (!start) break;
+    end=strchr(start+1,'>');
+    if (!end) break;
+
+    /* we found a <> pair, parse it */
+    ret=sscanf(start,"<%d:%d.%d>",&m,&s,&cs);
+
+    /* remove the <> tag from input to get raw text */
+    memmove(start,end+1,strlen(end+1)+1);
+
+    if (ret!=3 || (m|s|cs)<0) {
+      fprintf(stderr, _("WARNING - line %d: failed to process enhanced LRC tag (%*.*s) - ignored\n"),line,(int)(end-start+1),(int)(end-start+1),start);
+    }
+    else {
+      kate_float tag_time=hmsms2s(0,m,s,cs*10);
+
+      /* if this is the first tag in this line, create a kate motion */
+      if (!km) {
+        km=(kate_motion*)malloc(sizeof(kate_motion));
+        if (!km) {
+          fprintf(stderr, _("WARNING - failed to allocate memory - enhanced LRC tag will be ignored\n"));
+        }
+        else {
+          kate_motion_init(km);
+          km->semantics=kate_motion_semantics_glyph_pointer_1;
+        }
+      }
+      /* add to the kate motion */
+      if (km) {
+        add_kate_karaoke_tag(km,tag_time-current_time,str,start-str,line);
+        current_time = tag_time;
+      }
+    }
+  }
+
+  /* if we've found karaoke info, extend the motion to the end time */
+  if (km) {
+    add_kate_karaoke_tag(km,end_time-current_time,str,strlen(str),line);
+  }
+
+  return km;
+}
+
+static oe_lyrics *load_lrc_lyrics(FILE *f, oe_encoding encoding)
+{
+  oe_lyrics *lyrics;
+  static char str[4096];
+  static char lyrics_line[4096]="";
+  int m,s,cs;
+  double t,start_time = -1.0;
+  int offset;
+  int ret;
+  unsigned line=0;
+  kate_motion *km;
+
+  if (!f) return NULL;
+
+  /* skip headers */
+  fgets2(str,sizeof(str),f);
+  ++line;
+  while (!feof(f)) {
+    ret = sscanf(str, "[%d:%d.%d]%n\n",&m,&s,&cs,&offset);
+    if (ret == 3)
+      break;
+    fgets2(str,sizeof(str),f);
+    ++line;
+  }
+  if (feof(f)) {
+    fprintf(stderr,_("WARNING - line %u: Syntax error: %s\n"),line,str);
+    return NULL;
+  }
+
+  lyrics=(oe_lyrics*)malloc(sizeof(oe_lyrics));
+  if (!lyrics) return NULL;
+  lyrics->count = 0;
+  lyrics->lyrics = NULL;
+  lyrics->karaoke = 0;
+
+  while (!feof(f)) {
+    /* ignore empty lines */
+    if (!is_line_empty(str)) {
+      ret=sscanf(str, "[%d:%d.%d]%n\n",&m,&s,&cs,&offset);
+      if (ret != 3 || (m|s|cs)<0) {
+        fprintf(stderr,_("WARNING - line %u: Syntax error: %s\n"),line,str);
+        free_lyrics(lyrics);
+        return NULL;
+      }
+      t=hmsms2s(0,m,s,cs*10);
+
+      if (start_time>=0.0 && !is_line_empty(lyrics_line)) {
+        km=process_enhanced_lrc_tags(lyrics_line,start_time,t,line);
+        if (km) {
+          lyrics->karaoke = 1;
+        }
+        if (add_lyrics(lyrics,lyrics_line,km,encoding,start_time,t) < 0) {
+          free_lyrics(lyrics);
+          return NULL;
+        }
+      }
+
+      strncpy(lyrics_line,str+offset,sizeof(lyrics_line));
+      lyrics_line[sizeof(lyrics_line)-1]=0;
+      start_time=t;
+    }
+
+    fgets2(str,sizeof(str),f);
+    ++line;
+  }
+
+  return lyrics;
+}
+
+/* very weak checks, but we only support two formats, so it's ok */
+lyrics_format probe_lyrics_format(FILE *f)
+{
+  int dummy_int;
+  static char str[4096];
+  lyrics_format format=lf_unknown;
+  long pos;
+
+  if (!f) return lf_unknown;
+
+  pos=ftell(f);
+  fgets2(str,sizeof(str),f);
+
+  /* srt */
+  if (sscanf(str, "%d\n", &dummy_int) == 1 && dummy_int>=0)
+    format=lf_srt;
+
+  /* lrc */
+  if (str[0] == '[')
+    format=lf_lrc;
+
+  fseek(f,pos,SEEK_SET);
+
+  return format;
+}
+
+#endif
+
+oe_lyrics *load_lyrics(const char *filename, oe_encoding encoding)
+{
+#ifdef HAVE_KATE
+  static char str[4096];
+  int ret;
+  oe_lyrics *lyrics=NULL;
+  FILE *f;
+
+  if (!filename) {
+      fprintf(stderr,_("WARNING - No lyrics filename to load from\n"));
+      return NULL;
+  }
+
+  f = fopen(filename, "r");
+  if (!f) {
+      fprintf(stderr,_("WARNING - Failed to open lyrics file %s (%s)\n"), filename, strerror(errno));
+      return NULL;
+  }
+
+  /* first, check for a BOM */
+  ret=fread(str,1,3,f);
+  if (ret<3 || memcmp(str,"\xef\xbb\xbf",3)) {
+    /* No BOM, rewind */
+    fseek(f,0,SEEK_SET);
+  }
+
+  switch (probe_lyrics_format(f)) {
+    case lf_srt:
+      lyrics = load_srt_lyrics(f, encoding);
+      break;
+    case lf_lrc:
+      lyrics = load_lrc_lyrics(f, encoding);
+      break;
+    default:
+      fprintf(stderr, _("Failed to load %s - can't determine format\n"), filename);
+      break;
+  }
+
+  fclose(f);
+
+  return lyrics;
+#else
+  return NULL;
+#endif
+}
+
+void free_lyrics(oe_lyrics *lyrics)
+{
+    size_t n,c;
+    if (lyrics) {
+        for (n=0; n<lyrics->count; ++n) {
+          oe_lyrics_item *li=&lyrics->lyrics[n];
+          free(li->text);
+          if (li->km) {
+            for (c=0; c<li->km->ncurves; ++c) {
+              free(li->km->curves[c]->pts);
+              free(li->km->curves[c]);
+            }
+            free(li->km->curves);
+            free(li->km->durations);
+            free(li->km);
+          }
+        }
+        free(lyrics->lyrics);
+        free(lyrics);
+    }
+}
+
+const oe_lyrics_item *get_lyrics(const oe_lyrics *lyrics, double t, size_t *idx)
+{
+    if (!lyrics || *idx>=lyrics->count) return NULL;
+    if (lyrics->lyrics[*idx].t0 > t) return NULL;
+    return &lyrics->lyrics[(*idx)++];
+}
+

=== added file 'oggenc/lyrics.h'
--- oggenc/lyrics.h	1970-01-01 00:00:00 +0000
+++ oggenc/lyrics.h	2008-09-12 07:23:53 +0000
@@ -0,0 +1,38 @@
+#ifndef __LYRICS_H
+#define __LYRICS_H
+
+#include <stddef.h>
+#ifdef HAVE_KATE
+#include <kate/kate.h>
+#endif
+
+#define SUPPORTED_ENCODINGS "utf-8, utf8, iso-8859-1, latin1"
+
+typedef enum {
+  oe_encoding_unset,
+  oe_encoding_UTF8,
+  oe_encoding_ISO_8859_1,
+} oe_encoding;
+
+typedef struct oe_lyrics_item {
+    char *text;
+    size_t len;
+    double t0;
+    double t1;
+#ifdef HAVE_KATE
+    kate_motion *km;
+#endif
+} oe_lyrics_item;
+
+typedef struct oe_lyrics {
+    size_t count;
+    oe_lyrics_item *lyrics;
+    int karaoke;
+} oe_lyrics;
+
+extern oe_lyrics *load_lyrics(const char *filename, oe_encoding encoding);
+extern void free_lyrics(oe_lyrics *lyrics);
+extern const oe_lyrics_item *get_lyrics(const oe_lyrics *lyrics, double t, size_t *idx);
+
+#endif
+

=== modified file 'oggenc/man/oggenc.1'
--- oggenc/man/oggenc.1	2008-09-09 21:06:32 +0000
+++ oggenc/man/oggenc.1	2008-09-12 07:19:21 +0000
@@ -78,6 +78,14 @@
 .B -G
 .I genre
 ]
+[
+.B -L
+.I lyrics file
+]
+[
+.B -Y
+.I lyrics-language language-string
+]
 .I input_files \fR...
 
 .SH DESCRIPTION
@@ -102,6 +110,9 @@
 are available, the output filename will be the input filename with the
 extension (that part after the final dot) replaced with ogg, so file.wav
 will become file.ogg
+.br
+Optionally, lyrics may be embedded in the Ogg file, if Kate support was compiled in. Note, however, that multiplexing a Kate
+stream with Vorbis may cause some players to fail to play the stream, as they expect a single stream in the Ogg file.
 
 .SH OPTIONS
 .IP "-h, --help"
@@ -199,11 +210,21 @@
 .IP "-l album, --album album"
 Set the album comment field to
 .I album.
+
+.IP "-L filename, --lyrics filename"
+Loads lyrics from
+.I filename
+, and encodes them in a Kate stream multiplexed with the Vorbis stream.
+
+.IP "-Y language-string, --lyrics-language language-string"
+Sets the language for the corresponding lyrics file to
+.I language-string.
+This should be an ISO 639-1 language code, or a RFC 3066 language tag.
 .PP
 
-Note that the \fB-a\fR, \fB-t\fR, and \fB-l\fR options can be given
-multiple times.  They will be applied, one to each file, in the order
-given.  If there are fewer album, title, or artist comments given than
+Note that the \fB-a\fR, \fB-t\fR, \fB-l\fR, \fB-L\fR, and \fb-Y\fR  options
+can be given multiple times.  They will be applied, one to each file, in the
+order given.  If there are fewer album, title, or artist comments given than
 there are input files,
 .B oggenc
 will reuse the final one for the remaining files, and issue a warning
@@ -331,6 +352,12 @@
 .RE
 .PP
 
+Adding embedded lyrics.
+.RS
+oggenc somefile.wav --lyrics lyrics.lrc --lyrics-language en -o out.ogg
+.RE
+.PP
+
 This encodes the three files, each with the
 same artist/album tag, but with different title tags on each one. The
 string given as an argument to -n is used to generate filenames, as shown

=== modified file 'oggenc/oggenc.c'
--- oggenc/oggenc.c	2008-09-09 21:04:15 +0000
+++ oggenc/oggenc.c	2008-09-18 20:26:14 +0000
@@ -63,6 +63,8 @@
     {"advanced-encode-option", 1, 0, 0},
     {"discard-comments", 0, 0, 0},
     {"ignorelength", 0, 0, 0},
+    {"lyrics",1,0,'L'},
+    {"lyrics-language",1,0,'Y'},
     {NULL,0,0,0}
 };
 
@@ -78,10 +80,17 @@
 int main(int argc, char **argv)
 {
     /* Default values */
-    oe_options opt = {NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL,
-              0, NULL, 0, NULL, 0, NULL, 0, 1, 0, 0, 0,16,44100,2, 0, NULL,
-              DEFAULT_NAMEFMT_REMOVE, DEFAULT_NAMEFMT_REPLACE,
-              NULL, 0, -1,-1,-1,.3,-1,0, 0,0.f, 0, 0, 0};
+    oe_options opt = {
+              NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+              NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+              1, 0, 0, 0,
+              16,44100,2, 0,
+              NULL, DEFAULT_NAMEFMT_REMOVE, DEFAULT_NAMEFMT_REPLACE,
+              NULL,
+              0, -1,-1,-1,
+              .3,-1,
+              0,0,0.f,
+              0, 0, 0, 0, 0};
 
     int i;
 
@@ -129,6 +138,7 @@
         srand(time(NULL));
         opt.serial = rand();
         opt.skeleton_serial = opt.serial + numfiles;
+        opt.kate_serial = opt.skeleton_serial + numfiles;
     }
 
     for(i = 0; i < numfiles; i++)
@@ -143,6 +153,7 @@
         int closeout = 0, closein = 0;
         char *artist=NULL, *album=NULL, *title=NULL, *track=NULL;
         char *date=NULL, *genre=NULL;
+        char *lyrics=NULL, *lyrics_language=NULL;
         input_format *format;
         int resampled = 0;
 
@@ -150,6 +161,7 @@
 
         enc_opts.serialno = opt.serial++;
         enc_opts.skeleton_serialno = opt.skeleton_serial++;
+        enc_opts.kate_serialno = opt.kate_serial++;
         enc_opts.progress_update = update_statistics_full;
         enc_opts.start_encode = start_encode_full;
         enc_opts.end_encode = final_statistics;
@@ -163,6 +175,28 @@
         build_comments(&vc, &opt, i, &artist, &album, &title, &track,
                 &date, &genre);
 
+        if(opt.lyrics_count)
+        {
+            if(i >= opt.lyrics_count)
+            {
+                lyrics = NULL;
+            }
+            else
+                lyrics = opt.lyrics[i];
+        }
+
+        if(opt.lyrics_language_count)
+        {
+            if(i >= opt.lyrics_language_count)
+            {
+                if(!opt.quiet)
+                    fprintf(stderr, _("WARNING: Insufficient lyrics languages specified, defaulting to final lyrics language.\n"));
+                lyrics_language = opt.lyrics_language[opt.lyrics_language_count-1];
+            }
+            else
+                lyrics_language = opt.lyrics_language[i];
+        }
+
         if(!strcmp(infiles[i], "-"))
         {
             setbinmode(stdin);
@@ -267,15 +301,20 @@
                 end = strrchr(infiles[i], '.');
                 end = end?end:(start + strlen(infiles[i])+1);
 
-                extension = (opt.with_skeleton) ? ".oga" : ".ogg";
+                /* if adding skeleton or kate, we're not Vorbis I anymore */
+                extension = (opt.with_skeleton || opt.lyrics_count>0) ? ".oga" : ".ogg";
                 out_fn = malloc(end - start + 5);
                 strncpy(out_fn, start, end-start);
                 out_fn[end-start] = 0;
                 strcat(out_fn, extension);
             }
             else {
-                fprintf(stderr, _("WARNING: No filename, defaulting to \"default.ogg\"\n"));
-                out_fn = strdup("default.ogg");
+                /* if adding skeleton or kate, we're not Vorbis I anymore */
+                if (opt.with_skeleton || opt.lyrics_count>0)
+                    out_fn = strdup("default.oga");
+                else
+                    out_fn = strdup("default.ogg");
+                fprintf(stderr, _("WARNING: No filename, defaulting to \"%s\"\n"), out_fn);
             }
 
             /* Create any missing subdirectories, if possible */
@@ -321,6 +360,8 @@
         enc_opts.quality_set = opt.quality_set;
         enc_opts.advopt = opt.advopt;
         enc_opts.advopt_count = opt.advopt_count;
+        enc_opts.lyrics = lyrics;
+        enc_opts.lyrics_language = lyrics_language;
 
         if(opt.resamplefreq && opt.resamplefreq != enc_opts.rate) {
             int fromrate = enc_opts.rate;
@@ -482,15 +523,20 @@
         " -a, --artist         Name of artist\n"
         " -G, --genre          Genre of track\n"));
     fprintf(stdout, _(
+        " -L, --lyrics         Include lyrics from given file (.srt or .lrc format)\n"
+        " -Y, --lyrics-language  Sets the language for the lyrics\n"));
+    fprintf(stdout, _(
         "                      If multiple input files are given, then multiple\n"
-        "                      instances of the previous five arguments will be used,\n"
+        "                      instances of the previous eight arguments will be used,\n"
         "                      in the order they are given. If fewer titles are\n"
         "                      specified than files, OggEnc will print a warning, and\n"
         "                      reuse the final one for the remaining files. If fewer\n"
         "                      track numbers are given, the remaining files will be\n"
-        "                      unnumbered. For the others, the final tag will be reused\n"
-        "                      for all others without warning (so you can specify a date\n"
-        "                      once, for example, and have it used for all the files)\n"
+        "                      unnumbered. If fewer lyrics are given, the remaining\n"
+        "                      files will not have lyrics added. For the others, the\n"
+        "                      final tag will be reused for all others without warning\n"
+        "                      (so you can specify a date once, for example, and have\n"
+        "                      it used for all the files)\n"
         "\n"));
     fprintf(stdout, _(
         "INPUT FILES:\n"
@@ -503,6 +549,7 @@
         " You can specify taking the file from stdin by using - as the input filename.\n"
         " In this mode, output is to stdout unless an output filename is specified\n"
         " with -o\n"
+        " Lyrics files may be in SubRip (.srt) or LRC (.lrc) format\n"
         "\n"));
 }
 
@@ -614,7 +661,7 @@
     int ret;
     int option_index = 1;
 
-    while((ret = getopt_long(argc, argv, "A:a:b:B:c:C:d:G:hkl:m:M:n:N:o:P:q:QrR:s:t:VX:",
+    while((ret = getopt_long(argc, argv, "A:a:b:B:c:C:d:G:hklL:m:M:n:N:o:P:q:QrR:s:t:VX:Y:",
                     long_options, &option_index)) != -1)
     {
         switch(ret)
@@ -873,6 +920,26 @@
             case 'k':
                 opt->with_skeleton = 1;
                 break;
+            case 'L':
+#ifdef HAVE_KATE
+                opt->lyrics = realloc(opt->lyrics, (++opt->lyrics_count)*sizeof(char *));
+                opt->lyrics[opt->lyrics_count - 1] = strdup(optarg);
+#else
+                fprintf(stderr, _("WARNING: Kate support not compiled in, lyrics will not be included.\n"));
+#endif
+                break;
+            case 'Y':
+#ifdef HAVE_KATE
+                opt->lyrics_language = realloc(opt->lyrics_language, (++opt->lyrics_language_count)*sizeof(char *));
+                opt->lyrics_language[opt->lyrics_language_count - 1] = strdup(optarg);
+                if (strlen(opt->lyrics_language[opt->lyrics_language_count - 1]) > 15) {
+                  fprintf(stderr, _("WARNING: language can not be longer than 15 characters: truncated.\n"));
+                  opt->lyrics_language[opt->lyrics_language_count - 1][15] = 0;
+                }
+#else
+                fprintf(stderr, _("WARNING: Kate support not compiled in, lyrics will not be included.\n"));
+#endif
+                break;
             case '?':
                 fprintf(stderr, _("WARNING: Unknown option specified, ignoring->\n"));
                 break;

=== modified file 'ogginfo/ogginfo2.c'
--- ogginfo/ogginfo2.c	2008-09-09 20:22:27 +0000
+++ ogginfo/ogginfo2.c	2008-09-14 14:21:22 +0000
@@ -626,7 +626,7 @@
             /* Only do this if we saw at least one packet ending on this page.
              * It's legal (though very unusual) to have no packets in a page at
              * all - this is occasionally used to have an empty EOS page */
-            warn(_("Negative or zero granulepos (%lld) on vorbis stream outside of headers. This file was created by a buggy encoder\n"), gp);
+            warn(_("Negative or zero granulepos (%" I64FORMAT ") on vorbis stream outside of headers. This file was created by a buggy encoder\n"), gp);
         }
         if(inf->firstgranulepos < 0) { /* Not set yet */
         }
@@ -824,7 +824,7 @@
             /* Only do this if we saw at least one packet ending on this page.
              * It's legal (though very unusual) to have no packets in a page at
              * all - this is occasionally used to have an empty EOS page */
-            warn(_("Negative granulepos (%lld) on kate stream outside of headers. This file was created by a buggy encoder\n"), gp);
+            warn(_("Negative granulepos (%" I64FORMAT ") on kate stream outside of headers. This file was created by a buggy encoder\n"), gp);
         }
         if(inf->firstgranulepos < 0) { /* Not set yet */
         }
@@ -1100,9 +1100,13 @@
     int bytes;
 
     while((ret = ogg_sync_pageseek(sync, page)) <= 0) {
-        if(ret < 0)
-            warn(_("Warning: Hole in data (%d bytes) found at approximate offset %" I64FORMAT " bytes. Corrupted ogg.\n"), *written);
+        if(ret < 0) {
+            /* unsynced, we jump over bytes to a possible capture - we don't need to read more just yet */
+            warn(_("Warning: Hole in data (%d bytes) found at approximate offset %" I64FORMAT " bytes. Corrupted ogg.\n"), -ret, *written);
+            continue;
+        }
 
+        /* zero return, we didn't have enough data to find a whole page, read */
         buffer = ogg_sync_buffer(sync, CHUNK);
         bytes = fread(buffer, 1, CHUNK, f);
         if(bytes <= 0) {

