diff -ru ../../../svn/xiph/vorbis-tools/oggenc/encode.c oggenc/encode.c
--- ../../../svn/xiph/vorbis-tools/oggenc/encode.c	2008-04-15 13:57:29.000000000 +0100
+++ oggenc/encode.c	2008-07-14 19:05:10.000000000 +0100
@@ -25,6 +25,11 @@
 #include "i18n.h"
 #include "skeleton.h"
 
+#ifdef HAVE_KATE
+#include "lyrics.h"
+#include <kate/oggkate.h>
+#endif
+
 #define READSIZE 1024
 
 
@@ -116,7 +121,7 @@
 #endif
 }
 
-void add_fishead_packet (ogg_stream_state *os) {
+static void add_fishead_packet (ogg_stream_state *os) {
 
    fishead_packet fp;
 
@@ -130,9 +135,9 @@
 }
 
 /*
- * Adds the fishead packets in the skeleton output stream along with the e_o_s packet
+ * Adds the fishead packets in the skeleton output stream
  */
-void add_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt) {
+static void add_vorbis_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt) {
 
    fisbone_packet fp;
 
@@ -150,11 +155,32 @@
    add_fisbone_to_stream(os, &fp);
 }
 
+#ifdef HAVE_KATE
+static void add_kate_fisbone_packet (ogg_stream_state *os, oe_enc_opt *opt, kate_info *ki) {
+
+   fisbone_packet fp;
+
+   memset(&fp, 0, sizeof(fp));
+   fp.serial_no = opt->kate_serialno;
+   fp.nr_header_packet = ki->num_headers;
+   fp.granule_rate_n = ki->gps_numerator;
+   fp.granule_rate_d = ki->gps_denominator;
+   fp.start_granule = 0;
+   fp.preroll = 0;
+   fp.granule_shift = ki->granule_shift;
+
+   add_message_header_field(&fp, "Content-Type", "application/x-kate");
+
+   add_fisbone_to_stream(os, &fp);
+}
+#endif
+
 int oe_encode(oe_enc_opt *opt)
 {
 
     ogg_stream_state os;
     ogg_stream_state so; /* stream for skeleton bitstream */
+    ogg_stream_state ko; /* stream for kate bitstream */
     ogg_page         og;
     ogg_packet       op;
 
@@ -162,6 +188,15 @@
     vorbis_block     vb;
     vorbis_info      vi;
 
+#ifdef HAVE_KATE
+    kate_info        ki;
+    kate_comment     kc;
+    kate_state       k;
+    oe_lyrics        *lyrics=NULL;
+    size_t           lyrics_index=0;
+    double           vorbis_time = 0.0;
+#endif
+
     long samplesdone=0;
     int eos;
     long bytes_written = 0, packetsdone=0;
@@ -293,9 +328,28 @@
     vorbis_analysis_init(&vd,&vi);
     vorbis_block_init(&vd,&vb);
 
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        /* load lyrics */
+        lyrics=load_lyrics(opt->lyrics, oe_encoding_unset);
+        /* if it fails, don't do anything else for lyrics */
+        if (!lyrics) {
+            opt->lyrics = NULL;
+        } else {
+            /* init kate for encoding */
+            kate_info_init(&ki);
+            kate_info_set_category(&ki, "lyrics");
+            kate_comment_init(&kc);
+            kate_encode_init(&k,&ki);
+        }
+    }
+#endif
+
     ogg_stream_init(&os, opt->serialno);
-    if (opt->with_skeleton) 
+    if (opt->with_skeleton)
         ogg_stream_init(&so, opt->skeleton_serialno);
+    if (opt->lyrics)
+        ogg_stream_init(&ko, opt->kate_serialno);
 
     /* create the skeleton fishead packet and output it */ 
     if (opt->with_skeleton) { 
@@ -319,7 +373,7 @@
                 &header_main,&header_comments,&header_codebooks);
 
         /* And stream them out */
-        /* output the vorbis bos first, then the fisbone packets */
+        /* output the vorbis bos first, then the kate bos, then the fisbone packets */
         ogg_stream_packetin(&os,&header_main);
 	while((result = ogg_stream_flush(&os, &og)))
         {
@@ -333,13 +387,48 @@
             }
         }
 
+#ifdef HAVE_KATE
+        if (opt->lyrics) {
+            ogg_packet kate_op;
+            ret = kate_ogg_encode_headers(&k, &kc, &kate_op);
+            if (ret < 0) {
+                opt->error("Failed encoding Kate header\n");
+                goto cleanup; 
+            }
+            ogg_stream_packetin(&ko,&kate_op);
+	    while((result = ogg_stream_flush(&ko, &og)))
+            {
+                if(!result) break;
+                ret = oe_write_page(&og, opt->out);
+                if(ret != og.header_len + og.body_len)
+                {
+                    opt->error(_("Failed writing header to output stream\n"));
+                    ret = 1;
+                    goto cleanup; /* Bail and try to clean up stuff */
+                }
+            }
+            ogg_packet_clear(&kate_op);
+        }
+#endif
+
         if (opt->with_skeleton) {
-            add_fisbone_packet(&so, opt);
+            add_vorbis_fisbone_packet(&so, opt);
             if ((ret = flush_ogg_stream_to_file(&so, opt->out))) {
                 opt->error("Failed writing fisbone header packet to output stream\n");
                 goto cleanup; 
-           }
+            }
+#ifdef HAVE_KATE
+            if (opt->lyrics) {
+                add_kate_fisbone_packet(&so, opt, &ki);
+                if ((ret = flush_ogg_stream_to_file(&so, opt->out))) {
+                    opt->error("Failed writing fisbone header packet to output stream\n");
+                    goto cleanup; 
+                }
+            }
+#endif
         }
+
+        /* write the next Vorbis headers */
         ogg_stream_packetin(&os,&header_comments);
         ogg_stream_packetin(&os,&header_codebooks);
 
@@ -356,6 +445,27 @@
         }
     }
 
+    /* build kate headers if requested */
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        while (kate_ogg_encode_headers(&k,&kc,&op)==0) {
+          ogg_stream_packetin(&ko,&op);
+          ogg_packet_clear(&op);
+        }
+        while((result = ogg_stream_flush(&ko, &og)))
+        {
+            if(!result) break;
+            ret = oe_write_page(&og, opt->out);
+            if(ret != og.header_len + og.body_len)
+            {
+                opt->error(_("Failed writing header to output stream\n"));
+                ret = 1;
+                goto cleanup; /* Bail and try to clean up stuff */
+            }
+        }
+    }
+#endif
+
     if (opt->with_skeleton) { 
         add_eos_packet_to_stream(&so); 
         if ((ret = flush_ogg_stream_to_file(&so, opt->out))) { 
@@ -420,6 +530,39 @@
                     int result = ogg_stream_pageout(&os,&og);
                     if(!result) break;
 
+                    /* now that we have a new Vorbis page, we scan lyrics for any that is due */
+#ifdef HAVE_KATE
+                    if (opt->lyrics && ogg_page_granulepos(&og)>=0) {
+                        vorbis_time = vorbis_granule_time(&vd, ogg_page_granulepos(&og));
+                        const oe_lyrics_item *item;
+                        while ((item = get_lyrics(lyrics, vorbis_time, &lyrics_index))) {
+                            ogg_packet kate_op;
+                            ret = kate_ogg_encode_text(&k, item->t0, item->t1, item->text, strlen(item->text)+1, &kate_op);
+                            if (ret < 0) {
+                                opt->error(_("Failed encoding lyrics - continuing anyway\n"));
+                            }
+                            else {
+                                ogg_stream_packetin(&ko, &kate_op);
+                                ogg_packet_clear(&kate_op);
+                                while (1) {
+                                    ogg_page ogk;
+                                    int result=ogg_stream_flush(&ko,&ogk);
+                                    if (!result) break;
+                                    ret = oe_write_page(&ogk, opt->out);
+                                    if(ret != ogk.header_len + ogk.body_len)
+                                    {
+                                        opt->error(_("Failed writing data to output stream\n"));
+                                        ret = 1;
+                                        goto cleanup; /* Bail */
+                                    }
+                                    else
+                                        bytes_written += ret; 
+                                }
+                            }
+                        }
+                    }
+#endif
+
                     ret = oe_write_page(&og, opt->out);
                     if(ret != og.header_len + og.body_len)
                     {
@@ -437,6 +580,47 @@
         }
     }
 
+    /* if encoding lyrics, signal EOS and cleanup the kate state */
+#ifdef HAVE_KATE
+    if (opt->lyrics) {
+        ogg_packet kate_op;
+        ret = kate_ogg_encode_finish(&k, vorbis_time, &kate_op);
+        if (ret < 0) {
+            opt->error(_("Failed encoding Kate EOS packet\n"));
+        }
+        else {
+            ogg_stream_packetin(&ko,&kate_op);
+            packetsdone++;
+            ogg_packet_clear(&kate_op);
+
+            eos = 0;
+            while(!eos)
+            {
+                int result = ogg_stream_pageout(&ko,&og);
+                if(!result) break;
+
+                ret = oe_write_page(&og, opt->out);
+                if(ret != og.header_len + og.body_len)
+                {
+                    opt->error(_("Failed writing data to output stream\n"));
+                    ret = 1;
+                    goto cleanup; /* Bail */
+                }
+                else
+                    bytes_written += ret; 
+
+                if(ogg_page_eos(&og))
+                    eos = 1;
+            }
+        }
+        ogg_stream_clear(&ko);
+        kate_clear(&k);
+        kate_info_clear(&ki);
+        kate_comment_clear(&kc);
+        free_lyrics(lyrics);
+    }
+#endif
+
     ret = 0; /* Success, set return value to 0 since other things reuse it
               * for nefarious purposes. */
 
diff -ru ../../../svn/xiph/vorbis-tools/oggenc/encode.h oggenc/encode.h
--- ../../../svn/xiph/vorbis-tools/oggenc/encode.h	2008-04-15 13:57:29.000000000 +0100
+++ oggenc/encode.h	2008-07-13 11:08:01.000000000 +0100
@@ -54,6 +54,8 @@
     int date_count;
     char **genre;
     int genre_count;
+    char **lyrics;
+    int lyrics_count;
     adv_opt *advopt;
     int advopt_count;
     int copy_comments;
@@ -88,6 +90,7 @@
 
     unsigned int serial;
     unsigned int skeleton_serial;
+    unsigned int kate_serial;
         int fixedserial;
 } oe_options;
 
@@ -96,6 +99,7 @@
     vorbis_comment *comments;
     unsigned int serialno;
     unsigned int skeleton_serialno;
+    unsigned int kate_serialno;
 
     audio_read_func read_samples;
     progress_func progress_update;
@@ -127,6 +131,8 @@
     FILE *out;
     char *filename;
     char *infilename;
+
+    char *lyrics;
 } oe_enc_opt;
 
 
diff -ru ../../../svn/xiph/vorbis-tools/oggenc/Makefile.am oggenc/Makefile.am
--- ../../../svn/xiph/vorbis-tools/oggenc/Makefile.am	2008-04-15 13:57:29.000000000 +0100
+++ oggenc/Makefile.am	2008-07-14 19:05:37.000000000 +0100
@@ -13,16 +13,16 @@
 
 bin_PROGRAMS = oggenc
 
-INCLUDES = @SHARE_CFLAGS@ @OGG_CFLAGS@ @VORBIS_CFLAGS@ @I18N_CFLAGS@
+INCLUDES = @SHARE_CFLAGS@ @OGG_CFLAGS@ @VORBIS_CFLAGS@ @KATE_CFLAGS@ @I18N_CFLAGS@
 
 oggenc_LDADD = @SHARE_LIBS@ \
-	       @VORBISENC_LIBS@ @VORBIS_LIBS@ @OGG_LIBS@ \
+	       @VORBISENC_LIBS@ @VORBIS_LIBS@ @KATE_LIBS@ @OGG_LIBS@ \
 	       @LIBICONV@ @I18N_LIBS@ @FLAC_LIBS@
 
 oggenc_DEPENDENCIES = @SHARE_LIBS@
 
 oggenc_SOURCES = $(flac_sources) \
-                 oggenc.c audio.c encode.c platform.c \
+                 oggenc.c audio.c encode.c platform.c lyrics.c \
                  audio.h encode.h platform.h resample.c resample.h skeleton.c skeleton.h
 
 
diff -ru ../../../svn/xiph/vorbis-tools/oggenc/man/oggenc.1 oggenc/man/oggenc.1
--- ../../../svn/xiph/vorbis-tools/oggenc/man/oggenc.1	2008-04-15 13:57:29.000000000 +0100
+++ oggenc/man/oggenc.1	2008-07-14 20:54:40.000000000 +0100
@@ -78,6 +78,10 @@
 .B -G
 .I genre
 ]
+[
+.B -L
+.I lyrics file
+]
 .I input_files \fR...
 
 .SH DESCRIPTION
@@ -102,6 +106,9 @@
 are available, the output filename will be the input filename with the
 extension (that part after the final dot) replaced with ogg, so file.wav
 will become file.ogg
+.br
+Optionally, lyrics may be embedded in the Ogg file, if Kate support was compiled in. Note, however, that multiplexing a Kate
+stream with Vorbis may cause some players to fail to play the stream.
 
 .SH OPTIONS
 .IP "-h, --help"
@@ -191,6 +198,11 @@
 .IP "-l album, --album album"
 Set the album comment field to
 .I album.
+
+.IP "-L filename, --lyrics filename"
+Loads lyrics from
+.I filename
+, and encodes them in a Kate stream multiplexed with the Vorbis stream.
 .PP
 
 Note that the \fB-a\fR, \fB-t\fR, and \fB-l\fR options can be given
@@ -323,6 +335,12 @@
 .RE
 .PP
 
+Adding embedded lyrics.
+.RS
+oggenc somefile.wav --lyrics lyrics.lrc -o out.ogg
+.RE
+.PP
+
 This encodes the three files, each with the
 same artist/album tag, but with different title tags on each one. The
 string given as an argument to -n is used to generate filenames, as shown
@@ -355,6 +373,8 @@
 
 .SH BUGS
 Reading type 3 wav files (floating point samples) probably doesn't work other than on intel (or other 32 bit, little endian machines). 
+.br
+Enhanced LRC files are not yet supported.
 
 .SH "SEE ALSO"
 
diff -ru ../../../svn/xiph/vorbis-tools/oggenc/oggenc.c oggenc/oggenc.c
--- ../../../svn/xiph/vorbis-tools/oggenc/oggenc.c	2008-04-15 13:57:29.000000000 +0100
+++ oggenc/oggenc.c	2008-07-14 20:42:43.000000000 +0100
@@ -66,6 +66,7 @@
     {"scale", 1, 0, 0}, 
     {"advanced-encode-option", 1, 0, 0},
     {"discard-comments", 0, 0, 0},
+    {"lyrics",1,0,'L'},
     {NULL,0,0,0}
 };
 
@@ -81,10 +82,10 @@
 int main(int argc, char **argv)
 {
     /* Default values */
-    oe_options opt = {NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL,
+    oe_options opt = {NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL,
               0, NULL, 0, NULL, 0, NULL, 0, 1, 0, 0, 0,16,44100,2, 0, NULL,
               DEFAULT_NAMEFMT_REMOVE, DEFAULT_NAMEFMT_REPLACE,
-              NULL, 0, -1,-1,-1,.3,-1,0, 0,0.f, 0, 0};
+              NULL, 0, -1,-1,-1,.3,-1,0, 0,0.f, 0, 0, 0};
 
     int i;
 
@@ -132,6 +133,7 @@
         srand(time(NULL));
         opt.serial = rand();
         opt.skeleton_serial = opt.serial + numfiles;
+        opt.kate_serial = opt.skeleton_serial + numfiles;
     }
 
     for(i = 0; i < numfiles; i++)
@@ -146,6 +148,7 @@
         int closeout = 0, closein = 0;
         char *artist=NULL, *album=NULL, *title=NULL, *track=NULL;
         char *date=NULL, *genre=NULL;
+        char *lyrics=NULL;
         input_format *format;
         int resampled = 0;
 
@@ -153,6 +156,7 @@
 
         enc_opts.serialno = opt.serial++;
         enc_opts.skeleton_serialno = opt.skeleton_serial++;
+        enc_opts.kate_serialno = opt.kate_serial++;
         enc_opts.progress_update = update_statistics_full;
         enc_opts.start_encode = start_encode_full;
         enc_opts.end_encode = final_statistics;
@@ -165,6 +169,19 @@
         build_comments(&vc, &opt, i, &artist, &album, &title, &track,
                 &date, &genre);
 
+        if(opt.lyrics_count)
+        {
+            if(i >= opt.lyrics_count)
+            {
+                /* TODO: I think it'd be better to default to *none*, but it would be inconsistent with the rest */
+                if(!opt.quiet)
+                    fprintf(stderr, _("WARNING: Insufficient lyrics specified, defaulting to final lyrics.\n"));
+                lyrics = opt.lyrics[opt.lyrics_count-1];
+            }
+            else
+                lyrics = opt.lyrics[i];
+        }
+
         if(!strcmp(infiles[i], "-"))
         {
             setbinmode(stdin);
@@ -269,15 +286,20 @@
                 end = strrchr(infiles[i], '.');
                 end = end?end:(start + strlen(infiles[i])+1);
 
-                extension = (opt.with_skeleton) ? ".oga" : ".ogg";
+                /* if adding skeleton or kate, we're not Vorbis I anymore */
+                extension = (opt.with_skeleton || opt.lyrics_count>0) ? ".oga" : ".ogg";
                 out_fn = malloc(end - start + 5);
                 strncpy(out_fn, start, end-start);
                 out_fn[end-start] = 0;
                 strcat(out_fn, extension);
             }
             else {
-                fprintf(stderr, _("WARNING: No filename, defaulting to \"default.ogg\"\n"));
-                out_fn = strdup("default.ogg");
+                /* if adding skeleton or kate, we're not Vorbis I anymore */
+                if (opt.with_skeleton || opt.lyrics_count>0)
+                    out_fn = strdup("default.oga");
+                else
+                    out_fn = strdup("default.ogg");
+                fprintf(stderr, _("WARNING: No filename, defaulting to \"%s\"\n"), out_fn);
             }
 
             /* Create any missing subdirectories, if possible */
@@ -323,6 +345,7 @@
         enc_opts.quality_set = opt.quality_set;
         enc_opts.advopt = opt.advopt;
         enc_opts.advopt_count = opt.advopt_count;
+        enc_opts.lyrics = lyrics;
 
         if(opt.resamplefreq && opt.resamplefreq != enc_opts.rate) {
             int fromrate = enc_opts.rate;
@@ -470,6 +493,7 @@
         " -l, --album          Name of album\n"
         " -a, --artist         Name of artist\n"
         " -G, --genre          Genre of track\n"
+        " -L, --lyrics         Include lyrics from given file (.srt or .lrc format)\n"
         "                      If multiple input files are given, then multiple\n"
         "                      instances of the previous five arguments will be used,\n"
         "                      in the order they are given. If fewer titles are\n"
@@ -601,14 +625,14 @@
     int ret;
     int option_index = 1;
 
-    while((ret = getopt_long(argc, argv, "A:a:b:B:c:C:d:G:hkl:m:M:n:N:o:P:q:QrR:s:t:vX:",
+    while((ret = getopt_long(argc, argv, "A:a:b:B:c:C:d:G:hkL:l:m:M:n:N:o:P:q:QrR:s:t:vX:",
                     long_options, &option_index)) != -1)
     {
         switch(ret)
         {
             case 0:
                 if(!strcmp(long_options[option_index].name, "skeleton")) {
                 if(!strcmp(long_options[option_index].name, "skeleton")) {
                     opt->with_skeleton = 1;
                 }
                 else if(!strcmp(long_options[option_index].name, "managed")) {
@@ -857,6 +881,14 @@
             case 'k':
                 opt->with_skeleton = 1;
                 break;
+            case 'L':
+#ifdef HAVE_KATE
+                opt->lyrics = realloc(opt->lyrics, (++opt->lyrics_count)*sizeof(char *));
+                opt->lyrics[opt->lyrics_count - 1] = strdup(optarg);
+#else
+                fprintf(stderr, _("WARNING: Kate support not compiled in, lyrics will not be included.\n"));
+#endif
+                break;
             case '?':
                 fprintf(stderr, _("WARNING: Unknown option specified, ignoring->\n"));
                 break;
--- /dev/null	2008-04-05 19:24:09.000000000 +0100
+++ oggenc/lyrics.h	2008-07-14 18:58:35.000000000 +0100
@@ -0,0 +1,31 @@
+#ifndef __LYRICS_H
+#define __LYRICS_H
+
+#include <stddef.h>
+
+#define SUPPORTED_ENCODINGS "utf-8, utf8, iso-8859-1, latin1"
+
+typedef enum {
+  oe_encoding_unset,
+  oe_encoding_UTF8,
+  oe_encoding_ISO_8859_1,
+} oe_encoding;
+
+typedef struct oe_lyrics_item {
+    char *text;
+    size_t len;
+    double t0;
+    double t1;
+} oe_lyrics_item;
+
+typedef struct oe_lyrics {
+    size_t count;
+    oe_lyrics_item *lyrics;
+} oe_lyrics;
+
+extern oe_lyrics *load_lyrics(const char *filename, oe_encoding encoding);
+extern void free_lyrics(oe_lyrics *lyrics);
+extern const oe_lyrics_item *get_lyrics(const oe_lyrics *lyrics, double t, size_t *idx);
+
+#endif
+
--- /dev/null	2008-04-05 19:24:09.000000000 +0100
+++ oggenc/lyrics.c	2008-07-14 21:27:38.000000000 +0100
@@ -0,0 +1,358 @@
+/* OggEnc
+ **
+ ** This program is distributed under the GNU General Public License, version 2.
+ ** A copy of this license is included with this source.
+ **
+ ** Copyright 2000-2002, Michael Smith <msmith@xiph.org>
+ **
+ ** Portions from ffmpeg2theora, (c) j <j@v2v.cc>
+ **/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <malloc.h>
+#include <string.h>
+#include <errno.h>
+
+#ifdef HAVE_KATE
+#include <kate/oggkate.h>
+#endif
+
+#include "lyrics.h"
+#include "i18n.h"
+
+typedef enum {
+  lf_unknown,
+  lf_srt,
+  lf_lrc,
+} lyrics_format;
+
+/*
+static void report_unknown_subtitle_encoding(const char *name)
+{
+  fprintf(stderr, _("Unknown character encoding: %s\n"),name);
+  fprintf(stderr, _("Valid character encodings are:\n"));
+  fprintf(stderr, "  " _(SUPPORTED_ENCODINGS) "\n");
+}
+*/
+
+#ifdef HAVE_KATE
+static char *fgets2(char *s,size_t sz,FILE *f)
+{
+    char *ret = fgets(s, sz, f);
+    /* fixup DOS newline character */
+    char *ptr=strchr(s, '\r');
+    if (ptr) *ptr='\n';
+    return ret;
+}
+#endif
+
+#ifdef HAVE_KATE
+static double hmsms2s(int h,int m,int s,int ms)
+{
+    return h*3600+m*60+s+ms/1000.0;
+}
+#endif
+
+#ifdef HAVE_KATE
+/* very simple implementation when no iconv */
+static void convert_subtitle_to_utf8(oe_encoding encoding,unsigned char *text)
+{
+  size_t nbytes;
+  unsigned char *ptr,*newtext;
+
+  if (!text || !*text) return;
+
+  switch (encoding) {
+    case oe_encoding_unset:
+      /* we don't know what encoding this is, assume utf-8 and we'll yell if it ain't */
+      break;
+    case oe_encoding_UTF8:
+      /* nothing to do, already in utf-8 */
+      break;
+    case oe_encoding_ISO_8859_1:
+      /* simple, characters above 0x7f are broken in two,
+         and code points map to the iso-8859-1 8 bit codes */
+      nbytes=0;
+      for (ptr=text;*ptr;++ptr) {
+        nbytes++;
+        if (0x80&*ptr) nbytes++;
+      }
+      newtext=(unsigned char*)malloc(1+nbytes);
+      if (!newtext) {
+        fprintf(stderr, _("Memory allocation failed - cannot convert text\n"));
+        return;
+      }
+      nbytes=0;
+      for (ptr=text;*ptr;++ptr) {
+        if (0x80&*ptr) {
+          newtext[nbytes++]=0xc0|((*ptr)>>6);
+          newtext[nbytes++]=0x80|((*ptr)&0x3f);
+        }
+        else {
+          newtext[nbytes++]=*ptr;
+        }
+      }
+      newtext[nbytes++]=0;
+      memcpy(text,newtext,nbytes);
+      free(newtext);
+      break;
+    default:
+      fprintf(stderr, _("ERROR: encoding %d not handled in conversion!\n"), encoding);
+      break;
+  }
+}
+#endif
+
+#ifdef HAVE_KATE
+static int add_lyrics(oe_lyrics *lyrics, char *text, oe_encoding encoding,double t0,double t1)
+{
+  size_t len;
+  int ret;
+
+  convert_subtitle_to_utf8(encoding,(unsigned char*)text);
+  len = strlen(text);
+  lyrics->lyrics = (oe_lyrics_item*)realloc(lyrics->lyrics, (lyrics->count+1)*sizeof(oe_lyrics_item));
+  if (!lyrics->lyrics) {
+    fprintf(stderr, _("Out of memory\n"));
+    return -1;
+  }
+  ret=kate_text_validate(kate_utf8,text,len+1);
+  if (ret<0) {
+    fprintf(stderr,_("WARNING: subtitle %s is not valid utf-8\n"),text);
+  }
+  else {
+    /* kill off trailing \n characters */
+    while (len>0) {
+      if (text[len-1]=='\n') text[--len]=0; else break;
+    }
+    lyrics->lyrics[lyrics->count].text = (char*)malloc(len+1);
+    memcpy(lyrics->lyrics[lyrics->count].text, text, len+1);
+    lyrics->lyrics[lyrics->count].len = len;
+    lyrics->lyrics[lyrics->count].t0 = t0;
+    lyrics->lyrics[lyrics->count].t1 = t1;
+    lyrics->count++;
+  }
+  return 0;
+}
+#endif
+
+#ifdef HAVE_KATE
+static oe_lyrics *load_srt_lyrics(FILE *f, oe_encoding encoding)
+{
+    enum { need_id, need_timing, need_text };
+    int need = need_id;
+    int last_seen_id=0;
+    int ret;
+    int id;
+    static char text[4096];
+    static char str[4096];
+    int h0,m0,s0,ms0,h1,m1,s1,ms1;
+    double t0=0.0;
+    double t1=0.0;
+    oe_lyrics *lyrics;
+
+    lyrics=(oe_lyrics*)malloc(sizeof(oe_lyrics));
+    if (!lyrics) return NULL;
+    lyrics->count = 0;
+    lyrics->lyrics = NULL;
+
+    fgets2(str,sizeof(str),f);
+    while (!feof(f)) {
+      switch (need) {
+        case need_id:
+          ret=sscanf(str,"%d\n",&id);
+          if (ret!=1) {
+            fprintf(stderr,_("WARNING - Syntax error: %s\n"),str);
+            free_lyrics(lyrics);
+            return NULL;
+          }
+          if (id!=last_seen_id+1) {
+            fprintf(stderr,_("WARNING - non consecutive ids: %s - pretending not to have noticed\n"),str);
+          }
+          last_seen_id=id;
+          need=need_timing;
+          strcpy(text,"");
+          break;
+        case need_timing:
+          ret=sscanf(str,"%d:%d:%d%*[.,]%d --> %d:%d:%d%*[.,]%d\n",&h0,&m0,&s0,&ms0,&h1,&m1,&s1,&ms1);
+          if (ret!=8) {
+            fprintf(stderr,_("WARNING - Syntax error: %s\n"),str);
+            free_lyrics(lyrics);
+            return NULL;
+          }
+          else {
+            t0=hmsms2s(h0,m0,s0,ms0);
+            t1=hmsms2s(h1,m1,s1,ms1);
+          }
+          need=need_text;
+          break;
+        case need_text:
+          if (*str=='\n') {
+            if (add_lyrics(lyrics,str,encoding,t0,t1) < 0) {
+              free_lyrics(lyrics);
+              return NULL;
+            }
+            need=need_id;
+          }
+          else {
+            strcat(text,str);
+          }
+          break;
+      }
+      fgets2(str,sizeof(str),f);
+    }
+
+    return lyrics;
+}
+#endif
+
+#ifdef HAVE_KATE
+static int is_line_empty(const char *s)
+{
+  /* will work fine with UTF-8 despite the appearance s*/
+  while (*s) {
+    if (!strchr(" \t\r\n",*s)) return 0;
+    ++s;
+  }
+  return 1;
+}
+#endif
+
+#ifdef HAVE_KATE
+static oe_lyrics *load_lrc_lyrics(FILE *f, oe_encoding encoding)
+{
+  oe_lyrics *lyrics;
+  static char str[4096];
+  static char line[4096];
+  int m,s,ms;
+  double t,start_time = -1.0;
+  int offset;
+
+  /* skip headers */
+  fgets2(str,sizeof(str),f);
+  while (!feof(f)) {
+    if (sscanf(str, "[%u:%u.%u]%n\n",&m,&s,&ms,&offset) == 3)
+      break;
+    fgets2(str,sizeof(str),f);
+  }
+  if (feof(f)) {
+    fprintf(stderr,_("WARNING - Syntax error: %s\n"),str);
+    return NULL;
+  }
+
+  lyrics=(oe_lyrics*)malloc(sizeof(oe_lyrics));
+  if (!lyrics) return NULL;
+  lyrics->count = 0;
+  lyrics->lyrics = NULL;
+
+  while (!feof(f)) {
+    if (sscanf(str, "[%u:%u.%u]%n\n",&m,&s,&ms,&offset) != 3) {
+      fprintf(stderr,_("WARNING - Syntax error: %s\n"),str);
+      free_lyrics(lyrics);
+      return NULL;
+    }
+    t=hmsms2s(0,m,s,ms);
+
+    if (start_time>=0.0 && !is_line_empty(line)) {
+      if (add_lyrics(lyrics,line,encoding,start_time,t) < 0) {
+        free_lyrics(lyrics);
+        return NULL;
+      }
+    }
+
+    start_time=t;
+    strcpy(line,str+offset);
+    fgets2(str,sizeof(str),f);
+  }
+
+  return lyrics;
+}
+#endif
+
+#ifdef HAVE_KATE
+/* very weak checks, but we only support two formats, so it's ok */
+lyrics_format probe_lyrics_format(FILE *f)
+{
+  unsigned int dummy_int;
+  static char str[4096];
+  lyrics_format format=lf_unknown;
+  long pos;
+
+  if (!f) return lf_unknown;
+
+  pos=ftell(f);
+  fgets2(str,sizeof(str),f);
+
+  /* srt */
+  if (sscanf(str, "%u\n", &dummy_int) == 1)
+    format=lf_srt;
+
+  /* lrc */
+  if (str[0] == '[')
+    format=lf_lrc;
+
+  fseek(f,pos,SEEK_SET);
+
+  return format;
+}
+#endif
+
+oe_lyrics *load_lyrics(const char *filename, oe_encoding encoding)
+{
+#ifdef HAVE_KATE
+  static char str[4096];
+  int ret;
+  oe_lyrics *lyrics=NULL;
+
+  FILE *f = fopen(filename, "r");
+  if (!f) {
+      fprintf(stderr,_("WARNING - Failed to open lyrics file %s (%s)\n"), filename, strerror(errno));
+      return NULL;
+  }
+
+  /* first, check for a BOM */
+  ret=fread(str,1,3,f);
+  if (ret<3 || memcmp(str,"\xef\xbb\xbf",3)) {
+    /* No BOM, rewind */
+    fseek(f,0,SEEK_SET);
+  }
+
+  switch (probe_lyrics_format(f)) {
+    case lf_srt:
+      lyrics = load_srt_lyrics(f, encoding);
+      break;
+    case lf_lrc:
+      lyrics = load_lrc_lyrics(f, encoding);
+      break;
+    default:
+      fprintf(stderr, _("Failed to load %s - can't determine format\n"), filename);
+      break;
+  }
+
+  fclose(f);
+
+  return lyrics;
+#else
+  return NULL;
+#endif
+}
+
+void free_lyrics(oe_lyrics *lyrics)
+{
+    size_t n;
+    for (n=0; n<lyrics->count; ++n) free(lyrics->lyrics[n].text);
+    free(lyrics->lyrics);
+    free(lyrics);
+}
+
+const oe_lyrics_item *get_lyrics(const oe_lyrics *lyrics, double t, size_t *idx)
+{
+    if (!lyrics || *idx>=lyrics->count) return NULL;
+    if (lyrics->lyrics[*idx].t0 > t) return NULL;
+    return &lyrics->lyrics[(*idx)++];
+}
+
