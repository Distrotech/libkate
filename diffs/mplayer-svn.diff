diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/cs/mplayer.1 mplayer-svn-with-kate/DOCS/man/cs/mplayer.1
--- mplayer-svn/DOCS/man/cs/mplayer.1	2008-03-14 13:26:39.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/cs/mplayer.1	2008-03-15 21:25:45.000000000 +0000
@@ -171,7 +171,7 @@
 MPlayer mÃ¡ displej na obrazovce (OSD) pro stavovÃ© informace, krÃ¡snÃ© velkÃ©
 vyhlazenÃ© a stÃ­novanÃ© titulky a vizuÃ¡lnÃ­ odezvu na povely z\ klÃ¡vesnice.
 PodporovÃ¡ny jsou EvropskÃ©/\:ISO8859\-1,2 (BulharskÃ©, AnglickÃ©, ÄŒeskÃ©, atd),
-CyrilickÃ© a KorejskÃ© fonty spolu s 12 formÃ¡ty titulkÅ¯ (MicroDVD, SubRip, OGM,
+CyrilickÃ© a KorejskÃ© fonty spolu s 13 formÃ¡ty titulkÅ¯ (MicroDVD, SubRip, Kate, OGM,
 SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS a nÃ¡Å¡ vlastnÃ­: MPsub) a
 takÃ© DVD titulky (SPU proudy, VOBsub a Closed Captions).
 .PP
@@ -2068,6 +2068,12 @@
 VytvoÅ™Ã­ soubor dumpsub.smi v aktuÃ¡lnÃ­m adresÃ¡Å™i.
 .
 .TP
+.B \-dumpoggkatesub (pouze MPlayer)
+PÅ™evede zvolenÃ© titulky (urÄenÃ© volbou \-sub) do ÄasovÄ› orientovanÃ©ho
+Kate formÃ¡tu.
+VytvoÅ™Ã­ soubor dumpsub.ogg v aktuÃ¡lnÃ­m adresÃ¡Å™i.
+.
+.TP
 .B \-dumpsrtsub (pouze MPlayer)
 PÅ™evede zvolenÃ© titulky (urÄenÃ© volbou \-sub) do ÄasovÄ› orientovanÃ©ho
 SubViewer (SRT) formÃ¡tu.
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/de/mplayer.1 mplayer-svn-with-kate/DOCS/man/de/mplayer.1
--- mplayer-svn/DOCS/man/de/mplayer.1	2008-03-14 13:26:39.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/de/mplayer.1	2008-03-15 21:25:46.000000000 +0000
@@ -2173,6 +2173,12 @@
 Erstellt eine Datei dumpsub.smi im aktuellen Verzeichnis.
 .
 .TP
+.B \-dumpoggkatesub (MPlayer only)
+Konvertiert den (mit der \-sub-Option angegebenen) Untertitel in das
+zeitbasierende Kate-Untertitelformat.
+Erstellt eine Datei dumpsub.ogg im aktuellen Verzeichnis.
+.
+.TP
 .B \-dumpsrtsub (nur bei MPlayer)
 Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
 zeitbasierende SubViewer-Untertitelformat (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/en/mplayer.1 mplayer-svn-with-kate/DOCS/man/en/mplayer.1
--- mplayer-svn/DOCS/man/en/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/en/mplayer.1	2008-03-15 21:25:47.000000000 +0000
@@ -166,9 +166,9 @@
 MPlayer has an onscreen display (OSD) for status information, nice big
 antialiased shaded subtitles and visual feedback for keyboard controls.
 European/\:ISO8859-1,2 (Hungarian, English, Czech, etc), Cyrillic and Korean
-fonts are supported along with 12 subtitle formats (MicroDVD, SubRip, OGM,
-SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS and our own: MPsub) and
-DVD subtitles (SPU streams, VOBsub and Closed Captions).
+fonts are supported along with 13 subtitle formats (MicroDVD, SubRip, Kate,
+OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS and our own: MPsub)
+and DVD subtitles (SPU streams, VOBsub and Closed Captions).
 .PP
 .B mencoder
 (MPlayer's Movie Encoder) is a simple movie encoder, designed to encode
@@ -2140,6 +2140,12 @@
 Creates a dumpsub.smi file in the current directory.
 .
 .TP
+.B \-dumpoggkatesub (MPlayer only)
+Convert the given subtitle (specified with the \-sub option) to the time-based
+Kate subtitle format.
+Creates a dumpsub.ogg file in the current directory.
+.
+.TP
 .B \-dumpsrtsub (MPlayer only)
 Convert the given subtitle (specified with the \-sub option) to the time-based
 SubViewer (SRT) subtitle format.
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/es/mplayer.1 mplayer-svn-with-kate/DOCS/man/es/mplayer.1
--- mplayer-svn/DOCS/man/es/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/es/mplayer.1	2008-03-15 21:25:48.000000000 +0000
@@ -183,8 +183,8 @@
 subtítulos grandes y bonitos con suavizado de bordes y realimentación visual de
 los controles con teclado.
 Tipos de letra Europeo/\:ISO8859\-1,2 (Húngaro, Inglés, Checoslovaco, etc),
-Cirílico y Koreano se soportan en 12 formatos de subtítulos (MicroDVD, SubRip,
-OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS y el nuestro:
+Cirílico y Koreano se soportan en 13 formatos de subtítulos (MicroDVD, SubRip,
+Kate, OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS y el nuestro:
 MPsub) así como subtítulos DVD (cadenas SPU, VOBsub y Closed Captions).
 .PP
 .B mencoder
@@ -1901,6 +1901,12 @@
 Crea un archivo dumpsub.smi en el directorio actual.
 .
 .TP
+.B \-dumpoggkatesub (MPlayer solamente)
+Convierte el subtítulo dado (especificado con la opción \-sub) al formato
+de subtítulo basado en tiempo Kate.
+Crea un archivo dumpsub.ogg en el directorio actual.
+.
+.TP
 .B \-dumpsrtsub (MPlayer solamente)
 Convierte el subtítulo dado (especificado con la opción \-sub) al formato
 de subtítulo basado en tiempo SubViewer (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/fr/mplayer.1 mplayer-svn-with-kate/DOCS/man/fr/mplayer.1
--- mplayer-svn/DOCS/man/fr/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/fr/mplayer.1	2008-03-15 21:25:50.000000000 +0000
@@ -171,9 +171,9 @@
 informations, de belles et grandes polices lissées et des effets
 visuels pour confirmer les contrôles au clavier. Les polices
 européennes/\:ISO8859\-1,2 (Hongroise, Anglaise, Tchèque, etc),
-Cyrillique et Coréenne sont gérés ainsi que 11 formats de
-sous-titres (MicroDVD, SubRip, OGM, SubViewer, Sami, VPlayer, RT,
-SSA, AQTitle, JACOsub, PJS et le nôtre: MPsub) et les sous-titres
+Cyrillique et Coréenne sont gérés ainsi que 13 formats de
+sous-titres (MicroDVD, SubRip, Kate, OGM, SubViewer, Sami, VPlayer,
+RT, SSA, AQTitle, JACOsub, PJS et le nôtre: MPsub) et les sous-titres
 DVD (SPU streams, VobSub et Closed Captions).
 .PP
 .B mencoder
@@ -2246,6 +2246,12 @@
 Crée un fichier dumpsub.smi dans le répertoire courant.
 .
 .TP
+.B \-dumpoggkatesub (MPlayer uniquement)
+Convertit les sous-titres donnés (via l'option \-sub) au format basé sur le
+temps Kate.
+Crée un fichier dumpsub.ogg dans le répertoire courant.
+.
+.TP
 .B \-dumpsrtsub (MPlayer uniquement)
 Convertit les sous-titres donnés (via l'option \-sub) au format basé sur le
 temps SubViewer (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/hu/mplayer.1 mplayer-svn-with-kate/DOCS/man/hu/mplayer.1
--- mplayer-svn/DOCS/man/hu/mplayer.1	2008-03-17 21:23:26.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/hu/mplayer.1	2008-03-17 21:24:02.000000000 +0000
@@ -168,8 +168,8 @@
 Az MPlayernek van onscreen display (OSD) funkciója is a státuszinformációk
 és a szép, élsímított, árnyékolt feliratok megjelenítéséhez és a billentyûzetrõl
 érkezõ jelek visszajelzéséhez. Európai/\:ISO8859\-1,2 (magyar, angol, cseh, stb.),
-cirill és koreai betûtípusok mind támogatottak 12 felirat formátummal (MicroDVD,
-SubRip, OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS és a mi
+cirill és koreai betûtípusok mind támogatottak 13 felirat formátummal (MicroDVD,
+SubRip, Kate, OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS és a mi
 sajátunk: MPsub) és DVD felirattal (SPU streams, VOBsub és Closed Captions)
 egyetemben.
 .PP
@@ -2150,6 +2150,12 @@
 Az aktuális könyvtárban hoz létre egy dumpsub.smi fájlt.
 .
 .TP
+.B \-dumpoggkatesub (csak MPlayer)
+A használt felirat (amit a \-sub opció ad meg) idõ alapú Kate formátumba
+konvertálása.
+Az aktuális könyvtárban hoz létre egy dumpsub.ogg fájlt.
+.
+.TP
 .B \-dumpsrtsub (csak MPlayer)
 A használt felirat (amit a \-sub opció ad meg) idõ alapú SubViewer formátumba
 konvertálása.
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/it/mplayer.1 mplayer-svn-with-kate/DOCS/man/it/mplayer.1
--- mplayer-svn/DOCS/man/it/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/it/mplayer.1	2008-03-15 21:25:52.000000000 +0000
@@ -173,7 +173,7 @@
 informazioni sullo stato, grandi e bei sottotitoli sfumati con antialias ed un
 riscontro visuale dei comandi da tastiera.
 Sono supportati font europei/\:ISO8859\-1,2 (Ungherese, Inglese, Ceco, etc),
-Cirillici e Coreani insieme a 12 formati di sottotitoli (MicroDVD, SubRip,
+Cirillici e Coreani insieme a 13 formati di sottotitoli (MicroDVD, SubRip, Kate,
 OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS ed il nostro:
 MPsub) oltre ai sottotitoli dei DVD (flussi SPU, VOBsub e Closed Captions).
 .PP
@@ -2228,6 +2228,12 @@
 Crea un file dumpsub.smi nella directory corrente.
 .
 .TP
+.B \-dumpoggkatesub (solo MPlayer)
+Converti i sottotitoli (specificati con l'opzione \-sub) nel formato
+dei sottotitoli basato sul tempo Kate.
+Crea un file dumpsub.ogg nella directory corrente.
+.
+.TP
 .B \-dumpsrtsub (solo MPlayer)
 Converti i sottotitoli (specificati con l'opzione \-sub) nel formato
 dei sottotitoli basato sul tempo SubViever (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/pl/mplayer.1 mplayer-svn-with-kate/DOCS/man/pl/mplayer.1
--- mplayer-svn/DOCS/man/pl/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/pl/mplayer.1	2008-03-15 21:25:53.000000000 +0000
@@ -211,7 +211,7 @@
 przy pomocy klawiatury i wy¶wietla ³adne, du¿e, antyaliasowane i cieniowane
 napisy.
 Obs³ugiwane s± czcionki europejskie/\:ISO 8859\-1,2 (polskie, czeskie, angielskie
-itp.), koreañskie i cyrylica oraz 12 formatów napisów (MicroDVD, SubRip, OGM,
+itp.), koreañskie i cyrylica oraz 13 formatów napisów (MicroDVD, SubRip, Kate, OGM,
 SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS i nasz w³asny: MPsub)
 i napisów DVD (strumienie SPU, VOBSub i Closed Captions).
 .PP
@@ -1424,6 +1424,12 @@
 Tworzy w bie¿±cym katalogu zbiór dumpsub.smi
 .
 .TP
+.B \-dumpoggkatesub (tylko MPlayer)
+Konwertuje podane (przy pomocy opcji \-sub) napisy na oparty na czasie format
+Kate.
+Tworzy w bie¿±cym katalogu zbiór dumpsub.ogg
+.
+.TP
 .B \-dumpsrtsub (tylko MPlayer)
 Konwertuje podane (przy pomocy opcji \-sub) napisy na oparty na czasie format
 SubViewer (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/ru/mplayer.1 mplayer-svn-with-kate/DOCS/man/ru/mplayer.1
--- mplayer-svn/DOCS/man/ru/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/ru/mplayer.1	2008-03-15 21:25:57.000000000 +0000
@@ -168,7 +168,7 @@
 MPlayer ÉÍÅÅÔ onscreen display (OSD) ÄÌÑ ÏÔÏÂÒÁÖÅÎÉÑ ÉÎÆÏÒÍÁÃÉÉ Ï ÓÏÓÔÏÑÎÉÉ ,
 ÂÏÌØÛÉÈ ÓÇÌÁÖÅÎÎÙÈ ÓÕÂÔÉÔÒÏ× Ó ÔÅÎØÀ É ×ÉÚÕÁÌØÎÏÇÏ ÏÔËÌÉËÁ ÎÁ ËÌÁ×ÉÁÔÕÒÎÙÅ ËÏÍÁÎÄÙ.
 å×ÒÏĞÅÊÓËÉÅ/\:ISO8859\-1,2 (÷ÅÎÇÅÒÓËÉÅ, áÎÇÌÉÊÓËÉÅ, şÅÛÓËÉÅ, É Ô.Ä.), ëÉÒÉÌÌÉŞÅÓËÉÅ É ëÏÒÅÊÓËÉÅ
-ÛÒÉÆÔÙ ×ËÕĞÅ Ó 12 ÆÏÒÍÁÔÁÍÉ ÓÕÂÔÉÔÒÏ× (MicroDVD, SubRip, OGM,
+ÛÒÉÆÔÙ ×ËÕĞÅ Ó 13 ÆÏÒÍÁÔÁÍÉ ÓÕÂÔÉÔÒÏ× (MicroDVD, SubRip, Kate, OGM,
 SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS É ÎÁÛ ÓÏÂÓÔ×ÅÎÎÙÊ: MPsub) É 
 DVD ÓÕÂÔÉÔÒÙ (SPU streams, VOBsub É Closed Captions).
 .PP
@@ -2034,6 +2034,11 @@
 óÏÚÄÁÅÔ ÆÁÊÌ dumpsub.sm × ÔÅËÕİÅÍ ËÁÔÁÌÏÇÅ.
 .
 .TP
+.B \-dumpoggkatesub (ÔÏÌØËÏ MPlayer)
+ğÒÅÏÂÒÁÚÕÅÔ ÓÕÂÔÉÔÒÙ (ÕËÁÚÁÎÎÙÅ ÏĞÃÉÅÊ \-sub) × ÏÓÎÏ×ÁÎÎÙÊ ÎÁ ×ÒÅÍÅÎÉ ÆÏÒÍÁÔ Kate.
+óÏÚÄÁÅÔ ÆÁÊÌ dumpsub.ogg × ÔÅËÕİÅÍ ËÁÔÁÌÏÇÅ.
+.
+.TP
 .B \-dumpsrtsub (ÔÏÌØËÏ MPlayer)
 ğÒÅÏÂÒÁÚÕÅÔ ÓÕÂÔÉÔÒÙ (ÕËÁÚÁÎÎÙÅ ÏĞÃÉÅÊ \-sub) × ÏÓÎÏ×ÁÎÎÙÊ ÎÁ ×ÒÅÍÅÎÉ ÆÏÒÍÁÔ
 SubViewer (SRT).
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/man/zh/mplayer.1 mplayer-svn-with-kate/DOCS/man/zh/mplayer.1
--- mplayer-svn/DOCS/man/zh/mplayer.1	2008-03-14 13:26:40.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/man/zh/mplayer.1	2008-03-15 21:26:03.000000000 +0000
@@ -175,7 +175,7 @@
 MPlayer å…·æœ‰ OSD(å±ä¸Šæ˜¾ç¤º) åŠŸèƒ½æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯, æœ‰
 æŠ—é”¯é½¿å¸¦é˜´å½±çš„æ¼‚äº®å¤§å­—å¹•å’Œé”®ç›˜æ§åˆ¶çš„å¯è§†åé¦ˆã€‚
 æ”¯æŒçš„å­—ä½“åŒ…æ‹¬æ¬§æ´²è¯­ç§/\:ISO8859\-1,2 (åŒˆç‰™åˆ©è¯­, è‹±è¯­, æ·å…‹è¯­ç­‰ç­‰), 
-è¥¿é‡Œå°”è¯­å’ŒéŸ©è¯­, å¯ä»¥æ’­æ”¾ 12 ç§æ ¼å¼çš„å­—å¹•æ–‡ä»¶ (MicroDVD, SubRip, OGM,
+è¥¿é‡Œå°”è¯­å’ŒéŸ©è¯­, å¯ä»¥æ’­æ”¾ 13 ç§æ ¼å¼çš„å­—å¹•æ–‡ä»¶ (MicroDVD, SubRip, Kate OGM,
 SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub, PJS 
 åŠæˆ‘ä»¬è‡ªå·±çš„: MPsub) å’Œ DVD å­—å¹• (SPU æµ, VOBsub åŠéšè—å¼ CC å­—å¹•)ã€‚
 .PP
@@ -1993,6 +1993,11 @@
 åœ¨å½“å‰çš„ç›®å½•ä¸­åˆ›å»º dumpsub.smi æ–‡ä»¶ã€‚
 .
 .TP
+.B \-dumpoggkatesub (ä»…ç”¨äº MPlayer)
+è½¬æ¢ç»™å®šçš„(ç”± \-sub é€‰é¡¹æŒ‡å®šçš„)å­—å¹•æˆä¸ºåŸºäºæ—¶é—´çš„ Kate å­—å¹•æ ¼å¼ã€‚
+åœ¨å½“å‰çš„ç›®å½•ä¸­åˆ›å»º dumpsub.ogg æ–‡ä»¶ã€‚
+.
+.TP
 .B \-dumpsrtsub (ä»…ç”¨äº MPlayer)
 è½¬æ¢ç»™å®šçš„(ç”± \-sub é€‰é¡¹æŒ‡å®šçš„)å­—å¹•æˆä¸ºåŸºäºæ—¶é—´çš„ SubViewer (SRT) å­—å¹•æ ¼å¼ã€‚
 åœ¨å½“å‰çš„ç›®å½•ä¸­åˆ›å»º dumpsub.srt æ–‡ä»¶ã€‚
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/cs/usage.xml mplayer-svn-with-kate/DOCS/xml/cs/usage.xml
--- mplayer-svn/DOCS/xml/cs/usage.xml	2008-03-14 13:26:41.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/cs/usage.xml	2008-03-15 21:32:50.000000000 +0000
@@ -117,6 +117,7 @@
   <listitem><para>CC (closed caption)</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -141,6 +142,7 @@
   <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
   <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
   <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+  <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/de/usage.xml mplayer-svn-with-kate/DOCS/xml/de/usage.xml
--- mplayer-svn/DOCS/xml/de/usage.xml	2008-03-14 13:26:41.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/de/usage.xml	2008-03-15 21:32:59.000000000 +0000
@@ -117,6 +117,7 @@
       <listitem><para>CC (closed caption)</para></listitem>
       <listitem><para>MicroDVD</para></listitem>
       <listitem><para>SubRip</para></listitem>
+      <listitem><para>Kate</para></listitem>
       <listitem><para>SubViewer</para></listitem>
       <listitem><para>Sami</para></listitem>
       <listitem><para>VPlayer</para></listitem>
@@ -138,6 +139,7 @@
       <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
       <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
       <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+      <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
     </itemizedlist>
   </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/en/usage.xml mplayer-svn-with-kate/DOCS/xml/en/usage.xml
--- mplayer-svn/DOCS/xml/en/usage.xml	2008-03-14 13:26:42.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/en/usage.xml	2008-03-15 21:33:02.000000000 +0000
@@ -118,6 +118,7 @@
   <listitem><para>CC (closed caption)</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -142,6 +143,7 @@
   <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
   <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
   <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+  <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/fr/usage.xml mplayer-svn-with-kate/DOCS/xml/fr/usage.xml
--- mplayer-svn/DOCS/xml/fr/usage.xml	2008-03-14 13:26:42.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/fr/usage.xml	2008-03-15 21:33:22.000000000 +0000
@@ -117,6 +117,7 @@
 <listitem><para>CC (closed caption)</para></listitem>
 <listitem><para>MicroDVD</para></listitem>
 <listitem><para>SubRip</para></listitem>
+<listitem><para>Kate</para></listitem>
 <listitem><para>SubViewer</para></listitem>
 <listitem><para>Sami</para></listitem>
 <listitem><para>VPlayer</para></listitem>
@@ -139,6 +140,7 @@
 <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
 <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
 <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+<listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/hu/usage.xml mplayer-svn-with-kate/DOCS/xml/hu/usage.xml
--- mplayer-svn/DOCS/xml/hu/usage.xml	2008-03-14 13:26:42.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/hu/usage.xml	2008-03-15 21:33:24.000000000 +0000
@@ -119,6 +119,7 @@
   <listitem><para>CC (closed caption)</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -143,6 +144,7 @@
   <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
   <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
   <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+  <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/it/usage.xml mplayer-svn-with-kate/DOCS/xml/it/usage.xml
--- mplayer-svn/DOCS/xml/it/usage.xml	2008-03-14 13:26:43.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/it/usage.xml	2008-03-15 21:33:26.000000000 +0000
@@ -120,6 +120,7 @@
   <listitem><para>CC (closed caption)</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -144,6 +145,7 @@
   <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
   <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
   <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+  <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/pl/usage.xml mplayer-svn-with-kate/DOCS/xml/pl/usage.xml
--- mplayer-svn/DOCS/xml/pl/usage.xml	2008-03-14 13:26:43.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/pl/usage.xml	2008-03-15 21:33:28.000000000 +0000
@@ -118,6 +118,7 @@
   <listitem><para>CC (closed caption)</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -142,6 +143,7 @@
   <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
   <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
   <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+  <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
  
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/DOCS/xml/ru/usage.xml mplayer-svn-with-kate/DOCS/xml/ru/usage.xml
--- mplayer-svn/DOCS/xml/ru/usage.xml	2008-03-14 13:26:43.000000000 +0000
+++ mplayer-svn-with-kate/DOCS/xml/ru/usage.xml	2008-03-15 21:33:30.000000000 +0000
@@ -121,6 +121,7 @@
   <listitem><para>CC (closed caption[ÑĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ñ‚Ğ¸Ñ‚Ñ€Ñ‹])</para></listitem>
   <listitem><para>MicroDVD</para></listitem>
   <listitem><para>SubRip</para></listitem>
+  <listitem><para>Kate</para></listitem>
   <listitem><para>SubViewer</para></listitem>
   <listitem><para>Sami</para></listitem>
   <listitem><para>VPlayer</para></listitem>
@@ -143,6 +144,7 @@
  <listitem><para>MicroDVD: <option>-dumpmicrodvdsub</option></para></listitem>
  <listitem><para>JACOsub: <option>-dumpjacosub</option></para></listitem>
  <listitem><para>Sami: <option>-dumpsami</option></para></listitem>
+ <listitem><para>Kate: <option>-dumpoggkatesub</option></para></listitem>
 </itemizedlist>
 </para>
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/Makefile mplayer-svn-with-kate/Makefile
--- mplayer-svn/Makefile	2008-03-14 13:27:00.000000000 +0000
+++ mplayer-svn-with-kate/Makefile	2008-03-22 22:19:56.000000000 +0000
@@ -33,6 +33,7 @@
               subopt-helper.c \
               subreader.c \
               vobsub.c \
+              katedec.c \
 
 SRCS_COMMON-$(UNRAR_EXEC) += unrar_exec.c
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/cfg-mplayer.h mplayer-svn-with-kate/cfg-mplayer.h
--- mplayer-svn/cfg-mplayer.h	2008-03-14 13:26:39.000000000 +0000
+++ mplayer-svn-with-kate/cfg-mplayer.h	2008-03-15 20:49:21.000000000 +0000
@@ -299,6 +299,7 @@
 	{"dumpmicrodvdsub", &stream_dump_type, CONF_TYPE_FLAG, 0, 0, 7, NULL},
 	{"dumpjacosub", &stream_dump_type, CONF_TYPE_FLAG, 0, 0, 8, NULL},
 	{"dumpsami", &stream_dump_type, CONF_TYPE_FLAG, 0, 0, 9, NULL},
+	{"dumpoggkatesub", &stream_dump_type, CONF_TYPE_FLAG, 0, 0, 10, NULL},
 
 #ifdef HAVE_LIRC
 	{"lircconf", &lirc_configfile, CONF_TYPE_STRING, CONF_GLOBAL, 0, 0, NULL},
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/command.c mplayer-svn-with-kate/command.c
--- mplayer-svn/command.c	2008-03-14 13:26:39.000000000 +0000
+++ mplayer-svn-with-kate/command.c	2008-06-15 12:32:44.000000000 +0100
@@ -28,6 +28,7 @@
 #include "libmpcodecs/dec_video.h"
 #include "vobsub.h"
 #include "spudec.h"
+#include "katedec.h"
 #include "get_path.h"
 #ifdef USE_TV
 #include "stream/tv.h"
@@ -1470,6 +1471,8 @@
 		sh_sub_t *sh = d_sub->sh;
 		if (sh->type == 'v')
 		    init_vo_spudec();
+		if (sh->type == 'k')
+		    katedec_reset();
 #ifdef USE_ASS
 		else if (ass_enabled)
 		    ass_track = sh->ass_track;
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/configure mplayer-svn-with-kate/configure
--- mplayer-svn/configure	2008-03-17 21:23:27.000000000 +0000
+++ mplayer-svn-with-kate/configure	2008-06-15 13:36:08.000000000 +0100
@@ -304,6 +304,7 @@
   --disable-libvorbis       disable libvorbis support [autodetect]
   --disable-speex           disable Speex support [autodetect]
   --enable-theora           enable OggTheora libraries [autodetect]
+  --enable-kate             enable Kate libraries [autodetect]
   --enable-faad-external    enable external FAAD2 (AAC) [autodetect]
   --disable-faad-internal   disable internal FAAD2 (AAC) [autodetect]
   --enable-faad-fixed       enable fixed-point mode in internal FAAD2 [disabled]
@@ -565,6 +566,7 @@
 _libvorbis=auto
 _speex=auto
 _theora=auto
+_kate=auto
 _mp3lib=yes
 _liba52=yes
 _libdca=auto
@@ -913,6 +915,8 @@
   --disable-tremor-external)	_tremor_external=no	;;
   --enable-theora)	_theora=yes	;;
   --disable-theora)	_theora=no	;;
+  --enable-kate)	_kate=yes	;;
+  --disable-kate)	_kate=no	;;
   --enable-mp3lib)	_mp3lib=yes	;;
   --disable-mp3lib)	_mp3lib=no	;;
   --enable-liba52)	_liba52=yes	;;
@@ -5991,6 +5995,61 @@
 fi
 echores "$_theora"
 
+echocheck "Kate support"
+if test "$_kate" = auto ; then
+  _kate=no
+    cat > $TMPC << EOF
+#include <kate/kate.h>
+#include <kate/oggkate.h>
+#include <string.h>
+int main(void) 
+{ 
+  ogg_packet op;
+  kate_packet kp;
+  kate_comment kc;
+  kate_info ki;
+  kate_state k;
+  const kate_event *ev;
+  int r;
+  double t;
+
+  kate_info_init (&ki);
+  kate_comment_init (&kc);
+ 
+  return 0;
+
+  /* we don't want to execute this kind of nonsense; just for making sure
+   * that compilation works... */
+  memset(&op, 0, sizeof(op));
+  r = kate_ogg_decode_headerin (&ki, &kc, &op);
+  r = kate_decode_headerin (&ki, &kc, &kp);
+  r = kate_decode_init (&k, &ki);
+  t = kate_granule_time (&ki, op.granulepos);
+  r = kate_decode_packetin (&k, &op);
+  r = kate_decode_eventout (&k, &ev);
+  r = kate_high_decode_init(&k);
+  kate_clear (&k);
+
+  return 0;
+}
+EOF
+  for _ld_kate in "`$_pkg_config --silence-errors --libs --cflags oggkate`" "-loggkate -lkate -logg"; do
+    cc_check $_ld_kate && _ld_extra="$_ld_extra $_ld_kate" \
+                         && _kate=yes && break
+  done
+fi
+if test "$_kate" = yes ; then
+  _def_kate='#define HAVE_OGGKATE 1'
+  _codecmodules="libkate $_codecmodules"
+  # when --enable-kate is forced, we'd better provide a probably sane
+  # $_ld_kate than nothing
+  test -z "$_ld_kate" && _ld_extra="$_ld_extra -loggkate -lkate -logg"
+else
+  _def_kate='#undef HAVE_OGGKATE'
+  _nocodecmodules="libkate $_nocodecmodules"
+fi
+echores "$_kate"
+
 echocheck "internal mp3lib support"
 if test "$_mp3lib" = yes ; then
   _def_mp3lib='#define USE_MP3LIB 1'
@@ -7790,6 +7849,7 @@
 LIBMAD = $_mad
 LIBVORBIS = $_vorbis
 LIBTHEORA = $_theora
+LIBKATE = $_kate
 FAAD_INTERNAL = $_faad_internal
 FAAD_FIXED = $_faad_fixed
 LIBSMBCLIENT = $_smbsupport
@@ -8476,6 +8536,9 @@
 /* enable OggTheora support */
 $_def_theora
 
+/* enable Kate support */
+$_def_kate
+
 /* enable FAAD (AAC) support */
 $_def_faad
 $_def_faad_internal
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/katedec.c mplayer-svn-with-kate/katedec.c
--- mplayer-svn/katedec.c	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-svn-with-kate/katedec.c	2008-10-09 09:00:23.000000000 +0100
@@ -0,0 +1,320 @@
+/* Katedec.c
+
+   ogg.k.ogg.k@googlemail.com
+
+   For information on the Kate format see:
+   <URL:http://wiki.xiph.org/index.php/OggKate>
+
+ */
+#include "config.h"
+#include "mp_msg.h"
+
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <math.h>
+#include "libvo/sub.h"
+#include "libvo/video_out.h"
+#include "spudec.h"
+#include "katedec.h"
+#include "libavutil/avutil.h"
+#include "libswscale/swscale.h"
+
+#ifdef HAVE_OGGKATE
+#include <kate/kate.h>
+#endif
+
+#ifdef HAVE_OGGKATE
+
+/* if no canvas size if specified, default to DVD size, that's a good guess */
+#define DEFAULT_CANVAS_WIDTH 720
+#define DEFAULT_CANVAS_HEIGHT 576
+
+/* TODO: this means we can't have two Kate streams active at the same time */
+static int katedec_has_kin=0;
+static kate_tracker katedec_kin;
+static unsigned char *katedec_image=NULL;
+static unsigned char *katedec_y=NULL;
+static unsigned char *katedec_a=NULL;
+static unsigned char *katedec_scaled_y=NULL;
+static unsigned char *katedec_scaled_a=NULL;
+static size_t katedec_scaled_image_size=0;
+
+/* worked out the format mplayer expects, it's YA on 2 8 bit planes - UV aren't used */
+static inline int katedec_color_to_y(kate_color kc)
+{
+  /* adapted from vobsub.c */
+  /* TODO: plenty of conversions here, could do some integer only code, though we'll still have promotions */
+  return ( 0.299 * kc.r + 0.587 * kc.g + 0.114 * kc.b) * 219 / 255 + 16.5;
+}
+
+static inline int frob_alpha(int a)
+{
+  /* spudec.c says:
+     In mplayer's alpha planes, 0 is transparent, then 1 is nearly
+     opaque upto 255 which is transparent */
+  if (a>0) return 256-a;
+  return 0;
+}
+
+extern
+int spudec_draw_scaled_image(unsigned int dxs, unsigned int dys,
+                             /*const*/ unsigned char *image, /*const*/ unsigned char *aimage,
+                             unsigned int start_col, unsigned int start_row, unsigned int width, unsigned int height, unsigned int stride,
+                             unsigned int orig_frame_width, unsigned int orig_frame_height,
+                             unsigned int *scaled_frame_width, unsigned int *scaled_frame_height,
+                             unsigned char **scaled_image, unsigned char **scaled_aimage, size_t *scaled_image_size,
+                             void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+
+/* if we call draw_alpha directly, we get graphical artifacts on the right side of the image,
+   due to... scaling bugs ? - i don't think they're due to my rearrangement in spudec.c,
+   but it wouldn't surprise me - can't find it though */
+static void (*draw_alpha_ptr)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)=0;
+static void draw_alpha_proxy(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride)
+{
+  int y,n;
+  size_t needed = stride*h;
+
+  /* sized to the (supposed) max size of a SPU */
+  static char tda_y[720*576]; // TODO: allocate dynamically
+  static char tda_a[sizeof(tda_y)]; // TODO: allocate dynamically
+
+  if (needed > sizeof tda_y) {
+    mp_msg (MSGT_FIXME, MSGL_WARN, "kate: SPU too large (needing %u bytes, %u available), there will be graphical artifacts\n",
+        needed, sizeof(tda_y));
+    (*draw_alpha_ptr)(x0,y0,w,h,src,srca,stride);
+    return;
+  }
+
+  // TODO: can we lose this ?
+  memset(tda_y, 0, needed);
+  memset(tda_a, 0, needed);
+
+  n=0;
+  for (y=0;y<h;++y) {
+    memcpy(tda_y+n, src+stride*y, w);
+    memcpy(tda_a+n, srca+stride*y, w);
+    memset(tda_y+n+w, 0, stride-w);
+    memset(tda_a+n+w, 0, stride-w);
+    n+=stride;
+  }
+  (*draw_alpha_ptr)(x0,y0,w,h,tda_y,tda_a,stride);
+}
+
+#endif
+
+void katedec_draw(unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+{
+#ifdef HAVE_OGGKATE
+  if (katedec_has_kin) {
+    int xpos = katedec_kin.has.region ? (int)(katedec_kin.region_x+0.5f) : 0;
+    int ypos = katedec_kin.has.region ? (int)(katedec_kin.region_y+0.5f) : 0;
+#if (((KATE_VERSION_MAJOR)<<16) | ((KATE_VERSION_MINOR)<<8) | (KATE_VERSION_PATCH)) >= 0x000105
+    int original_canvas_width = katedec_kin.ki->original_canvas_width ? katedec_kin.ki->original_canvas_width : DEFAULT_CANVAS_WIDTH;
+    int original_canvas_height = katedec_kin.ki->original_canvas_height ? katedec_kin.ki->original_canvas_height : DEFAULT_CANVAS_HEIGHT;
+#else
+    int original_canvas_width = DEFAULT_CANVAS_WIDTH;
+    int original_canvas_height = DEFAULT_CANVAS_HEIGHT;
+#endif
+    const kate_bitmap *kb=katedec_kin.event->bitmap;
+    const kate_palette *kp=katedec_kin.event->palette;
+    size_t w=kb->width;
+    size_t h=kb->height;
+    size_t stride = (w+7)&~7; /* seen a comment somewhere saying 8 alignment is needed */
+    unsigned int scaled_frame_width = 0;
+    unsigned int scaled_frame_height = 0;
+
+    if (!katedec_image) {
+      size_t n,src,x,l;
+
+      mp_msg (MSGT_FIXME, MSGL_DBG2, "creating kate_bitmap\n");
+
+      katedec_image = malloc(2*stride*h);
+      if (!katedec_image) {
+        mp_msg (MSGT_FIXME, MSGL_WARN, "kate: failed to allocate %lu bytes\n", 2ul*stride*h);
+        return;
+      }
+      katedec_y=katedec_image;
+      katedec_a=katedec_image+stride*h;
+
+      n=0;
+      src=0;
+      for (l=0; l<h; ++l) {
+        for (x=0; x<w; ++x) {
+          kate_color kc=kp->colors[kb->pixels[src]];
+
+          /* odd, weird, and makes it work - for me at least - adapted from spudec.c */
+#if 0
+          katedec_y[n] = kc.r; /* faster */
+#else
+          katedec_y[n]=katedec_color_to_y(kc); /* probably more correct */
+#endif
+          if (katedec_y[n] + kc.a <= 255) katedec_y[n] = 256 - katedec_y[n];
+          katedec_a[n]=frob_alpha(kc.a);
+
+#if 0
+          // black rectangle - for testing
+          katedec_y[n] = 16;
+          katedec_a[n] = 1;
+#endif
+
+          ++n;
+          ++src;
+        }
+
+#if 1
+        /* skip to the next line */
+        n += stride-w;
+#else
+        /* empty the leftover right border */
+        while (x++<stride) {
+          katedec_y[n]=0;
+          katedec_a[n]=0;
+          ++n;
+        }
+#endif
+      }
+#if 0
+      /* black border for testing */
+      for (n=0;n<w;++n) {
+        katedec_y[0*stride+n]=0;
+        katedec_a[0*stride+n]=1;
+        katedec_y[(h-1)*stride+n]=0;
+        katedec_a[(h-1)*stride+n]=1;
+      }
+      for (n=0;n<h;++n) {
+        katedec_y[0+n*stride]=0;
+        katedec_a[0+n*stride]=1;
+        katedec_y[(w-1)+n*stride]=0;
+        katedec_a[(w-1)+n*stride]=1;
+      }
+      for (n=0;n<stride;++n) {
+        katedec_y[0*stride+n]=0;
+        katedec_a[0*stride+n]=1;
+        katedec_y[(h-1)*stride+n]=0;
+        katedec_a[(h-1)*stride+n]=1;
+      }
+      for (n=0;n<h;++n) {
+        katedec_y[0+n*stride]=0;
+        katedec_a[0+n*stride]=1;
+        katedec_y[(stride-1)+n*stride]=0;
+        katedec_a[(stride-1)+n*stride]=1;
+      }
+#endif
+    }
+
+#if 0
+    draw_alpha(xpos,ypos,w,h,katedec_y,katedec_a,stride);
+#else
+    draw_alpha_ptr=draw_alpha;
+#if 1
+    /*
+       we don't want to scale the position, just the image, as:
+        - either the positions were expressed in absolute pixels, in which case we must use those
+        - either they were expressed in relative units, in which case the tracker will already
+          have given us the correct positions
+     */
+    xpos = xpos*original_canvas_width/dxs;
+    ypos = ypos*original_canvas_height/dys;
+#endif
+    spudec_draw_scaled_image(dxs, dys,
+                             katedec_y, katedec_a,
+                             xpos, ypos, w, h, stride,
+                             original_canvas_width, original_canvas_height,
+                             &scaled_frame_width, &scaled_frame_height,
+                             &katedec_scaled_y, &katedec_scaled_a, &katedec_scaled_image_size,
+                             draw_alpha_proxy);
+#endif
+  }
+#endif
+}
+
+int katedec_decode(sh_sub_t *sh, sh_video_t *sh_video, subtitle *subs, int nbytes, unsigned char *data)
+{
+#ifdef HAVE_OGGKATE
+    kate_packet kp;
+    const kate_event *ev;
+    int ret;
+
+    mp_msg (MSGT_FIXME, MSGL_DBG2, "kate: decoding %d byte packet from %p\n", nbytes, sh);
+
+    ret = kate_packet_wrap(&kp, nbytes, data);
+    if (ret < 0) {
+      mp_msg (MSGT_FIXME, MSGL_WARN, "kate_packet_wrap failed: %d\n", ret);
+      return -1;
+    }
+    ret = kate_high_decode_packetin(sh->k, &kp, &ev);
+    if (ret < 0) {
+      mp_msg (MSGT_FIXME, MSGL_WARN, "kate_high_decode_packetin failed to decode %d byte packet: %d\n", nbytes, ret);
+      return -1;
+    }
+    if (ret > 0) {
+      mp_msg (MSGT_FIXME, MSGL_INFO, "Kate headers decoded, ready\n");
+    }
+
+    if (ev) {
+      /* kate supports overlapping subtitles, but we don't support this here,
+         so clear subtitles when we add another one, in case */
+      /*if (endpts == MP_NOPTS_VALUE)*/
+      sub_clear_text(subs, MP_NOPTS_VALUE);
+      katedec_reset();
+
+      if (ev->text && ev->len>0) {
+        sub_utf8 = 1;
+        sub_add_text(subs, ev->text, ev->len0, ev->end_time);
+        vo_osd_changed(OSDTYPE_SUBTITLE);
+      }
+      if (ev->bitmap && ev->palette) {
+        ret = kate_tracker_init(&katedec_kin, ev->ki, ev);
+        if (ret < 0) {
+          mp_msg (MSGT_FIXME, MSGL_WARN, "kate_tracker_init failed: %d\n", ret);
+          return -1;
+        }
+        ret = kate_tracker_update(&katedec_kin, 0.0f, sh_video->disp_w,sh_video->disp_h, 0, 0, sh_video->disp_w,sh_video->disp_h);
+        if (ret < 0) {
+          mp_msg (MSGT_FIXME, MSGL_WARN, "kate_tracker_update failed: %d\n", ret);
+          kate_tracker_clear(&katedec_kin);
+          return -1;
+        }
+        katedec_has_kin=1;
+        vo_osd_changed(OSDTYPE_KATE);
+      }
+    }
+#endif
+    return 0;
+}
+
+void katedec_reset()
+{
+#ifdef HAVE_OGGKATE
+  if (katedec_has_kin) {
+    kate_tracker_clear(&katedec_kin);
+    free(katedec_image);
+    katedec_image=NULL;
+    katedec_y=NULL;
+    katedec_a=NULL;
+    katedec_has_kin=0;
+    vo_osd_changed(OSDTYPE_KATE);
+  }
+#endif
+}
+
+void katedec_tick(sh_sub_t *sh, double pts)
+{
+#ifdef HAVE_OGGKATE
+  if (katedec_has_kin) {
+    /* if an event has an end time equal to its start time, we keep it till
+       the next one arrives (some DVDs have that kind of end-less SPUs).
+       Newer versions of the Kate GStreamer plugin detect this and make a
+       good guess at a likely end time, but we can't rely on this (eg, if
+       encoded by some other tool which doesn't do this) */
+    if (katedec_kin.event->end_time > katedec_kin.event->start_time && pts >= katedec_kin.event->end_time) {
+      katedec_reset();
+    }
+  }
+#endif
+}
+
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/katedec.h mplayer-svn-with-kate/katedec.h
--- mplayer-svn/katedec.h	1970-01-01 01:00:00.000000000 +0100
+++ mplayer-svn-with-kate/katedec.h	2008-09-06 18:22:35.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef MPLAYER_KATEDEC_H
+#define MPLAYER_KATEDEC_H
+
+#include "libvo/video_out.h"
+#include "libmpdemux/stheader.h"
+
+extern int katedec_decode(sh_sub_t *sh, sh_video_t *sh_video, subtitle *subs, int nbytes, unsigned char *data);
+extern void katedec_draw(unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride));
+extern void katedec_reset();
+extern void katedec_tick(sh_sub_t *sh, double pts);
+
+#endif /* MPLAYER_KATEDEC_H */
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/demux_mkv.c mplayer-svn-with-kate/libmpdemux/demux_mkv.c
--- mplayer-svn/libmpdemux/demux_mkv.c	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/demux_mkv.c	2008-06-14 20:17:40.000000000 +0100
@@ -128,7 +128,7 @@
   mkv_content_encoding_t *encodings;
   int num_encodings;
 
-  /* For VobSubs and SSA/ASS */
+  /* For VobSubs, SSA/ASS and Kate */
   sh_sub_t *sh_sub;
 } mkv_track_t;
 
@@ -1016,7 +1016,9 @@
             }
           else if (!strcmp (track->codec_id, MKV_S_TEXTASCII))
             track->subtitle_type = MATROSKA_SUBTYPE_TEXT;
-          if (!strcmp (track->codec_id, MKV_S_TEXTUTF8))
+          else if (!strcmp (track->codec_id, MKV_S_KATE))
+            track->subtitle_type = MATROSKA_SUBTYPE_KATE;
+          else if (!strcmp (track->codec_id, MKV_S_TEXTUTF8))
             {
               track->subtitle_type = MATROSKA_SUBTYPE_TEXT;
             }
@@ -2203,6 +2205,8 @@
         sh->type = 'v';
       if (track->subtitle_type == MATROSKA_SUBTYPE_SSA)
         sh->type = 'a';
+      else if (track->subtitle_type == MATROSKA_SUBTYPE_KATE)
+        sh->type = 'k';
       size = track->private_size;
       m = demux_mkv_decode (track,track->private_data,&buffer,&size,2);
       if (buffer && m)
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/demux_ogg.c mplayer-svn-with-kate/libmpdemux/demux_ogg.c
--- mplayer-svn/libmpdemux/demux_ogg.c	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/demux_ogg.c	2008-10-09 19:32:02.000000000 +0100
@@ -32,6 +32,11 @@
 extern int _ilog (unsigned int); /* defined in many places in theora/lib/ */
 #endif
 
+#ifdef HAVE_OGGKATE
+#include <kate/kate.h>
+#include <kate/oggkate.h>
+#endif
+
 #define BLOCK_SIZE 4096
 
 /* Theora decoder context : we won't be able to interpret granule positions
@@ -106,6 +111,7 @@
   int vorbis;
   int speex;
   int theora;
+  int kate;
   int flac;
   int text;
   int id;
@@ -113,6 +119,8 @@
   vorbis_info      vi;
   int vi_initialized;
 
+  int gshift;
+
   void *ogg_d;
 } ogg_stream_t;
 
@@ -157,7 +165,7 @@
 static subtitle ogg_sub;
 //FILE* subout;
 
-void demux_ogg_add_sub (ogg_stream_t* os,ogg_packet* pack) {
+static void demux_ogg_add_sub (ogg_stream_t* os,ogg_packet* pack) {
   int lcv;
   char *packet = pack->packet;
 
@@ -293,6 +301,17 @@
 	*pts = (double)os->lastpos / (double)os->samplerate;
      }
 #endif /* HAVE_OGGTHEORA */
+# ifdef HAVE_OGGKATE
+  } else if (os->kate) {
+	if (pack->granulepos >= 0)
+	{
+          int64_t base, offset;
+	  base = pack->granulepos >> os->gshift;
+	  offset = pack->granulepos - (base << os->gshift);
+          *pts = (double)(base+offset) / (double)os->samplerate;
+	}
+
+#endif /* HAVE_OGGKATE */
   } else if (os->flac) {
      /* we pass complete packets to flac, mustn't strip the header! */
      if (os->flac == 2 && pack->packet[0] != 0xff)
@@ -449,6 +468,7 @@
       demux_ogg_add_sub(os,pack);
     return 0;
   }
+
   if (os->speex) {
     // discard first two packets, they contain the header and comment
     if (os->hdr_packets < 2) {
@@ -458,9 +478,9 @@
   } else
   // If packet is an header we jump it except for vorbis and theora
   // (PACKET_TYPE_HEADER bit doesn't even exist for theora ?!)
-  // We jump nothing for FLAC. Ain't this great? Packet contents have to be
-  // handled differently for each and every stream type. The joy! The joy!
-  if(!os->flac && (*pack->packet & PACKET_TYPE_HEADER) && 
+  // We jump nothing for FLAC or Kate. Ain't this great? Packet contents have to
+  // be handled differently for each and every stream type. The joy! The joy!
+  if(!os->flac && !os->kate && (*pack->packet & PACKET_TYPE_HEADER) && 
      (ds != d->audio || ((sh_audio_t*)ds->sh)->format != FOURCC_VORBIS || os->hdr_packets >= NUM_VORBIS_HDR_PACKETS ) &&
      (ds != d->video || (((sh_video_t*)ds->sh)->format != FOURCC_THEORA)))
     return 0;
@@ -477,6 +497,30 @@
   if (!data)
     return 0;
 
+  // for Kate headers, we can't just ds_add_packet the packet because MPlayer will
+  // helpfully clear the subtitles packet queue before starting polling it, so we
+  // never get those, so we pass them to libakte now, apart from the first one,
+  // which was already eaten when probing
+  if (pack->bytes>0 && (pack->packet[0] & 0x80) && pack->packet[0]!=0x80 && !memcmp(pack->packet+1,"kate\0\0\0",7)) {
+    /* Kate packets: forward headers for all streams, so they're all ready for decoding,
+       but only pass data for the currently selected one, if any */
+    sh_sub_t *sh = d->s_streams[id];
+    kate_packet kp;
+    int ret;
+
+    kate_packet_wrap(&kp, pack->bytes, pack->packet);
+    ret = kate_high_decode_packetin(sh->k, &kp, NULL);
+    if (ret<0) {
+      mp_msg(MSGT_DEMUX,MSGL_WARN,"kate_high_decode_packetin failed: %d\n", ret);
+    }
+    return 0;
+  }
+  else if (ds->sh && ((sh_sub_t*)ds->sh)->type == 'k') {
+    /* we do not forward Kate events for non active streams */
+    const sh_sub_t *sh = d->s_streams[id];
+    if (sh && dvdsub_id != sh->sid) return 0;
+  }
+
   /// Clear subtitles if necessary (for broken files)
   if (sub_clear_text(&ogg_sub, pts)) {
     vo_sub = &ogg_sub;
@@ -754,6 +798,7 @@
   ogg_packet pack;
   sh_audio_t* sh_a;
   sh_video_t* sh_v;
+  sh_sub_t* sh_s;
 
 #ifdef USE_ICONV
   subcp_open(NULL);
@@ -816,6 +861,7 @@
     // Reset our vars
     sh_a = NULL;
     sh_v = NULL;
+    sh_s = NULL;
 
     ogg_d->subs[ogg_d->num_sub].ogg_d = ogg_d;
 
@@ -895,6 +941,62 @@
 	theora_comment_clear(&cc);
 	theora_info_clear(&inf);
 #   endif /* HAVE_OGGTHEORA */
+#   ifdef HAVE_OGGKATE
+    } else if (pack.bytes >= 8 && !strncmp (&pack.packet[1], "kate\0\0\0", 7)) {
+	int ret;
+
+        sh_s = new_sh_sub_sid(demuxer, ogg_d->num_sub, ogg_d->n_text);
+        sh_s->type = 'k';
+
+        sh_s->k = (kate_state*)malloc(sizeof(kate_state));
+        ret = kate_high_decode_init(sh_s->k);
+        if (ret<0) {
+	    mp_msg(MSGT_DEMUX,MSGL_ERR,"Kate failed to initialize for decoding: %d\n", ret);
+        }
+        else {
+          kate_packet kp;
+          const kate_info *ki = sh_s->k->ki;
+
+          kate_packet_wrap(&kp, pack.bytes, pack.packet);
+	  ret = kate_high_decode_packetin (sh_s->k, &kp, NULL);
+	  if (ret<0)
+          {
+	      mp_msg(MSGT_DEMUX,MSGL_ERR,"Kate header %lld parsing failed: %d\n", pack.packetno, ret);
+          }
+	  else
+	  {
+            mp_msg(MSGT_DEMUX, MSGL_INFO, "[Ogg] stream %d: Kate %d.%d (%s), language \"%s\", -sid %d\n",
+                ogg_d->num_sub,
+                ki->bitstream_version_major, ki->bitstream_version_minor,
+                ki->category ?  ki->category : "no category", 
+                ki->language ? ki->language : "<unset>",
+                ogg_d->n_text);
+	    ogg_d->subs[ogg_d->num_sub].samplerate = ki->gps_numerator / (float)ki->gps_denominator;
+	    ogg_d->subs[ogg_d->num_sub].kate = 1;
+	    ogg_d->subs[ogg_d->num_sub].gshift = ki->granule_shift;
+            ogg_d->subs[ogg_d->num_sub].id = ogg_d->n_text;
+            if (demuxer->sub->id == ogg_d->n_text)
+              text_id = ogg_d->num_sub;
+            ogg_d->n_text++;
+            ogg_d->text_ids = (int *)realloc(ogg_d->text_ids, sizeof(int) * ogg_d->n_text);
+            ogg_d->text_ids[ogg_d->n_text - 1] = ogg_d->num_sub;
+            ogg_d->text_langs = (char **)realloc(ogg_d->text_langs, sizeof(char *) * ogg_d->n_text);
+            ogg_d->text_langs[ogg_d->n_text - 1] = NULL;
+	    if (ki->language) {
+               ogg_d->text_langs[ogg_d->n_text - 1] = strdup(ki->language);
+               sh_s->lang = strdup(ki->language);
+            }
+
+            // check for -slang if subs are uninitialized yet
+            if (ki->language && demuxer->sub->id < 0 && demux_ogg_check_lang(ki->language, dvdsub_lang))
+            {
+	      demuxer->sub->id = ogg_d->n_text-1;
+	      dvdsub_id = ogg_d->n_text-1;
+              mp_msg(MSGT_DEMUX, MSGL_V, "Ogg demuxer: Displaying subtitle stream id %d which matched -slang %s\n", ogg_d->n_text-1, ki->language);
+            }
+          }
+	}
+#   endif /* HAVE_OGGKATE */
     } else if (pack.bytes >= 4 && !strncmp (&pack.packet[0], "fLaC", 4)) {
 	sh_a = new_sh_audio_aid(demuxer,ogg_d->num_sub, n_audio);
 	sh_a->format =  mmioFOURCC('f', 'L', 'a', 'C');
@@ -1052,7 +1154,7 @@
     } else
       mp_msg(MSGT_DEMUX,MSGL_ERR,"Ogg stream %d is of an unknown type\n",ogg_d->num_sub);
 
-    if(sh_a || sh_v) {
+    if(sh_a || sh_v || sh_s) {
       demux_stream_t* ds = NULL;
       if(sh_a) {
 	// If the audio stream is not defined we took the first one
@@ -1081,6 +1183,18 @@
           video_id = ogg_d->num_sub;
 	}
       }
+      if(sh_s) {
+	/// and for text too
+	if(demuxer->sub->id == -1) {
+	  demuxer->sub->id = ogg_d->n_text - 1;
+	}
+	if(demuxer->sub->id == ogg_d->n_text - 1) {
+	  demuxer->sub->sh = sh_s;
+	  //sh_s->ds = demuxer->sub; // has no ds field - we presumably don't need it
+	  ds = demuxer->sub;
+          //sub_id = ogg_d->num_sub;
+	}
+      }
       /// Add the header packets if the stream isn't seekable
       if(ds && !s->end_pos) {
 	/// Finish the page, otherwise packets will be lost
@@ -1209,7 +1323,7 @@
       ds = d->audio;
     else if(id == d->video->id)
       ds = d->video;
-    else if (ogg_d->subs[id].text)
+    else if (ogg_d->subs[id].text || ogg_d->subs[id].kate)
       ds = d->sub;
 
     if(ds) {
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/demuxer.c mplayer-svn-with-kate/libmpdemux/demuxer.c
--- mplayer-svn/libmpdemux/demuxer.c	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/demuxer.c	2008-06-15 13:38:31.000000000 +0100
@@ -27,6 +27,10 @@
 #include "libass/ass_mp.h"
 #endif
 
+#ifdef HAVE_OGGKATE
+#include <kate/kate.h>
+#endif
+
 extern void resync_video_stream(sh_video_t *sh_video);
 extern void resync_audio_stream(sh_audio_t *sh_audio);
 
@@ -251,6 +255,10 @@
 #ifdef USE_ASS
     if (sh->ass_track) ass_free_track(sh->ass_track);
 #endif
+#ifdef HAVE_OGGKATE
+    kate_high_decode_clear(sh->k);
+    free(sh->k);
+#endif
     free(sh->lang);
     free(sh);
 }
@@ -687,6 +695,53 @@
   return -1;
 }
 
+/*
+   Splits extra data from a single block into kate_packets and decode them.
+*/
+static int
+parse_kate_headers (kate_state *k, void *extradata, size_t extradata_len)
+{
+  int n,nlaces,offset,ret;
+  const unsigned char **header_data;
+  const unsigned char *priv;
+  size_t *header_size;
+
+  if ((extradata == NULL) || (extradata_len == 0))
+    return KATE_E_BAD_PACKET;
+
+  priv = (const unsigned char*)extradata;
+  nlaces = priv[0];
+  header_data=(const unsigned char**)alloca((nlaces+1)*sizeof(const unsigned char*));
+  header_size=(size_t*)alloca((nlaces+1)*sizeof(size_t));
+
+  offset=1;
+  for (n=0;n<nlaces;++n) {
+    header_size[n]=0;
+    do {
+      header_size[n]+=priv[offset];
+    } while (priv[offset++]==255);
+  }
+  header_size[nlaces]=extradata_len-offset;
+  for (n=0;n<nlaces;++n) header_size[nlaces]-=header_size[n];
+  header_data[0]=priv+offset;
+  for (n=1;n<=nlaces;++n) {
+    header_data[n]=header_data[n-1]+header_size[n-1];
+  }
+
+  for (n=0;n<nlaces+1;++n) {
+    kate_packet kp;
+    kate_packet_wrap(&kp,header_size[n],header_data[n]);
+    ret=kate_high_decode_packetin(k,&kp,NULL);
+    if (ret<0) {
+      mp_msg (MSGT_DEMUXER, MSGL_WARN, "kate_high_decode_packetin returned %d\n", ret);
+      kate_high_decode_clear(k);
+      return ret;
+    }
+  }
+
+  return 0;
+}
+
 int extension_parsing=1; // 0=off 1=mixed (used only for unstable formats)
 
 int correct_pts=0;
@@ -843,10 +898,11 @@
     sh_video->i_bps*0.008f,
     sh_video->i_bps/1024.0f );
 }
+
+ for (i = 0; i < MAX_S_STREAMS; ++i) {
+   sh_sub_t* sh = demuxer->s_streams[i];
 #ifdef USE_ASS
- if (ass_enabled && ass_library) {
-   for (i = 0; i < MAX_S_STREAMS; ++i) {
-     sh_sub_t* sh = demuxer->s_streams[i];
+   if (ass_enabled && ass_library) {
      if (sh && sh->type == 'a') {
        sh->ass_track = ass_new_track(ass_library);
        if (sh->ass_track && sh->extradata)
@@ -854,8 +910,36 @@
      } else if (sh && sh->type != 'v')
        sh->ass_track = ass_default_track(ass_library);
    }
- }
 #endif
+#ifdef HAVE_OGGKATE
+   if (sh && sh->type == 'k' && !sh->k) {
+     sh->k = (kate_state*)malloc(sizeof(kate_state));
+     if (sh->k) {
+       int ret;
+       ret = kate_high_decode_init(sh->k);
+       if (ret >= 0) {
+         ret = parse_kate_headers(sh->k, sh->extradata, sh->extradata_len);
+         if (ret >= 0) {
+           /* init success */
+           mp_msg(MSGT_DEMUX,MSGL_V,"Kate init success, language %s, category %s\n",
+               sh->k->ki->language, sh->k->ki->language);
+           if (sh->lang) free(sh->lang);
+           sh->lang = strdup(sh->k->ki->language);
+         }
+         else {
+           mp_msg(MSGT_DEMUX,MSGL_WARN,"Failed to parse kate stream headers: %d\n", ret);
+         }
+       }
+       else {
+         mp_msg(MSGT_DEMUX,MSGL_WARN,"Failed to initialize kate_state: %d\n", ret);
+       }
+     }
+     else {
+       mp_msg(MSGT_DEMUX,MSGL_WARN,"Failed to allocate %u bytes for kate_state\n", sizeof(kate_state));
+     }
+   }
+#endif
+ }
 return demuxer;
 }
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/ebml.h mplayer-svn-with-kate/libmpdemux/ebml.h
--- mplayer-svn/libmpdemux/ebml.h	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/ebml.h	2008-03-15 20:49:21.000000000 +0000
@@ -162,6 +162,7 @@
 #define MATROSKA_SUBTYPE_TEXT      1
 #define MATROSKA_SUBTYPE_SSA       2
 #define MATROSKA_SUBTYPE_VOBSUB    3
+#define MATROSKA_SUBTYPE_KATE      4
 
 #ifndef UINT64_MAX
 #define UINT64_MAX 18446744073709551615ULL
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/matroska.h mplayer-svn-with-kate/libmpdemux/matroska.h
--- mplayer-svn/libmpdemux/matroska.h	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/matroska.h	2008-03-15 20:49:21.000000000 +0000
@@ -60,6 +60,7 @@
 #define MKV_S_TEXTSSA    "S_TEXT/SSA"
 #define MKV_S_TEXTASS    "S_TEXT/ASS"
 #define MKV_S_VOBSUB     "S_VOBSUB"
+#define MKV_S_KATE       "S_KATE"
 #define MKV_S_SSA        "S_SSA" // Deprecated
 #define MKV_S_ASS        "S_ASS" // Deprecated
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libmpdemux/stheader.h mplayer-svn-with-kate/libmpdemux/stheader.h
--- mplayer-svn/libmpdemux/stheader.h	2008-03-14 13:26:57.000000000 +0000
+++ mplayer-svn-with-kate/libmpdemux/stheader.h	2008-06-15 12:06:20.000000000 +0100
@@ -95,7 +95,7 @@
 
 typedef struct {
   int sid;
-  char type;                    // t = text, v = VobSub, a = SSA/ASS
+  char type;                    // t = text, v = VobSub, a = SSA/ASS, k = kate
   int has_palette;              // If we have a valid palette
   unsigned int palette[16];     // for VobSubs
   int width, height;            // for VobSubs
@@ -107,6 +107,9 @@
 #ifdef USE_ASS
   ass_track_t* ass_track;  // for SSA/ASS streams (type == 'a')
 #endif
+#ifdef HAVE_OGGKATE
+  struct kate_state *k;
+#endif
   char* lang; // track language
 } sh_sub_t;
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libvo/sub.c mplayer-svn-with-kate/libvo/sub.c
--- mplayer-svn/libvo/sub.c	2008-03-14 13:26:58.000000000 +0000
+++ mplayer-svn-with-kate/libvo/sub.c	2008-09-02 23:09:03.000000000 +0100
@@ -26,6 +26,7 @@
 #include "font_load.h"
 #include "sub.h"
 #include "spudec.h"
+#include "katedec.h"
 #include "libavutil/common.h"
 
 #define NEW_SPLITTING
@@ -1022,11 +1023,22 @@
   obj->flags |= OSDFLAG_BBOX;
 }
 
+inline static void vo_update_kate(mp_osd_obj_t* obj, int dxs, int dys)
+{
+  // TODO: update tiger_renderer
+  obj->flags|=OSDFLAG_CHANGED|OSDFLAG_VISIBLE;
+}
+
 inline static void vo_draw_spudec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, unsigned char* src, unsigned char* srca, int stride))
 {
   spudec_draw_scaled(vo_spudec, obj->dxs, obj->dys, draw_alpha);
 }
 
+inline static void vo_draw_katedec_sub(mp_osd_obj_t* obj, void (*draw_alpha)(int x0, int y0, int w, int h, unsigned char* src, unsigned char* srca, int stride))
+{
+  katedec_draw(obj->dxs, obj->dys, draw_alpha);
+}
+
 void *vo_spudec=NULL;
 void *vo_vobsub=NULL;
 
@@ -1146,6 +1158,11 @@
 	    } else
 		obj->flags&=~OSDFLAG_VISIBLE;
 	    break;
+#ifdef HAVE_OGGKATE
+        case OSDTYPE_KATE:
+           vo_update_kate(obj,dxs,dys);
+           break;
+#endif
 	}
 	// check bbox:
 	if(!(obj->flags&OSDFLAG_BBOX)){
@@ -1198,6 +1215,9 @@
 #if HAVE_TV_TELETEXT
     new_osd_obj(OSDTYPE_TELETEXT);
 #endif
+#if HAVE_OGGKATE
+    new_osd_obj(OSDTYPE_KATE);
+#endif
 #ifdef HAVE_FREETYPE
     force_load_font = 1;
 #endif
@@ -1244,6 +1264,11 @@
 	case OSDTYPE_PROGBAR:
 	    vo_draw_text_from_buffer(obj,draw_alpha);
 	    break;
+#ifdef HAVE_OGGKATE
+        case OSDTYPE_KATE:
+	    vo_draw_katedec_sub(obj, draw_alpha);
+	    break;
+#endif
 	}
 	obj->old_bbox=obj->bbox;
 	obj->flags|=OSDFLAG_OLD_BBOX;
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/libvo/sub.h mplayer-svn-with-kate/libvo/sub.h
--- mplayer-svn/libvo/sub.h	2008-03-14 13:26:58.000000000 +0000
+++ mplayer-svn-with-kate/libvo/sub.h	2008-06-15 13:43:37.000000000 +0100
@@ -12,6 +12,7 @@
 #define OSDTYPE_SPU 4
 #define OSDTYPE_DVDNAV 5
 #define OSDTYPE_TELETEXT 6
+#define OSDTYPE_KATE 7
 
 #define OSDFLAG_VISIBLE 1
 #define OSDFLAG_CHANGED 2
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/mpcommon.c mplayer-svn-with-kate/mpcommon.c
--- mplayer-svn/mpcommon.c	2008-03-14 13:27:00.000000000 +0000
+++ mplayer-svn-with-kate/mpcommon.c	2008-10-09 08:46:19.000000000 +0100
@@ -20,6 +20,10 @@
 ass_track_t* ass_track = 0; // current track to render
 #endif
 
+#ifdef HAVE_OGGKATE
+#include "katedec.h"
+#endif
+
 sub_data* subdata = NULL;
 subtitle* vo_sub_last = NULL;
 
@@ -39,6 +43,7 @@
             spudec_reset(vo_spudec);
             vo_osd_changed(OSDTYPE_SPU);
         }
+        katedec_reset();
     }
     // find sub
     if (subdata) {
@@ -100,6 +105,22 @@
 
         if (spudec_changed(vo_spudec))
             vo_osd_changed(OSDTYPE_SPU);
+    } else if (dvdsub_id >= 0 && type == 'k') {
+	double curpts = sh_video->pts + sub_delay;
+        sh_sub_t* sh = d_dvdsub->sh;
+	vo_sub = &subs;
+	while (d_dvdsub->first) {
+	    double pts = ds_get_next_pts(d_dvdsub);
+	    if (pts > curpts)
+		break;
+	    len = ds_get_packet_sub(d_dvdsub, &packet);
+	    if (pts != MP_NOPTS_VALUE) {
+                katedec_decode(sh, sh_video, &subs, len, packet);
+	    }
+	}
+	if (sub_clear_text(&subs, curpts))
+	    vo_osd_changed(OSDTYPE_SUBTITLE);
+	katedec_tick(sh, curpts);
     } else if (dvdsub_id >= 0 && (type == 't' || type == 'm' || type == 'a')) {
         double curpts = sh_video->pts + sub_delay;
         double endpts;
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/mplayer.c mplayer-svn-with-kate/mplayer.c
--- mplayer-svn/mplayer.c	2008-03-14 13:27:00.000000000 +0000
+++ mplayer-svn-with-kate/mplayer.c	2008-10-09 19:28:45.000000000 +0100
@@ -1115,6 +1115,15 @@
     forced_subs_only = mkv_sh_sub->forced_subs_only;
   }
 
+  if ((vo_spudec == NULL) &&
+      (mpctx->demuxer->type == DEMUXER_TYPE_OGG || mpctx->demuxer->type == DEMUXER_TYPE_MATROSKA) &&
+      (mpctx->d_sub->sh != NULL) && (((sh_sub_t *)mpctx->d_sub->sh)->type == 'k')) {
+    sh_sub_t *sh_sub = (sh_sub_t *)mpctx->d_sub->sh;
+    current_module = "spudec_init_kate";
+    vo_spudec = spudec_new_scaled(sh_sub->palette, sh_sub->width, sh_sub->height);
+    forced_subs_only = sh_sub->forced_subs_only;
+  }
+
   if (vo_spudec==NULL) {
     sh_sub_t *sh = (sh_sub_t *)mpctx->d_sub->sh;
     unsigned int *palette = NULL;
@@ -3475,6 +3484,9 @@
         case 7: dump_microdvd(subdata, mpctx->sh_video->fps); break;
         case 8: dump_jacosub(subdata, mpctx->sh_video->fps); break;
         case 9: dump_sami(subdata, mpctx->sh_video->fps); break;
+#ifdef HAVE_OGGKATE
+        case 10: dump_oggkate(subdata, mpctx->sh_video->fps); break;
+#endif
     }
 }
 
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/spudec.c mplayer-svn-with-kate/spudec.c
--- mplayer-svn/spudec.c	2008-03-14 13:27:00.000000000 +0000
+++ mplayer-svn-with-kate/spudec.c	2008-07-05 23:36:00.000000000 +0100
@@ -79,8 +79,8 @@
   unsigned char *image;		/* Grayscale value */
   unsigned char *aimage;	/* Alpha value */
   unsigned int scaled_frame_width, scaled_frame_height;
-  unsigned int scaled_start_col, scaled_start_row;
-  unsigned int scaled_width, scaled_height, scaled_stride;
+  //unsigned int scaled_start_col, scaled_start_row;
+  //unsigned int scaled_width, scaled_height, scaled_stride;
   size_t scaled_image_size;
   unsigned char *scaled_image;
   unsigned char *scaled_aimage;
@@ -711,33 +711,33 @@
 }
 
 /* bilinear scale, similar to vobsub's code */
-static void scale_image(int x, int y, scale_pixel* table_x, scale_pixel* table_y, spudec_handle_t * spu)
+static void scale_image(int x, int y, scale_pixel* table_x, scale_pixel* table_y, const unsigned char *image, const unsigned char *aimage, unsigned int width, unsigned int height, unsigned int stride, unsigned int scaled_stride, unsigned char *scaled_image, unsigned char *scaled_aimage)
 {
   int alpha[4];
   int color[4];
   unsigned int scale[4];
-  int base = table_y[y].position * spu->stride + table_x[x].position;
-  int scaled = y * spu->scaled_stride + x;
-  alpha[0] = canon_alpha(spu->aimage[base]);
-  alpha[1] = canon_alpha(spu->aimage[base + 1]);
-  alpha[2] = canon_alpha(spu->aimage[base + spu->stride]);
-  alpha[3] = canon_alpha(spu->aimage[base + spu->stride + 1]);
-  color[0] = spu->image[base];
-  color[1] = spu->image[base + 1];
-  color[2] = spu->image[base + spu->stride];
-  color[3] = spu->image[base + spu->stride + 1];
+  int base = table_y[y].position * stride + table_x[x].position;
+  int scaled = y * scaled_stride + x;
+  alpha[0] = canon_alpha(aimage[base]);
+  alpha[1] = canon_alpha(aimage[base + 1]);
+  alpha[2] = canon_alpha(aimage[base + stride]);
+  alpha[3] = canon_alpha(aimage[base + stride + 1]);
+  color[0] = image[base];
+  color[1] = image[base + 1];
+  color[2] = image[base + stride];
+  color[3] = image[base + stride + 1];
   scale[0] = (table_x[x].left_up * table_y[y].left_up >> 16) * alpha[0];
   if (table_y[y].left_up == 0x10000) // necessary to avoid overflow-case
     scale[0] = table_x[x].left_up * alpha[0];
   scale[1] = (table_x[x].right_down * table_y[y].left_up >>16) * alpha[1];
   scale[2] = (table_x[x].left_up * table_y[y].right_down >> 16) * alpha[2];
   scale[3] = (table_x[x].right_down * table_y[y].right_down >> 16) * alpha[3];
-  spu->scaled_image[scaled] = (color[0] * scale[0] + color[1] * scale[1] + color[2] * scale[2] + color[3] * scale[3])>>24;
-  spu->scaled_aimage[scaled] = (scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
-  if (spu->scaled_aimage[scaled]){
-    spu->scaled_aimage[scaled] = 256 - spu->scaled_aimage[scaled];
-    if(spu->scaled_aimage[scaled] + spu->scaled_image[scaled] > 255)
-      spu->scaled_image[scaled] = 256 - spu->scaled_aimage[scaled];
+  scaled_image[scaled] = (color[0] * scale[0] + color[1] * scale[1] + color[2] * scale[2] + color[3] * scale[3])>>24;
+  scaled_aimage[scaled] = (scale[0] + scale[1] + scale[2] + scale[3]) >> 16;
+  if (scaled_aimage[scaled]){
+    scaled_aimage[scaled] = 256 - scaled_aimage[scaled];
+    if(scaled_aimage[scaled] + scaled_image[scaled] > 255)
+      scaled_image[scaled] = 256 - scaled_aimage[scaled];
   }
 }
 
@@ -767,124 +767,131 @@
 	sws_freeContext(ctx);
 }
 
-void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+int spudec_draw_scaled_image(unsigned int dxs, unsigned int dys,
+                             /*const*/ unsigned char *image, /*const*/ unsigned char *aimage,
+                             unsigned int start_col, unsigned int start_row, unsigned int width, unsigned int height, unsigned int stride,
+                             unsigned int orig_frame_width, unsigned int orig_frame_height,
+                             unsigned int *scaled_frame_width, unsigned int *scaled_frame_height,
+                             unsigned char **scaled_image, unsigned char **scaled_aimage, size_t *scaled_image_size,
+                             void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
 {
-  spudec_handle_t *spu = (spudec_handle_t *)me;
   scale_pixel *table_x;
   scale_pixel *table_y;
+  int drawn = 0;
 
-  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
-
-    // check if only forced subtitles are requested 
-    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){ 
-	return;
-    }
-
-    if (!(spu_aamode&16) && (spu->orig_frame_width == 0 || spu->orig_frame_height == 0
-	|| (spu->orig_frame_width == dxs && spu->orig_frame_height == dys))) {
-      if (spu->image)
+/* Valid values for spu_aamode:
+   0: none (fastest, most ugly)
+   1: approximate
+   2: full (slowest)
+   3: bilinear (similiar to vobsub, fast and not too bad)
+   4: uses swscaler gaussian (this is the only one that looks good)
+ */
+  spu_aamode=2;
+
+    if (!(spu_aamode&16) && (orig_frame_width == 0 || orig_frame_height == 0
+	|| (orig_frame_width == dxs && orig_frame_height == dys))) {
+      if (image)
       {
-	draw_alpha(spu->start_col, spu->start_row, spu->width, spu->height,
-		   spu->image, spu->aimage, spu->stride);
-	spu->spu_changed = 0;
+	draw_alpha(start_col, start_row, width, height, image, aimage, stride);
+        drawn = 1;
       }
     }
     else {
-      if (spu->scaled_frame_width != dxs || spu->scaled_frame_height != dys) {	/* Resizing is needed */
+	unsigned int scalex = 0x100 * dxs / orig_frame_width;
+	unsigned int scaley = 0x100 * dys / orig_frame_height;
+	unsigned int scaled_width = width * scalex / 0x100;
+	unsigned int scaled_height = height * scaley / 0x100;
+	unsigned int scaled_stride = (scaled_width + 7) & ~7;
+	unsigned int scaled_start_col = start_col * scalex / 0x100;
+	unsigned int scaled_start_row = start_row * scaley / 0x100;
+      if (*scaled_frame_width != dxs || *scaled_frame_height != dys) {	/* Resizing is needed */
 	/* scaled_x = scalex * x / 0x100
 	   scaled_y = scaley * y / 0x100
 	   order of operations is important because of rounding. */
-	unsigned int scalex = 0x100 * dxs / spu->orig_frame_width;
-	unsigned int scaley = 0x100 * dys / spu->orig_frame_height;
-	spu->scaled_start_col = spu->start_col * scalex / 0x100;
-	spu->scaled_start_row = spu->start_row * scaley / 0x100;
-	spu->scaled_width = spu->width * scalex / 0x100;
-	spu->scaled_height = spu->height * scaley / 0x100;
 	/* Kludge: draw_alpha needs width multiple of 8 */
-	spu->scaled_stride = (spu->scaled_width + 7) & ~7;
-	if (spu->scaled_image_size < spu->scaled_stride * spu->scaled_height) {
-	  if (spu->scaled_image) {
-	    free(spu->scaled_image);
-	    spu->scaled_image_size = 0;
+	if (*scaled_image_size < scaled_stride * scaled_height) {
+	  if (*scaled_image) {
+	    free(*scaled_image);
+	    *scaled_image_size = 0;
 	  }
-	  spu->scaled_image = malloc(2 * spu->scaled_stride * spu->scaled_height);
-	  if (spu->scaled_image) {
-	    spu->scaled_image_size = spu->scaled_stride * spu->scaled_height;
-	    spu->scaled_aimage = spu->scaled_image + spu->scaled_image_size;
+	  *scaled_image = malloc(2 * scaled_stride * scaled_height);
+	  if (*scaled_image) {
+	    *scaled_image_size = scaled_stride * scaled_height;
+	    *scaled_aimage = *scaled_image + *scaled_image_size;
 	  }
 	}
-	if (spu->scaled_image) {
+	if (*scaled_image) {
 	  unsigned int x, y;
-	  if (spu->scaled_width <= 1 || spu->scaled_height <= 1) {
+	  if (scaled_width <= 1 || scaled_height <= 1) {
 	    goto nothing_to_do;
 	  }
 	  switch(spu_aamode&15) {
 	  case 4:
-	  sws_spu_image(spu->scaled_image, spu->scaled_aimage,
-		  spu->scaled_width, spu->scaled_height, spu->scaled_stride,
-		  spu->image, spu->aimage, spu->width, spu->height, spu->stride);
+	  sws_spu_image(*scaled_image, *scaled_aimage,
+		  scaled_width, scaled_height, scaled_stride,
+		  image, aimage, width, height, stride);
 	  break;
 	  case 3:
-	  table_x = calloc(spu->scaled_width, sizeof(scale_pixel));
-	  table_y = calloc(spu->scaled_height, sizeof(scale_pixel));
+	  table_x = calloc(scaled_width, sizeof(scale_pixel));
+	  table_y = calloc(scaled_height, sizeof(scale_pixel));
 	  if (!table_x || !table_y) {
 	    mp_msg(MSGT_SPUDEC, MSGL_FATAL, "Fatal: spudec_draw_scaled: calloc failed\n");
 	  }
-	  scale_table(0, 0, spu->width - 1, spu->scaled_width - 1, table_x);
-	  scale_table(0, 0, spu->height - 1, spu->scaled_height - 1, table_y);
-	  for (y = 0; y < spu->scaled_height; y++)
-	    for (x = 0; x < spu->scaled_width; x++)
-	      scale_image(x, y, table_x, table_y, spu);
+	  scale_table(0, 0, width - 1, scaled_width - 1, table_x);
+	  scale_table(0, 0, height - 1, scaled_height - 1, table_y);
+	  for (y = 0; y < scaled_height; y++)
+	    for (x = 0; x < scaled_width; x++)
+	      scale_image(x, y, table_x, table_y, image, aimage, width, height, stride, scaled_stride, *scaled_image, *scaled_aimage);
 	  free(table_x);
 	  free(table_y);
 	  break;
 	  case 0:
 	  /* no antialiasing */
-	  for (y = 0; y < spu->scaled_height; ++y) {
+	  for (y = 0; y < scaled_height; ++y) {
 	    int unscaled_y = y * 0x100 / scaley;
-	    int strides = spu->stride * unscaled_y;
-	    int scaled_strides = spu->scaled_stride * y;
-	    for (x = 0; x < spu->scaled_width; ++x) {
+	    int strides = stride * unscaled_y;
+	    int scaled_strides = scaled_stride * y;
+	    for (x = 0; x < scaled_width; ++x) {
 	      int unscaled_x = x * 0x100 / scalex;
-	      spu->scaled_image[scaled_strides + x] = spu->image[strides + unscaled_x];
-	      spu->scaled_aimage[scaled_strides + x] = spu->aimage[strides + unscaled_x];
+	      (*scaled_image)[scaled_strides + x] = image[strides + unscaled_x];
+	      (*scaled_aimage)[scaled_strides + x] = aimage[strides + unscaled_x];
 	    }
 	  }
 	  break;
 	  case 1:
 	  {
 	    /* Intermediate antialiasing. */
-	    for (y = 0; y < spu->scaled_height; ++y) {
-	      const unsigned int unscaled_top = y * spu->orig_frame_height / dys;
-	      unsigned int unscaled_bottom = (y + 1) * spu->orig_frame_height / dys;
-	      if (unscaled_bottom >= spu->height)
-		unscaled_bottom = spu->height - 1;
-	      for (x = 0; x < spu->scaled_width; ++x) {
-		const unsigned int unscaled_left = x * spu->orig_frame_width / dxs;
-		unsigned int unscaled_right = (x + 1) * spu->orig_frame_width / dxs;
+	    for (y = 0; y < scaled_height; ++y) {
+	      const unsigned int unscaled_top = y * orig_frame_height / dys;
+	      unsigned int unscaled_bottom = (y + 1) * orig_frame_height / dys;
+	      if (unscaled_bottom >= height)
+		unscaled_bottom = height - 1;
+	      for (x = 0; x < scaled_width; ++x) {
+		const unsigned int unscaled_left = x * orig_frame_width / dxs;
+		unsigned int unscaled_right = (x + 1) * orig_frame_width / dxs;
 		unsigned int color = 0;
 		unsigned int alpha = 0;
 		unsigned int walkx, walky;
 		unsigned int base, tmp;
-		if (unscaled_right >= spu->width)
-		  unscaled_right = spu->width - 1;
+		if (unscaled_right >= width)
+		  unscaled_right = width - 1;
 		for (walky = unscaled_top; walky <= unscaled_bottom; ++walky)
 		  for (walkx = unscaled_left; walkx <= unscaled_right; ++walkx) {
-		    base = walky * spu->stride + walkx;
-		    tmp = canon_alpha(spu->aimage[base]);
+		    base = walky * stride + walkx;
+		    tmp = canon_alpha(aimage[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * image[base];
 		  }
-		base = y * spu->scaled_stride + x;
-		spu->scaled_image[base] = alpha ? color / alpha : 0;
-		spu->scaled_aimage[base] =
+		base = y * scaled_stride + x;
+		(*scaled_image)[base] = alpha ? color / alpha : 0;
+		(*scaled_aimage)[base] =
 		  alpha * (1 + unscaled_bottom - unscaled_top) * (1 + unscaled_right - unscaled_left);
-		/* spu->scaled_aimage[base] =
-		  alpha * dxs * dys / spu->orig_frame_width / spu->orig_frame_height; */
-		if (spu->scaled_aimage[base]) {
-		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
-		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
-		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		/* (*scaled_aimage)[base] =
+		  alpha * dxs * dys / orig_frame_width / orig_frame_height; */
+		if ((*scaled_aimage)[base]) {
+		  (*scaled_aimage)[base] = 256 - (*scaled_aimage)[base];
+		  if ((*scaled_aimage)[base] + (*scaled_image)[base] > 255)
+		    (*scaled_image)[base] = 256 - (*scaled_aimage)[base];
 		}
 	      }
 	    }
@@ -933,7 +940,7 @@
 	       unscaled_x_right. */
 	    const double inv_scalex = (double) 0x100 / scalex;
 	    const double inv_scaley = (double) 0x100 / scaley;
-	    for (y = 0; y < spu->scaled_height; ++y) {
+	    for (y = 0; y < scaled_height; ++y) {
 	      const double unscaled_y = y * inv_scaley;
 	      const double unscaled_y_bottom = unscaled_y + inv_scaley;
 	      const unsigned int top_low_row = FFMIN(unscaled_y_bottom, unscaled_y + 1.0);
@@ -944,7 +951,7 @@
 	      const double bottom = unscaled_y_bottom > top_low_row
 		? unscaled_y_bottom - floor(unscaled_y_bottom)
 		: 0.0;
-	      for (x = 0; x < spu->scaled_width; ++x) {
+	      for (x = 0; x < scaled_width; ++x) {
 		const double unscaled_x = x * inv_scalex;
 		const double unscaled_x_right = unscaled_x + inv_scalex;
 		const unsigned int left_right_column = FFMIN(unscaled_x_right, unscaled_x + 1.0);
@@ -967,35 +974,35 @@
 		  transformed color = sum(surface * alpha * color) / sum(surface * alpha)
 		*/
 		/* 1: top left part */
-		base = spu->stride * (unsigned int) unscaled_y;
-		tmp = left * top * canon_alpha(spu->aimage[base + (unsigned int) unscaled_x]);
+		base = stride * (unsigned int) unscaled_y;
+		tmp = left * top * canon_alpha(aimage[base + (unsigned int) unscaled_x]);
 		alpha += tmp;
-		color += tmp * spu->image[base + (unsigned int) unscaled_x];
+		color += tmp * image[base + (unsigned int) unscaled_x];
 		/* 2: top center part */
 		if (width > 0) {
 		  unsigned int walkx;
 		  for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		    base = spu->stride * (unsigned int) unscaled_y + walkx;
-		    tmp = /* 1.0 * */ top * canon_alpha(spu->aimage[base]);
+		    base = stride * (unsigned int) unscaled_y + walkx;
+		    tmp = /* 1.0 * */ top * canon_alpha(aimage[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * image[base];
 		  }
 		}
 		/* 3: top right part */
 		if (right > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y + (unsigned int) unscaled_x_right;
-		  tmp = right * top * canon_alpha(spu->aimage[base]);
+		  base = stride * (unsigned int) unscaled_y + (unsigned int) unscaled_x_right;
+		  tmp = right * top * canon_alpha(aimage[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * image[base];
 		}
 		/* 4: center left part */
 		if (height > 0) {
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
-		    base = spu->stride * walky + (unsigned int) unscaled_x;
-		    tmp = left /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    base = stride * walky + (unsigned int) unscaled_x;
+		    tmp = left /* * 1.0 */ * canon_alpha(aimage[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * image[base];
 		  }
 		}
 		/* 5: center part */
@@ -1003,11 +1010,11 @@
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
 		    unsigned int walkx;
-		    base = spu->stride * walky;
+		    base = stride * walky;
 		    for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		      tmp = /* 1.0 * 1.0 * */ canon_alpha(spu->aimage[base + walkx]);
+		      tmp = /* 1.0 * 1.0 * */ canon_alpha(aimage[base + walkx]);
 		      alpha += tmp;
-		      color += tmp * spu->image[base + walkx];
+		      color += tmp * image[base + walkx];
 		    }
 		  }		    
 		}
@@ -1015,44 +1022,44 @@
 		if (right > 0.0 && height > 0) {
 		  unsigned int walky;
 		  for (walky = top_low_row; walky < (unsigned int) unscaled_y_bottom; ++walky) {
-		    base = spu->stride * walky + (unsigned int) unscaled_x_right;
-		    tmp = right /* * 1.0 */ * canon_alpha(spu->aimage[base]);
+		    base = stride * walky + (unsigned int) unscaled_x_right;
+		    tmp = right /* * 1.0 */ * canon_alpha(aimage[base]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base];
+		    color += tmp * image[base];
 		  }
 		}
 		/* 7: bottom left part */
 		if (bottom > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x;
-		  tmp = left * bottom * canon_alpha(spu->aimage[base]);
+		  base = stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x;
+		  tmp = left * bottom * canon_alpha(aimage[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * image[base];
 		}
 		/* 8: bottom center part */
 		if (width > 0 && bottom > 0.0) {
 		  unsigned int walkx;
-		  base = spu->stride * (unsigned int) unscaled_y_bottom;
+		  base = stride * (unsigned int) unscaled_y_bottom;
 		  for (walkx = left_right_column; walkx < (unsigned int) unscaled_x_right; ++walkx) {
-		    tmp = /* 1.0 * */ bottom * canon_alpha(spu->aimage[base + walkx]);
+		    tmp = /* 1.0 * */ bottom * canon_alpha(aimage[base + walkx]);
 		    alpha += tmp;
-		    color += tmp * spu->image[base + walkx];
+		    color += tmp * image[base + walkx];
 		  }
 		}
 		/* 9: bottom right part */
 		if (right > 0.0 && bottom > 0.0) {
-		  base = spu->stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x_right;
-		  tmp = right * bottom * canon_alpha(spu->aimage[base]);
+		  base = stride * (unsigned int) unscaled_y_bottom + (unsigned int) unscaled_x_right;
+		  tmp = right * bottom * canon_alpha(aimage[base]);
 		  alpha += tmp;
-		  color += tmp * spu->image[base];
+		  color += tmp * image[base];
 		}
 		/* Finally mix these transparency and brightness information suitably */
-		base = spu->scaled_stride * y + x;
-		spu->scaled_image[base] = alpha > 0 ? color / alpha : 0;
-		spu->scaled_aimage[base] = alpha * scalex * scaley / 0x10000;
-		if (spu->scaled_aimage[base]) {
-		  spu->scaled_aimage[base] = 256 - spu->scaled_aimage[base];
-		  if (spu->scaled_aimage[base] + spu->scaled_image[base] > 255)
-		    spu->scaled_image[base] = 256 - spu->scaled_aimage[base];
+		base = scaled_stride * y + x;
+		(*scaled_image)[base] = alpha > 0 ? color / alpha : 0;
+		(*scaled_aimage)[base] = alpha * scalex * scaley / 0x10000;
+		if ((*scaled_aimage)[base]) {
+		  (*scaled_aimage)[base] = 256 - (*scaled_aimage)[base];
+		  if ((*scaled_aimage)[base] + (*scaled_image)[base] > 255)
+		    (*scaled_image)[base] = 256 - (*scaled_aimage)[base];
 		}
 	      }
 	    }
@@ -1060,36 +1067,63 @@
 	  }
 nothing_to_do:
 	  /* Kludge: draw_alpha needs width multiple of 8. */
-	  if (spu->scaled_width < spu->scaled_stride)
-	    for (y = 0; y < spu->scaled_height; ++y) {
-	      memset(spu->scaled_aimage + y * spu->scaled_stride + spu->scaled_width, 0,
-		     spu->scaled_stride - spu->scaled_width);
+	  if (scaled_width < scaled_stride)
+	    for (y = 0; y < scaled_height; ++y) {
+	      memset((*scaled_aimage) + y * scaled_stride + scaled_width, 0,
+		     scaled_stride - scaled_width);
 	    }
-	  spu->scaled_frame_width = dxs;
-	  spu->scaled_frame_height = dys;
+	  *scaled_frame_width = dxs;
+	  *scaled_frame_height = dys;
 	}
+	//spu->scaled_width = scaled_width;
+	//spu->scaled_height = scaled_height;
+        //spu->scaled_stride = scaled_stride;
       }
-      if (spu->scaled_image){
+      if (*scaled_image){
         switch (spu_alignment) {
         case 0:
-          spu->scaled_start_row = dys*sub_pos/100;
-	  if (spu->scaled_start_row + spu->scaled_height > dys)
-	    spu->scaled_start_row = dys - spu->scaled_height;
+          scaled_start_row = dys*sub_pos/100;
+	  if (scaled_start_row + scaled_height > dys)
+	    scaled_start_row = dys - scaled_height;
 	  break;
 	case 1:
-          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height/2;
-	  if (sub_pos >= 50 && spu->scaled_start_row + spu->scaled_height > dys)
-	      spu->scaled_start_row = dys - spu->scaled_height;
+          scaled_start_row = dys*sub_pos/100 - scaled_height/2;
+	  if (sub_pos >= 50 && scaled_start_row + scaled_height > dys)
+	      scaled_start_row = dys - scaled_height;
 	  break;
         case 2:
-          spu->scaled_start_row = dys*sub_pos/100 - spu->scaled_height;
+          scaled_start_row = dys*sub_pos/100 - scaled_height;
 	  break;
 	}
-	draw_alpha(spu->scaled_start_col, spu->scaled_start_row, spu->scaled_width, spu->scaled_height,
-		   spu->scaled_image, spu->scaled_aimage, spu->scaled_stride);
-	spu->spu_changed = 0;
+	draw_alpha(scaled_start_col, scaled_start_row, scaled_width, scaled_height,
+		   *scaled_image, *scaled_aimage, scaled_stride);
+        drawn = 1;
       }
     }
+    return drawn;
+}
+
+void spudec_draw_scaled(void *me, unsigned int dxs, unsigned int dys, void (*draw_alpha)(int x0,int y0, int w,int h, unsigned char* src, unsigned char *srca, int stride))
+{
+  spudec_handle_t *spu = (spudec_handle_t *)me;
+  int drawn;
+
+  if (spu->start_pts <= spu->now_pts && spu->now_pts < spu->end_pts) {
+
+    // check if only forced subtitles are requested 
+    if( (spu->forced_subs_only) && !(spu->is_forced_sub) ){ 
+	return;
+    }
+
+    drawn = spudec_draw_scaled_image(dxs, dys,
+                                     spu->image, spu->aimage,
+                                     spu->start_col, spu->start_row, spu->width, spu->height, spu->stride,
+                                     spu->orig_frame_width, spu->orig_frame_height,
+                                     &spu->scaled_frame_width, &spu->scaled_frame_height,
+                                     &spu->scaled_image, &spu->scaled_aimage, &spu->scaled_image_size,
+                                     draw_alpha);
+    if (drawn)
+      spu->spu_changed = 0;
   }
   else
   {
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/subreader.c mplayer-svn-with-kate/subreader.c
--- mplayer-svn/subreader.c	2008-03-14 13:27:01.000000000 +0000
+++ mplayer-svn-with-kate/subreader.c	2008-10-09 08:49:31.000000000 +0100
@@ -24,6 +24,12 @@
 #include <enca.h>
 #endif
 
+#ifdef HAVE_OGGKATE
+#include <ogg/ogg.h>
+#include <kate/kate.h>
+#include <kate/oggkate.h>
+#endif
+
 #define ERR ((void *) -1)
 
 #ifdef USE_ICONV
@@ -236,13 +242,13 @@
 }
 
 
-static char *sub_readtext(char *source, char **dest) {
+static const char *sub_readtext2(const char *source, char **dest, int pipe_is_eol) {
     int len=0;
-    char *p=source;
+    const char *p=source;
     
 //    printf("src=%p  dest=%p  \n",source,dest);
 
-    while ( !eol(*p) && *p!= '|' ) {
+    while ( !eol(*p) && (!pipe_is_eol || *p!= '|') ) {
 	p++,len++;
     }
     
@@ -252,16 +258,20 @@
     strncpy(*dest, source, len);
     (*dest)[len]=0;
     
-    while (*p=='\r' || *p=='\n' || *p=='|') p++;
+    while (*p=='\r' || *p=='\n' || (*p=='|' && pipe_is_eol)) p++;
     
     if (*p) return p;  // not-last text field
     else return NULL;  // last text field
 }
 
+static const char *sub_readtext(const char *source, char **dest) {
+  return sub_readtext2(source, dest, 1);
+}
+
 static subtitle *sub_read_line_microdvd(stream_t *st,subtitle *current) {
     char line[LINE_LEN+1];
     char line2[LINE_LEN+1];
-    char *p, *next;
+    const char *p, *next;
     int i;
 
     do {
@@ -289,7 +299,7 @@
 static subtitle *sub_read_line_mpl2(stream_t *st,subtitle *current) {
     char line[LINE_LEN+1];
     char line2[LINE_LEN+1];
-    char *p, *next;
+    const char *p, *next;
     int i;
 
     do {
@@ -312,6 +322,118 @@
     return current;
 }
 
+static subtitle *sub_read_line_oggkate(stream_t *st,subtitle *current) {
+    int ret;
+    char *buffer;
+    size_t bytes;
+    const char *next;
+    int i;
+
+    enum { uninitialized, header_info, data };
+
+    static int ogg_init=0;
+    static int init=uninitialized;
+    static ogg_sync_state sync;
+    static ogg_stream_state os;
+    static ogg_page og;
+    static ogg_packet op;
+    static kate_state k;
+    static kate_info ki;
+    static kate_comment kc;
+
+    if (!ogg_init) {
+      ogg_init=1;
+      ogg_sync_init(&sync);
+    }
+
+    while (1) {
+      /* first, get a packet if we can */
+      ret=ogg_stream_packetout(&os,&op);
+      if (ret>0) {
+        /* we have a packet */
+        if (init<data) {
+          ret=kate_ogg_decode_headerin(&ki,&kc,&op);
+          if (ret>=0) {
+            if (ret>0) {
+              kate_info_remove_markup(&ki,1);
+              kate_decode_init(&k,&ki);
+              init=data;
+            }
+          }
+          else {
+            if (init!=uninitialized) {
+              kate_info_clear(&ki);
+              kate_comment_clear(&kc);
+            }
+            init=uninitialized;
+          }
+        }
+        else {
+          ret=kate_ogg_decode_packetin(&k,&op);
+          if (ret==0) {
+            const kate_event *ev=NULL;
+            ret=kate_decode_eventout(&k,&ev);
+            if (!ret) {
+              current->start=(int64_t)(ev->start_time)*100;
+              current->end=(int64_t)(ev->start_time+ev->duration)*100;
+#if 0
+              char *line=malloc(ev->len0);
+              memcpy(line,ev->text,ev->len0);
+              current->text[0]=line;
+              current->lines=1;
+#else
+    next=ev->text, i=0;
+    while ((next =sub_readtext2 (next, &(current->text[i]), 0))) {
+        if (current->text[i]==ERR) {return ERR;}
+	i++;
+	if (i>=SUB_MAX_TEXT) { mp_msg(MSGT_SUBREADER,MSGL_WARN,"Too many lines in a subtitle\n");current->lines=i;return current;}
+    }
+    current->lines= ++i;
+#endif
+              break;
+            }
+          }
+        }
+        continue;
+      }
+      /* no packets to be had, read more */
+      ret=ogg_sync_pageout(&sync,&og);
+      if (ret>0) {
+        if (ogg_page_bos(&og)) {
+          if (init==uninitialized) {
+            ogg_stream_init(&os,ogg_page_serialno(&og));
+            kate_info_init(&ki);
+            kate_comment_init(&kc);
+            init=header_info;
+          }
+        }
+        ret=ogg_stream_pagein(&os,&og);
+        if (ret<0) {
+          continue;
+        }
+        continue;
+      }
+      else if (ret<0) {
+        continue;
+      }
+      /* read more data */
+      buffer=ogg_sync_buffer(&sync,4096);
+      if (!buffer) break;
+      bytes=stream_read(st,buffer,4096);
+      if (bytes==0) {
+        ogg_stream_clear(&os);
+        ogg_sync_clear(&sync);
+        ogg_init=0;
+        /* end of file */
+        return NULL;
+      }
+      ogg_sync_wrote(&sync,bytes);
+      continue;
+    }
+
+    return current;
+}
+
 static subtitle *sub_read_line_subrip(stream_t* st, subtitle *current) {
     char line[LINE_LEN+1];
     int a1,a2,a3,a4,b1,b2,b3,b4;
@@ -430,7 +552,8 @@
 static subtitle *sub_read_line_vplayer(stream_t *st,subtitle *current) {
 	char line[LINE_LEN+1];
 	int a1,a2,a3;
-	char *p=NULL, *next,separator;
+	const char *p=NULL, *next;
+        char separator;
 	int i,len,plen;
 
 	while (!current->text[0]) {
@@ -479,7 +602,7 @@
 	// WARNING: full XML parses can be required for proper parsing 
     char line[LINE_LEN+1];
     int a1,a2,a3,a4,b1,b2,b3,b4;
-    char *p=NULL,*next=NULL;
+    const char *p=NULL,*next=NULL;
     int i,len,plen;
     
     while (!current->text[0]) {
@@ -709,7 +832,7 @@
 
 static subtitle *sub_read_line_aqt(stream_t *st,subtitle *current) {
     char line[LINE_LEN+1];
-    char *next;
+    const char *next;
     int i;
 
     while (1) {
@@ -767,7 +890,7 @@
 static subtitle *sub_read_line_subrip09(stream_t *st,subtitle *current) {
     char line[LINE_LEN+1];
     int a1,a2,a3;
-    char * next=NULL;
+    const char * next=NULL;
     int i,len;
    
     while (1) {
@@ -1060,6 +1183,20 @@
 		{*uses_time=0; return SUB_AQTITLE;}
 	if (sscanf (line, "[%d:%d:%d]", &i, &i, &i)==3)
 		{*uses_time=1;return SUB_SUBRIP09;}
+        /* We test for the OggS capture pattern, as the Kate track might be
+           well away from the start of the stream (eg, if it is multiplexed
+           with video and/or skeleton) so other bits above (like that bloody
+           RT hair trigger) would go off wrongly. Ideally, the second bit of
+           code below would be better, since that's the Kate signature, but
+           it might find itself on a subsequent 'line' so would not have a
+           chance to run before some of the other checks above would trigger. */
+#if 1
+	if (!memcmp(line, "OggS", 4))
+		{*uses_time=1;return SUB_KATE;}
+#else
+        if ((ptr=strstr(line,"\200kate")) && !memcmp(ptr,"\200kate\0\0\0",8))
+		{*uses_time=1;return SUB_KATE;}
+#endif
     }
 
     return SUB_INVALID;  // too many bad lines
@@ -1351,7 +1488,8 @@
 	    { sub_read_line_subviewer2, NULL, "subviewer 2.0" },
 	    { sub_read_line_subrip09, NULL, "subrip 0.9" },
 	    { sub_read_line_jacosub, NULL, "jacosub" },
-	    { sub_read_line_mpl2, NULL, "mpl2" }
+	    { sub_read_line_mpl2, NULL, "mpl2" },
+	    { sub_read_line_oggkate, NULL, "Kate" }
     };
     struct subreader *srp;
     
@@ -1381,6 +1519,11 @@
 			    break;
 			}
 	    }
+
+            /* Kate is always utf-8 */
+            if (sub_format == SUB_KATE)
+                sub_utf8 = 1;
+
 	    if (k<0) subcp_open(fd);
     }
 #endif
@@ -1488,9 +1631,13 @@
     }
 
     // we do overlap if the user forced it (suboverlap_enable == 2) or
-    // the user didn't forced no-overlapsub and the format is Jacosub or Ssa.
+    // the user didn't forced no-overlapsub and the format is Jacosub, Ssa, or Kate.
     // this is because usually overlapping subtitles are found in these formats,
     // while in others they are probably result of bad timing
+
+    /* TODO: Kate also supports overlapping subtitles, but enabling this code makes ALL
+       subtitles overlap even when the timings do not overlap, and I don't understand
+       what this code does, so I'll leave it as is for now */
 if ((suboverlap_enabled == 2) ||
     ((suboverlap_enabled) && ((sub_format == SUB_JACOSUB) || (sub_format == SUB_SSA)))) {
     adjust_subs_time(first, 6.0, fps, 0, sub_num, uses_time);/*~6 secs AST*/
@@ -2003,6 +2150,129 @@
     mp_msg(MSGT_SUBREADER,MSGL_INFO,"Read %i subtitles, %i errors.\n", subd->sub_num, subd->sub_errs);
 }
 
+#ifdef HAVE_OGGKATE
+
+static void flush_page(FILE *f,ogg_stream_state *os)
+{
+  ogg_page og;
+  while (1) {
+    int ret=ogg_stream_flush(os,&og);
+    if (ret==0) break;
+    fwrite(og.header,1,og.header_len,f);
+    fwrite(og.body,1,og.body_len,f);
+  }
+}
+
+static void write_kate_headers(FILE *f,kate_state *k,ogg_stream_state *os,ogg_packet *op)
+{
+  kate_comment kc;
+  kate_comment_init(&kc);
+  while (1) {
+    int ret=kate_ogg_encode_headers(k,&kc,op);
+    if (ret>0) {
+      break;
+    }
+    else if (ret<0) {
+      /* error */
+      perror("write_kate_headers: kate_encode_error");
+      break;
+    }
+    else if (ret==0) {
+      ogg_stream_packetin(os,op);
+    }
+  }
+  flush_page(f,os);
+  kate_comment_clear(&kc);
+}
+
+static void add_to_text(char **text,int *text_size,const char *new_text)
+{
+  size_t current_len=*text?strlen(*text):0;
+  size_t new_text_len=strlen(new_text);
+  size_t needed=current_len+new_text_len+2;
+  if (needed>*text_size) {
+    size_t new_size=needed+256;
+    *text=(char*)realloc(*text,new_size);
+    if (current_len==0) **text=0;
+    *text_size=new_size;
+  }
+  if (*text) strcat(*text,new_text);
+}
+
+void dump_oggkate(sub_data* subd, float fps){
+    int i,j;
+    FILE * fd;
+    subtitle * onesub;
+    unsigned long temp;
+    subtitle *subs = subd->subtitles;
+    char *text=NULL;
+    size_t allocated=0;
+
+    kate_state k;
+    kate_info ki;
+    ogg_packet op;
+    ogg_stream_state os;
+    double t0,t1;
+
+    if (!subd->sub_uses_time && sub_fps == 0)
+	sub_fps = fps;
+    fd=fopen("dumpsub.ogg","w");
+    if(!fd)
+    { 
+	perror("dump_oggkate: fopen");
+	return;
+    }
+
+    kate_info_init(&ki);
+    ki.gps_numerator = 1000;
+    ki.gps_denominator = 1;
+    ki.granule_shift = 32;
+    kate_encode_init(&k,&ki);
+    ogg_stream_init(&os,rand());
+
+    write_kate_headers(fd,&k,&os,&op);
+
+    for(i=0; i < subd->sub_num; i++)
+    {
+        onesub=subs+i;    //=&subs[i];
+
+	temp=onesub->start;
+	if (!subd->sub_uses_time)
+	    temp = temp * 100 / sub_fps;
+	temp -= sub_delay * 100;
+        t0=temp/100.0;
+
+	temp=onesub->end;
+	if (!subd->sub_uses_time)
+	    temp = temp * 100 / sub_fps;
+	temp -= sub_delay * 100;
+        t1=temp/100.0;
+	
+	for(j=0;j<onesub->lines;j++) {
+          if (j) add_to_text(&text,&allocated,"\n");
+          add_to_text(&text,&allocated,onesub->text[j]);
+        }
+
+        kate_ogg_encode_text(&k,t0,t1,text,strlen(text),&op);
+        ogg_stream_packetin(&os,&op);
+
+        flush_page(fd,&os);
+        if (text) *text=0;
+    }
+
+    kate_ogg_encode_finish(&k,-1,&op);
+    ogg_stream_packetin(&os,&op);
+    flush_page(fd,&os);
+    ogg_stream_clear(&os);
+    kate_clear(&k);
+
+    free(text);
+
+    fclose(fd);
+    mp_msg(MSGT_SUBREADER,MSGL_INFO,"SUB: Kate format subtitles dumped in \'dumpsub.ogg\'.\n");
+}
+#endif
+
 void dump_srt(sub_data* subd, float fps){
     int i,j;
     int h,m,s,ms;
diff -ruN -x 'config.*' -x configure.log -x '*.o' -x allformats.c -x vidix -x codecs.conf.h -x version.h -x help_mp.h mplayer-svn/subreader.h mplayer-svn-with-kate/subreader.h
--- mplayer-svn/subreader.h	2008-03-14 13:27:01.000000000 +0000
+++ mplayer-svn-with-kate/subreader.h	2008-06-14 21:03:10.000000000 +0100
@@ -23,6 +23,7 @@
 #define SUB_SUBRIP09 11
 #define SUB_JACOSUB  12
 #define SUB_MPL2     13
+#define SUB_KATE     14
 
 // One of the SUB_* constant above
 extern int sub_format;
@@ -78,6 +79,9 @@
 char ** sub_filenames(const char *path, char *fname);
 void list_sub_file(sub_data* subd);
 void dump_srt(sub_data* subd, float fps);
+#ifdef HAVE_OGGKATE
+void dump_oggkate(sub_data* subd, float fps);
+#endif
 void dump_mpsub(sub_data* subd, float fps);
 void dump_microdvd(sub_data* subd, float fps);
 void dump_jacosub(sub_data* subd, float fps);
