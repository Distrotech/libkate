diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/config.h.in mkvtoolnix-svn/config.h.in
--- ../svn/mkvtoolnix/config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ mkvtoolnix-svn/config.h.in	2008-03-17 20:23:33.000000000 +0000
@@ -0,0 +1,127 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <bzlib.h> header file. */
+#undef HAVE_BZLIB_H
+
+/* Define to 1 if you have the <expat.h> header file. */
+#undef HAVE_EXPAT_H
+
+/* Define if FLAC__stream_decoder_skip_single_frame exists */
+#undef HAVE_FLAC_DECODER_SKIP
+
+/* Define if the FLAC headers are present */
+#undef HAVE_FLAC_FORMAT_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* locale_charset is available */
+#undef HAVE_LOCALE_CHARSET
+
+/* Define this if LZO compression is present */
+#undef HAVE_LZO
+
+/* Define to 1 if you have the <lzo1x.h> header file. */
+#undef HAVE_LZO1X_H
+
+/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
+#undef HAVE_LZO_LZO1X_H
+
+/* Define to 1 if you have the <magic.h> header file. */
+#undef HAVE_MAGIC_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* nl_langinfo is available */
+#undef HAVE_NL_LANGINFO
+
+/* int64_t does not exist */
+#undef HAVE_NO_INT64_T
+
+/* uint64_t does not exist */
+#undef HAVE_NO_UINT64_T
+
+/* Define to 1 if you have the <ogg/ogg.h> header file. */
+#undef HAVE_OGG_OGG_H
+
+/* define if posix_advise and its definitions are available */
+#undef HAVE_POSIX_FADVISE
+
+/* Define if Qt is present */
+#undef HAVE_QT
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the <vorbis/codec.h> header file. */
+#undef HAVE_VORBIS_CODEC_H
+
+/* Define to 1 if you have the `vsscanf' function. */
+#undef HAVE_VSSCANF
+
+/* Define if wxWindows is present */
+#undef HAVE_WXWIDGETS
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#undef HAVE_ZLIB_H
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* the type to define int64_t manually */
+#undef INT64_TYPE
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* The size of a `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of a `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of a `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* the type to define uint64_t manually */
+#undef UINT64_TYPE
+
+/* big endian system */
+#undef WORDS_BIGENDIAN
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/doc/mkvextract.1 mkvtoolnix-svn/doc/mkvextract.1
--- ../svn/mkvtoolnix/doc/mkvextract.1	2008-03-17 18:34:56.000000000 +0000
+++ mkvtoolnix-svn/doc/mkvextract.1	2008-03-26 22:30:39.000000000 +0000
@@ -191,6 +191,9 @@
 .TP
 S_TEXT/SSA, S_TEXT/ASS
 SSA and ASS text subtitles will be written as SSA/ASS files respectively.
+.TP
+S_KATE
+Kate streams will be written within an Ogg container.
 .LP
 \fBTags\fR are converted to a XML format. This format is the same that
 \fBmkvmerge\fR supports for reading tags.
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/doc/mkvmerge.1 mkvtoolnix-svn/doc/mkvmerge.1
--- ../svn/mkvtoolnix/doc/mkvmerge.1	2008-03-17 18:34:56.000000000 +0000
+++ mkvtoolnix-svn/doc/mkvmerge.1	2008-03-26 22:28:42.000000000 +0000
@@ -486,7 +486,7 @@
 Sets the charset for the conversion to UTF-8 for UTF-8 subtitles for the given
 track ID. If not specified the charset will be derived from the current locale
 settings. Note that a charset is not needed for subtitles read from Matroska
-files as these are always stored in UTF-8.
+files or from Kate streams, as these are always stored in UTF-8.
 .br
 This option can be used multiple times for an input file applying to several
 tracks by selecting different track IDs each time.
@@ -741,9 +741,9 @@
 .SH SUBTITLES
 .LP
 There are several text subtitle formats that can be embedded into Matroska.
-At the moment \fBmkvmerge\fR supports only text subtitle formats.
-These subtitles must be recoded to UTF-8 so that they can be displayed
-correctly by a player.
+At the moment \fBmkvmerge\fR supports only text and Kate subtitle formats.
+Text subtitles must be recoded to UTF-8 so that they can be displayed
+correctly by a player. Kate subtitles are already in UTF-8 format.
 .LP
 \fBmkvmerge\fR does this conversion automatically based on the system's current
 locale. If the subtitle charset is not the same as
@@ -758,6 +758,9 @@
 .TP
 *
 Substation Alpha (SSA) / Advanced Substation Alpha scripts (ASS)
+.TP
+*
+Kate streams in Ogg
 
 
 .SH FILE LINKING
@@ -1230,7 +1233,7 @@
 .TP
 *
 OGG as the source for video, audio (Vorbis, raw PCM, MP3 and AC3 audio) and
-text streams (subtitles).
+Kate and text streams (subtitles).
 .TP
 *
 WAV as the audio source
@@ -1265,8 +1268,8 @@
 or removing packets at the beginning.
 .TP
 *
-Text subtitles can be read from SRT (SubRipper / subrip) files or
-taken from other OGM files.
+Subtitles can be read as text from SRT (SubRipper / subrip) files,
+taken from other OGM files, or from Kate streams in Ogg files.
 .TP
 *
 SSA/ASS subtitles from SSA/ASS files
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/common/kate_common.cpp mkvtoolnix-svn/src/common/kate_common.cpp
--- ../svn/mkvtoolnix/src/common/kate_common.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mkvtoolnix-svn/src/common/kate_common.cpp	2008-03-17 20:13:01.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+   mkvmerge -- utility for splicing together matroska files
+   from component media subtypes
+
+   Distributed under the GPL
+   see the file COPYING for details
+   or visit http://www.gnu.org/copyleft/gpl.html
+
+   $Id: kate_common.cpp 3134 2005-10-23 18:21:13Z mosu $
+
+   Ogg Kate helper functions
+
+   Written by Moritz Bunkus <moritz@bunkus.org>.
+*/
+
+#include "os.h"
+
+#include "bit_cursor.h"
+#include "common.h"
+#include "kate_common.h"
+
+kate_identification_header_t::kate_identification_header_t() {
+  memset(this, 0, sizeof(kate_identification_header_t));
+}
+
+static int32_t read32(bit_cursor_c &bc)
+{
+  int32_t v=0;
+  for (int n=0;n<4;++n) {
+    v|=bc.get_bits(8)<<(n*8);
+  }
+  return v;
+}
+
+void
+kate_parse_identification_header(const unsigned char *buffer,
+                                 int size,
+                                 kate_identification_header_t &header)
+  throw(error_c) {
+
+  bit_cursor_c bc(buffer, size);
+  int i;
+
+  header.headertype = bc.get_bits(8);
+  if (KATE_HEADERTYPE_IDENTIFICATION != header.headertype)
+    throw error_c(mxsprintf("Wrong header type: 0x%02x != 0x%02x",
+                            header.headertype,
+                            KATE_HEADERTYPE_IDENTIFICATION));
+
+  for (i = 0; 8 > i; ++i)
+    header.kate_string[i] = bc.get_bits(8);
+  if (memcmp(header.kate_string, "kate\0\0\0\0", 8))
+    throw error_c(mxsprintf("Wrong identifaction string: '%8s' != 'kate\\0\\0\\0\\0'",
+                            header.kate_string)); /* won't print NULs well, but hey */
+
+  header.vmaj = bc.get_bits(8);
+  header.vmin = bc.get_bits(8);
+
+  // do not test vmin, as the header is stable for minor version changes
+  static const int supported_version = 0;
+  if (header.vmaj > supported_version)
+    throw error_c(mxsprintf("Wrong Kate version: %d.%d > %d.x",
+                            header.vmaj, header.vmin, supported_version));
+
+  header.nheaders = bc.get_bits(8);
+  header.tenc = bc.get_bits(8);
+  header.tdir = bc.get_bits(8);
+  if (0 != bc.get_bits(8))
+      throw error_c("Reserved bits are not 0");
+  header.kfgshift = bc.get_bits(8);
+
+  if (0 != read32(bc))
+      throw error_c("Reserved bits are not 0");
+  if (0 != read32(bc))
+      throw error_c("Reserved bits are not 0");
+  header.gnum = read32(bc);
+  header.gden = read32(bc);
+
+  for (i = 0; 16 > i; ++i)
+    header.language[i] = bc.get_bits(8);
+  if (header.language[15])
+      throw error_c("Language is not NUL terminated");
+  for (i = 0; 16 > i; ++i)
+    header.category[i] = bc.get_bits(8);
+  if (header.category[15])
+      throw error_c("Category is not NUL terminated");
+}
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/common/kate_common.h mkvtoolnix-svn/src/common/kate_common.h
--- ../svn/mkvtoolnix/src/common/kate_common.h	1970-01-01 01:00:00.000000000 +0100
+++ mkvtoolnix-svn/src/common/kate_common.h	2008-03-17 20:13:01.000000000 +0000
@@ -0,0 +1,52 @@
+/*
+   mkvmerge -- utility for splicing together matroska files
+   from component media subtypes
+
+   Distributed under the GPL
+   see the file COPYING for details
+   or visit http://www.gnu.org/copyleft/gpl.html
+
+   $Id: kate_common.h 3134 2005-10-23 18:21:13Z mosu $
+
+   Ogg Kate helper functions
+
+   Written by Moritz Bunkus <moritz@bunkus.org>.
+*/
+
+#ifndef __KATE_COMMON_H
+#define __KATE_COMMON_H
+
+#include "os.h"
+
+#include "error.h"
+
+#define KATE_HEADERTYPE_IDENTIFICATION 0x80
+
+struct MTX_DLL_API kate_identification_header_t {
+  uint8_t headertype;
+  char kate_string[8];
+
+  uint8_t vmaj;
+  uint8_t vmin;
+
+  uint8_t nheaders;
+  uint8_t tenc;
+  uint8_t tdir;
+
+  int32_t gnum;
+  int32_t gden;
+
+  uint8_t kfgshift;
+
+  uint8_t language[16];
+  uint8_t category[16];
+
+  kate_identification_header_t();
+};
+
+void MTX_DLL_API
+kate_parse_identification_header(const unsigned char *buffer, int size,
+                                 kate_identification_header_t &header)
+  throw(error_c);
+
+#endif // __KATE_COMMON_H
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/common/matroska.h mkvtoolnix-svn/src/common/matroska.h
--- ../svn/mkvtoolnix/src/common/matroska.h	2008-03-17 18:34:56.000000000 +0000
+++ mkvtoolnix-svn/src/common/matroska.h	2008-03-17 20:13:01.000000000 +0000
@@ -70,6 +70,7 @@
 #define MKV_S_TEXTASCII  "S_TEXT/ASCII"
 #define MKV_S_VOBSUB     "S_VOBSUB"
 #define MKV_S_VOBSUBZLIB "S_VOBSUB/ZLIB"
+#define MKV_S_KATE       "S_KATE"
 
 #define MKV_B_VOBBTN     "B_VOBBTN"
 
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/extract/xtr_base.cpp mkvtoolnix-svn/src/extract/xtr_base.cpp
--- ../svn/mkvtoolnix/src/extract/xtr_base.cpp	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/extract/xtr_base.cpp	2008-03-17 20:13:01.000000000 +0000
@@ -185,6 +185,8 @@
     return new xtr_usf_c(new_codec_id, new_tid, tspec);
   else if (new_codec_id == MKV_V_COREPICTURE)
     return new xtr_cpic_c(new_codec_id, new_tid, tspec);
+  else if (new_codec_id == MKV_S_KATE)
+    return new xtr_oggkate_c(new_codec_id, new_tid, tspec);
 
   return NULL;
 }
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/extract/xtr_ogg.cpp mkvtoolnix-svn/src/extract/xtr_ogg.cpp
--- ../svn/mkvtoolnix/src/extract/xtr_ogg.cpp	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/extract/xtr_ogg.cpp	2008-03-17 20:13:01.000000000 +0000
@@ -15,6 +15,7 @@
 #include "common.h"
 #include "commonebml.h"
 #include "random.h"
+#include "kate_common.h"
 
 #include "xtr_ogg.h"
 
@@ -269,3 +270,138 @@
   }
 }
 
+// ------------------------------------------------------------------------
+
+xtr_oggkate_c::xtr_oggkate_c(const string &_codec_id,
+                                 int64_t _tid,
+                                 track_spec_t &tspec):
+  xtr_oggbase_c(_codec_id, _tid, tspec) {
+}
+
+void
+xtr_oggkate_c::create_file(xtr_base_c *_master,
+                             KaxTrackEntry &track) {
+  const unsigned char *c, **headers;
+  ogg_packet op;
+  int offset, *header_sizes;
+  KaxCodecPrivate *priv;
+  int nheaders;
+
+  priv = FINDFIRST(&track, KaxCodecPrivate);
+  if (NULL == priv)
+    mxerror("Track " LLD " with the CodecID '%s' is missing the \"codec "
+            "private\" element and cannot be extracted.\n", tid,
+            codec_id.c_str());
+
+  init_content_decoder(track);
+  memory_cptr mpriv = decode_codec_private(priv);
+
+  c = (const unsigned char *)mpriv->get();
+  if ((mpriv->get_size() == 0) || (c[0] < 1))
+    mxerror("Track " LLD " with the CodecID '%s' does not contain valid "
+            "headers.\n", tid, codec_id.c_str());
+
+  nheaders = c[0]+1;
+
+  headers = (const unsigned char**)alloca(nheaders*sizeof(const unsigned char*));
+  header_sizes = (int*)alloca(nheaders*sizeof(int));
+
+  offset = 1;
+  for (packetno = 0; packetno < nheaders-1; packetno++) {
+    int length = 0;
+
+    while ((offset < mpriv->get_size()) && ((unsigned char)255 == c[offset])) {
+      length += 255;
+      offset++;
+    }
+    if ((mpriv->get_size() - 1) <= offset)
+      mxerror("Track " LLD " with the CodecID '%s' does not contain valid "
+              "headers.\n", tid, codec_id.c_str());
+    length += c[offset];
+    offset++;
+    header_sizes[packetno] = length;
+  }
+
+  for (packetno=0; packetno<nheaders;++packetno) {
+    headers[packetno] = c+offset;
+    for (int n=0;n<packetno;++n) headers[packetno]+=header_sizes[n];
+  }
+  header_sizes[nheaders-1] = mpriv->get_size()-offset;
+  for (packetno=0;packetno<nheaders-1;++packetno) {
+    header_sizes[nheaders-1] -= header_sizes[packetno];
+  }
+
+  xtr_oggbase_c::create_file(_master, track);
+
+  kate_parse_identification_header(headers[0], header_sizes[0], kate_id_header);
+  if (kate_id_header.nheaders != nheaders)
+    mxerror("Track " LLD " with the CodecID '%s' does not contain valid "
+            "headers.\n", tid, codec_id.c_str());
+
+  for (packetno = 0; packetno < nheaders; packetno++) {
+    // Handle all the header packets: ID header, comments, etc
+    op.b_o_s = (0 == packetno ? 1 : 0);
+    op.e_o_s = 0;
+    op.packetno = packetno;
+    op.packet = (unsigned char *)safememdup(headers[packetno],
+                                            header_sizes[packetno]);
+    op.bytes = header_sizes[packetno];
+    op.granulepos = 0;
+    ogg_stream_packetin(&os, &op);
+    if (0 == packetno) /* ID header must be alone on a separate page */
+      flush_pages();
+    safefree(op.packet);
+  }
+  /* flush at last header, data must start on a new page */
+  flush_pages();
+}
+
+static int64_t read64(const unsigned char *c)
+{
+  int64_t gpos=0;
+  for (int n=0;n<sizeof(int64_t);++n) {
+    uint64_t byte=*c++;
+    gpos|=byte<<(n*8);
+  }
+  return gpos;
+}
+
+void
+xtr_oggkate_c::handle_frame(memory_cptr &frame,
+                            KaxBlockAdditions *additions,
+                            int64_t timecode,
+                            int64_t duration,
+                            int64_t bref,
+                            int64_t fref,
+                            bool keyframe,
+                            bool discardable,
+                            bool references_valid) {
+  content_decoder.reverse(frame, CONTENT_ENCODING_SCOPE_BLOCK);
+
+  ogg_packet op;
+
+  op.b_o_s = 0;
+  op.e_o_s = (frame->get_size()==1 && frame->get()[0]==0x7f);
+  op.packetno = packetno;
+  op.packet = frame->get();
+  op.bytes = frame->get_size();
+
+  /* we encode the backlink in the granulepos */
+  float f_timecode=timecode/1000000000.0;
+  int64_t g_backlink=0;
+  if (op.bytes>=1+3*sizeof(int64_t)) {
+    g_backlink=read64(op.packet+1+2*sizeof(int64_t));
+  }
+  float f_backlink = g_backlink*(float)kate_id_header.gden/kate_id_header.gnum;
+  float f_base = f_timecode-f_backlink;
+  float f_offset = f_timecode-f_base;
+  int64_t g_base=(int64_t)(f_base*kate_id_header.gnum/kate_id_header.gden);
+  int64_t g_offset=(int64_t)(f_offset*kate_id_header.gnum/kate_id_header.gden);
+  op.granulepos = (g_base<<kate_id_header.kfgshift)|g_offset;
+
+  ogg_stream_packetin(&os, &op);
+  flush_pages(); /* Kate is a data packet per page */
+
+  packetno++;
+}
+
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/extract/xtr_ogg.h mkvtoolnix-svn/src/extract/xtr_ogg.h
--- ../svn/mkvtoolnix/src/extract/xtr_ogg.h	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/extract/xtr_ogg.h	2008-03-17 20:13:01.000000000 +0000
@@ -19,6 +19,7 @@
 
 #include <ogg/ogg.h>
 
+#include "kate_common.h"
 #include "xtr_base.h"
 
 class xtr_flac_c: public xtr_base_c {
@@ -72,4 +73,22 @@
   };
 };
 
+class xtr_oggkate_c: public xtr_oggbase_c {
+public:
+  xtr_oggkate_c(const string &_codec_id, int64_t _tid, track_spec_t &tspec);
+
+  virtual void create_file(xtr_base_c *_master, KaxTrackEntry &track);
+  virtual void handle_frame(memory_cptr &frame, KaxBlockAdditions *additions,
+                            int64_t timecode, int64_t duration, int64_t bref,
+                            int64_t fref, bool keyframe, bool discardable,
+                            bool references_valid);
+
+  virtual const char *get_container_name() {
+    return "Ogg (Kate in Ogg)";
+  };
+
+private:
+  kate_identification_header_t kate_id_header;
+};
+
 #endif
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/input/r_matroska.cpp mkvtoolnix-svn/src/input/r_matroska.cpp
--- ../svn/mkvtoolnix/src/input/r_matroska.cpp	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/input/r_matroska.cpp	2008-03-17 20:13:01.000000000 +0000
@@ -80,6 +80,7 @@
 #include "p_vobbtn.h"
 #include "p_vorbis.h"
 #include "p_wavpack.h"
+#include "p_kate.h"
 
 using namespace std;
 using namespace libmatroska;
@@ -471,6 +472,14 @@
             continue;
           }
         }
+        else if (t->codec_id == MKV_S_KATE) {
+          if (t->private_data == NULL) {
+            if (verbose)
+              mxwarn(PFX "CodecID for track " LLU " is '%s', but there was no "
+                     "private data found.\n", t->tnum, t->codec_id.c_str());
+            continue;
+          }
+        }
         t->ok = 1;
         break;
 
@@ -1719,6 +1728,17 @@
                  ti.fname.c_str(), (int64_t)t->tnum);
 
           t->sub_type = 't';
+        } else if (t->codec_id == MKV_S_KATE) {
+          t->ptzr =
+            add_packetizer(new kate_packetizer_c(this,
+                                                 t->private_data,
+                                                 t->private_size,
+                                                 nti));
+          mxinfo(FMT_TID "Using the Kate output module.\n",
+                 ti.fname.c_str(), (int64_t)t->tnum);
+
+          t->sub_type = 'k';
+
         } else
           init_passthrough_packetizer(t);
 
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/input/r_ogm.cpp mkvtoolnix-svn/src/input/r_ogm.cpp
--- ../svn/mkvtoolnix/src/input/r_ogm.cpp	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/input/r_ogm.cpp	2008-03-17 22:08:40.000000000 +0000
@@ -48,6 +48,7 @@
 #include "p_textsubs.h"
 #include "p_video.h"
 #include "p_vorbis.h"
+#include "p_kate.h"
 #include "r_ogm.h"
 #include "r_ogm_flac.h"
 
@@ -219,6 +220,27 @@
   virtual bool is_header_packet(ogg_packet &op);
 };
 
+class ogm_s_kate_demuxer_c: public ogm_demuxer_c {
+public:
+  kate_identification_header_t kate;
+
+public:
+  ogm_s_kate_demuxer_c(ogm_reader_c *p_reader);
+
+  virtual const char *get_type() {
+    return ID_RESULT_TRACK_SUBTITLES;
+  };
+
+  virtual string get_codec() {
+    return "Kate";
+  };
+
+  virtual void initialize();
+  virtual generic_packetizer_c *create_packetizer(track_info_c &ti);
+  virtual void process_page(int64_t granulepos);
+  virtual bool is_header_packet(ogg_packet &op);
+};
+
 // ---------------------------------------------------------------------------------
 
 
@@ -454,6 +476,9 @@
   else if ((op.bytes >= 7) && !strncmp((char *)&op.packet[1], "theora", 6))
     dmx = new ogm_v_theora_demuxer_c(this);
 
+  else if ((op.bytes >= 9) && !strncmp((char *)&op.packet[1], "kate\0\0\0\0", 8))
+    dmx = new ogm_s_kate_demuxer_c(this);
+
   // FLAC
   else if ((op.bytes >= 4) && !strncmp((char *)op.packet, "fLaC", 4)) {
 #if !defined(HAVE_FLAC_FORMAT_H)
@@ -1312,7 +1337,8 @@
       continue;
 
     keyframe_number     = granulepos >> theora.kfgshift;
-    non_keyframe_number = granulepos &  theora.kfgshift;
+    non_keyframe_number = granulepos &  theora.kfgshift; // TODO: seems wrong
+    // should probably be: // non_keyframe_number = granulepos - (keyframe_number << theora.kfgshift);
 
     timecode = (int64_t)(1000000000.0 * units_processed * theora.frd / theora.frn);
     duration = (int64_t)(1000000000.0 *                   theora.frd / theora.frn);
@@ -1335,3 +1361,68 @@
 ogm_v_theora_demuxer_c::is_header_packet(ogg_packet &op) {
   return ((0x80 <= op.packet[0]) && (0x82 >= op.packet[0]));
 }
+
+ogm_s_kate_demuxer_c::ogm_s_kate_demuxer_c(ogm_reader_c *p_reader):
+  ogm_demuxer_c(p_reader) {
+
+  stype              = OGM_STREAM_TYPE_S_KATE;
+  num_header_packets = 1; /* at least 1, will be updated upon reading the ID header */
+
+  memset(&kate, 0, sizeof(kate_identification_header_t));
+}
+
+void
+ogm_s_kate_demuxer_c::initialize() {
+  try {
+    memory_cptr &mem = packet_data[0];
+    kate_parse_identification_header(mem->get(), mem->get_size(), kate);
+    num_header_packets = kate.nheaders;
+  } catch (error_c &e) {
+    mxerror(FMT_TID "The Kate identifaction header could not be parsed (%s).\n", reader->ti.fname.c_str(), track_id, e.get_error().c_str());
+  }
+}
+
+generic_packetizer_c *
+ogm_s_kate_demuxer_c::create_packetizer(track_info_c &ti) {
+  memory_cptr codecprivate       = lace_memory_xiph(packet_data);
+  ti.private_data                = codecprivate->get();
+  ti.private_size                = codecprivate->get_size();
+
+  generic_packetizer_c *ptzr_obj = new kate_packetizer_c(reader, ti.private_data, ti.private_size, ti);
+
+  mxinfo(FMT_TID "Using the Kate video output module.\n", ti.fname.c_str(), (int64_t)ti.id);
+
+  ti.private_data = NULL;
+
+  return ptzr_obj;
+}
+
+void
+ogm_s_kate_demuxer_c::process_page(int64_t granulepos) {
+  int base, offset;
+  ogg_packet op;
+
+  while (ogg_stream_packetout(&os, &op) == 1) {
+    eos |= op.e_o_s;
+
+    if ((0 == op.bytes) || (0 != (op.packet[0] & 0x80)))
+      continue;
+
+    base     = granulepos >> kate.kfgshift;
+    offset   = granulepos - (base << kate.kfgshift);
+
+    reader->reader_packetizers[ptzr]->process(new packet_t(new memory_c(op.packet, op.bytes, false)));
+
+    ++units_processed;
+
+    if (op.e_o_s) {
+      eos = 1;
+      return;
+    }
+  }
+}
+
+bool
+ogm_s_kate_demuxer_c::is_header_packet(ogg_packet &op) {
+  return (0x80 & op.packet[0]);
+}
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/input/r_ogm.h mkvtoolnix-svn/src/input/r_ogm.h
--- ../svn/mkvtoolnix/src/input/r_ogm.h	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/input/r_ogm.h	2008-03-17 20:13:01.000000000 +0000
@@ -28,6 +28,7 @@
 #include "common.h"
 #include "pr_generic.h"
 #include "theora_common.h"
+#include "kate_common.h"
 
 enum ogm_stream_type_e {
   OGM_STREAM_TYPE_UNKNOWN,
@@ -42,6 +43,7 @@
   OGM_STREAM_TYPE_V_AVC,
   OGM_STREAM_TYPE_V_MSCOMP,
   OGM_STREAM_TYPE_V_THEORA,
+  OGM_STREAM_TYPE_S_KATE,
 };
 
 class ogm_reader_c;
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/merge/mkvmerge.cpp mkvtoolnix-svn/src/merge/mkvmerge.cpp
--- ../svn/mkvtoolnix/src/merge/mkvmerge.cpp	2008-03-17 18:34:57.000000000 +0000
+++ mkvtoolnix-svn/src/merge/mkvmerge.cpp	2008-03-17 20:13:01.000000000 +0000
@@ -80,7 +80,7 @@
    {"mp2 ", FILE_TYPE_MP3, "MPEG-1 layer II audio (CBR and VBR/ABR)"},
    {"mp3 ", FILE_TYPE_MP3, "MPEG-1 layer III audio (CBR and VBR/ABR)"},
    {"mkv ", FILE_TYPE_MATROSKA, "general Matroska files"},
-   {"ogg ", FILE_TYPE_OGM, "audio/video embedded in OGG"},
+   {"ogg ", FILE_TYPE_OGM, "audio/video/text embedded in OGG"},
    {"mov ", FILE_TYPE_QTMP4, "Quicktime/MP4 audio and video"},
    {"rm  ", FILE_TYPE_REAL, "RealMedia audio and video"},
    {"srt ", FILE_TYPE_SRT, "SRT text subtitles"},
@@ -113,6 +113,7 @@
    {"    ", -1,      "VobSub subtitles"},
    {"    ", -1,      "Vorbis audio"},
    {"    ", -1,      "WAVPACK lossless audio"},
+   {"    ", -1,      "Kate subtitles"},
    {NULL,  -1,      NULL}};
 
 /** \brief Outputs usage information
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/output/p_kate.cpp mkvtoolnix-svn/src/output/p_kate.cpp
--- ../svn/mkvtoolnix/src/output/p_kate.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mkvtoolnix-svn/src/output/p_kate.cpp	2008-03-22 21:06:56.000000000 +0000
@@ -0,0 +1,150 @@
+/*
+   mkvmerge -- utility for splicing together matroska files
+   from component media subtypes
+
+   Distributed under the GPL
+   see the file COPYING for details
+   or visit http://www.gnu.org/copyleft/gpl.html
+
+   $Id: p_textsubs.cpp 3194 2006-02-27 17:06:55Z mosu $
+
+   kate packetizer
+
+   Written by Moritz Bunkus <moritz@bunkus.org>.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+
+#include <ogg/ogg.h>
+
+#include "common.h"
+#include "kate_common.h"
+#include "pr_generic.h"
+#include "p_kate.h"
+#include "matroska.h"
+
+using namespace libmatroska;
+
+kate_packetizer_c::kate_packetizer_c(generic_reader_c *_reader,
+                                     const void *_global_data,
+                                     int _global_size,
+                                     track_info_c &_ti)
+  throw (error_c):
+  generic_packetizer_c(_reader, _ti),
+  global_data(new memory_c((unsigned char *)safememdup(_global_data?_global_data:ti.private_data,
+                                                       _global_data?_global_size:ti.private_size),
+                           _global_data?_global_size:ti.private_size, true))
+{
+  int i, nheaders;
+
+  set_track_type(track_subtitle);
+
+  // the number of headers to expect is stored in the first header
+  memory_cptr temp(new memory_c((unsigned char *)global_data->get(),
+                                global_data->get_size(), false));
+  vector<memory_cptr> blocks = unlace_memory_xiph(temp);
+  kate_parse_identification_header(blocks[0]->get(), blocks[0]->get_size(), kate_id);
+  if (blocks.size() != kate_id.nheaders)
+    throw false;
+
+  set_language((const char*)kate_id.language);
+  nheaders = kate_id.nheaders;
+  for (i=0; i<nheaders;++i) {
+    headers.push_back(memory_cptr(new memory_c((unsigned char *)
+                                               safememdup(blocks[i]->get(), blocks[i]->get_size()),
+                                               blocks[i]->get_size())));
+  }
+
+  last_timecode = 0;
+}
+
+kate_packetizer_c::~kate_packetizer_c() {
+}
+
+void
+kate_packetizer_c::set_headers() {
+  set_codec_id(MKV_S_KATE);
+
+  memory_cptr codecprivate;
+  codecprivate = lace_memory_xiph(headers);
+  set_codec_private(codecprivate->get(), codecprivate->get_size());
+
+  generic_packetizer_c::set_headers();
+}
+
+static int64_t read64(const unsigned char *c)
+{
+  int64_t gpos=0;
+  for (int n=0;n<sizeof(int64_t);++n) {
+    uint64_t byte=*c++;
+    gpos|=byte<<(n*8);
+  }
+  return gpos;
+}
+
+int
+kate_packetizer_c::process(packet_cptr packet) {
+
+  if (packet->data->get_size()<1+3*sizeof(int64_t)) {
+    /* end packet is 1 byte long and has type 0x7f */
+    if (packet->data->get_size() == 1 && packet->data->get()[0]==0x7f) {
+      packet->timecode=last_timecode;
+      packet->duration=1;
+      packet->duration_mandatory = true;
+      add_packet(packet);
+    }
+    else {
+      mxwarn(_(FMT_TID "Kate packet is too small and is being skipped.\n"), ti.fname.c_str(), (int64_t)ti.id);
+    }
+    return FILE_STATUS_MOREDATA;
+  }
+
+  int64_t start_time=read64(packet->data->get()+1);
+  int64_t duration=read64(packet->data->get()+1+sizeof(int64_t));
+  int64_t backlink=read64(packet->data->get()+1+sizeof(int64_t)*2);
+
+  float t = (start_time*(float)kate_id.gden/kate_id.gnum);
+  float backlink_t = (int64_t)((start_time-backlink)*(float)kate_id.gden/kate_id.gnum);
+  float dt = (int64_t)(duration*(float)kate_id.gden/kate_id.gnum);
+  packet->timecode=(int64_t)(t*1000000000ll);
+  packet->bref=(int64_t)(backlink_t*1000000000ll);
+  packet->duration=(int64_t)(dt*1000000000ll);
+  packet->duration_mandatory = true;
+  int64_t end = packet->timecode+packet->duration;
+  if (end>last_timecode) last_timecode=end;
+  packet->gap_following=true;
+
+  add_packet(packet);
+
+  return FILE_STATUS_MOREDATA;
+}
+
+void
+kate_packetizer_c::dump_debug_info() {
+  mxdebug("kate_packetizer_c: queue: %u\n",
+          (unsigned int)packet_queue.size());
+}
+
+connection_result_e
+kate_packetizer_c::can_connect_to(generic_packetizer_c *src,
+                                      string &error_message) {
+  kate_packetizer_c *psrc;
+
+  psrc = dynamic_cast<kate_packetizer_c *>(src);
+  if (psrc == NULL)
+    return CAN_CONNECT_NO_FORMAT;
+
+  if (((ti.private_data == NULL) && (src->ti.private_data != NULL)) ||
+      ((ti.private_data != NULL) && (src->ti.private_data == NULL)) ||
+      (ti.private_size != src->ti.private_size)) {
+    error_message = mxsprintf("The codec's private data does not match "
+                              "(lengths: %d and %d).", ti.private_size,
+                              src->ti.private_size);
+    return CAN_CONNECT_MAYBE_CODECPRIVATE;
+  }
+
+  return CAN_CONNECT_YES;
+}
diff -x config.log -x config.status -x configure -x t1 -x t2 -x dump.1 -x dump.2 -x autom4te.cache -x Makefile -x config.h -x mkvmerge-gui.hhk -urN ../svn/mkvtoolnix/src/output/p_kate.h mkvtoolnix-svn/src/output/p_kate.h
--- ../svn/mkvtoolnix/src/output/p_kate.h	1970-01-01 01:00:00.000000000 +0100
+++ mkvtoolnix-svn/src/output/p_kate.h	2008-03-17 20:13:01.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+   mkvmerge -- utility for splicing together matroska files
+   from component media subtypes
+
+   Distributed under the GPL
+   see the file COPYING for details
+   or visit http://www.gnu.org/copyleft/gpl.html
+
+   $Id: p_textsubs.h 3112 2005-10-09 09:55:53Z mosu $
+
+   class definition for the kate packetizer
+
+   Written by Moritz Bunkus <moritz@bunkus.org>.
+*/
+
+#ifndef __P_KATE_H
+#define __P_KATE_H
+
+#include "os.h"
+
+#include "common.h"
+#include "pr_generic.h"
+#include "smart_pointers.h"
+#include "kate_common.h"
+
+class kate_packetizer_c: public generic_packetizer_c {
+private:
+  vector<memory_cptr> headers;
+  //int packetno;
+  memory_cptr global_data;
+
+  kate_identification_header_t kate_id;
+
+  int64_t last_timecode;
+
+public:
+  kate_packetizer_c(generic_reader_c *_reader,
+                    const void *_global_data, int _global_size,
+                    track_info_c &_ti)
+    throw (error_c);
+  virtual ~kate_packetizer_c();
+
+  virtual int process(packet_cptr packet);
+  virtual void set_headers();
+
+  virtual void dump_debug_info();
+
+  virtual const char *get_format_name() {
+    return "kate";
+  }
+  virtual connection_result_e can_connect_to(generic_packetizer_c *src,
+                                             string &error_message);
+};
+
+
+#endif  // __P_KATE_H
