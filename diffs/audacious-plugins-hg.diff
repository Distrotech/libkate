diff -ru audacious-plugins-be718ff506c0/configure.ac ../audacious-plugins-be718ff506c0/configure.ac
--- audacious-plugins-be718ff506c0/configure.ac	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/configure.ac	2008-10-27 20:39:20.000000000 +0000
@@ -685,6 +685,32 @@
 	INPUT_PLUGINS="$INPUT_PLUGINS vorbis"
 fi
 
+dnl *** Kate
+
+AC_ARG_ENABLE(kate,
+    [  --disable-kate          disable Kate support in Vorbis plugin (default=enabled)],
+    [enable_kate=$enableval],
+    [enable_kate="yes"]
+)
+
+if test "x$enable_kate" = "xyes"; then
+    PKG_CHECK_MODULES(KATE, [kate >= 0.1.5],
+        [have_kate=yes],
+        [AC_MSG_WARN([*** Cannot find libkate, Ogg Vorbis will be built without Kate support ***])
+         have_kate=no]
+    )
+else
+    AC_MSG_RESULT([*** Kate disabled per user request ***])
+    have_kate=no
+fi
+
+if test "x$have_kate" = "xyes"; then
+    AC_DEFINE(HAVE_KATE, 1, [Define if libkate is available.])
+    AC_SUBST(KATE_CFLAGS)
+    AC_SUBST(KATE_LIBS)
+fi
+
+
 dnl *** FLACng (in progress replacement to XMMS-flac port)
 
 AC_ARG_ENABLE(flacng,
@@ -1720,6 +1746,7 @@
 echo "  sndfile extensions:                     $enable_sndfile"
 echo "  Tone Generator:                         yes"
 echo "  Ogg Vorbis (vorbis):                    $have_oggvorbis"
+echo "    -> Kate synced lyrics:                $have_kate"
 echo "  Free Lossless Audio Codec (flacng):     $have_flacng"
 echo "  Commodore 64 audio (SID):               $have_sidplay $xs_have_sidplay2_api"
 echo "    -> libSIDPlay1 support:               $xs_have_sidplay1"
diff -ru audacious-plugins-be718ff506c0/extra.mk.in ../audacious-plugins-be718ff506c0/extra.mk.in
--- audacious-plugins-be718ff506c0/extra.mk.in	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/extra.mk.in	2008-07-21 19:24:41.000000000 +0100
@@ -164,6 +164,8 @@
 HAVE_GNOME_VFS_TRUE ?= @HAVE_GNOME_VFS_TRUE@
 HAVE_JACK_FALSE ?= @HAVE_JACK_FALSE@
 HAVE_JACK_TRUE ?= @HAVE_JACK_TRUE@
+HAVE_KATE_FALSE ?= @HAVE_KATE_FALSE@
+HAVE_KATE_TRUE ?= @HAVE_KATE_TRUE@
 HAVE_NULL_TRUE ?= @HAVE_NULL_TRUE@
 HAVE_LIBSAMPLERATE_FALSE ?= @HAVE_LIBSAMPLERATE_FALSE@
 HAVE_LIBSAMPLERATE_TRUE ?= @HAVE_LIBSAMPLERATE_TRUE@
@@ -200,6 +202,8 @@
 INTL_LIBTOOL_SUFFIX_PREFIX ?= @INTL_LIBTOOL_SUFFIX_PREFIX@
 JACK_CFLAGS ?= @JACK_CFLAGS@
 JACK_LIBS ?= @JACK_LIBS@
+KATE_CFLAGS ?= @KATE_CFLAGS@
+KATE_LIBS ?= @KATE_LIBS@
 LDFLAGS ?= @LDFLAGS@
 LEDCODE ?= @LEDCODE@
 LIBBEEP_MAJOR_VERSION ?= @LIBBEEP_MAJOR_VERSION@
diff -ru audacious-plugins-be718ff506c0/src/vorbis/configure.c ../audacious-plugins-be718ff506c0/src/vorbis/configure.c
--- audacious-plugins-be718ff506c0/src/vorbis/configure.c	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/configure.c	2008-10-27 19:59:19.000000000 +0000
@@ -18,6 +18,15 @@
 static GtkWidget *title_tag_override, *title_tag_box, *title_tag_entry,
     *title_desc;
 
+#ifdef HAVE_KATE
+static GtkWidget *kate_display, *kate_all_streams;
+static GtkWidget *kate_offset_spin, *kate_offset_box, *kate_offset_label;
+static GtkTooltips *kate_tip_display, *kate_tip_offset, *kate_tip_all_streams;
+#else
+static GtkWidget *kate_not_compiled_in_label;
+static GtkTooltips *kate_tip_not_compiled_in;
+#endif
+
 vorbis_config_t vorbis_cfg;
 
 static void
@@ -26,19 +35,38 @@
     mcs_handle_t *db;
     GtkToggleButton *tb;
 
-	if (vorbis_cfg.tag_format != NULL)
-		g_free(vorbis_cfg.tag_format);
+    if (vorbis_cfg.tag_format != NULL)
+	g_free(vorbis_cfg.tag_format);
     vorbis_cfg.tag_format =
         g_strdup(gtk_entry_get_text(GTK_ENTRY(title_tag_entry)));
+#ifdef HAVE_KATE
+    vorbis_cfg.kate_offset =
+        gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(kate_offset_spin));
+#else
+    vorbis_cfg.kate_offset = 0;
+#endif
 
     tb = GTK_TOGGLE_BUTTON(title_tag_override);
     vorbis_cfg.tag_override = gtk_toggle_button_get_active(tb);
+#ifdef HAVE_KATE
+    tb = GTK_TOGGLE_BUTTON(kate_display);
+    vorbis_cfg.kate_display = gtk_toggle_button_get_active(tb);
+    tb = GTK_TOGGLE_BUTTON(kate_all_streams);
+    vorbis_cfg.kate_all_streams = gtk_toggle_button_get_active(tb);
+#else
+    vorbis_cfg.kate_display = FALSE;
+    vorbis_cfg.kate_all_streams = FALSE;
+#endif
 
     db = aud_cfg_db_open();
     aud_cfg_db_set_bool(db, "vorbis", "tag_override",
                         vorbis_cfg.tag_override);
     aud_cfg_db_set_string(db, "vorbis", "tag_format", vorbis_cfg.tag_format);
+    aud_cfg_db_set_int(db, "vorbis", "kate_offset", vorbis_cfg.kate_offset);
+    aud_cfg_db_set_bool(db, "vorbis", "kate_display", vorbis_cfg.kate_display);
+    aud_cfg_db_set_bool(db, "vorbis", "kate_all_streams", vorbis_cfg.kate_all_streams);
     aud_cfg_db_close(db);
+
     gtk_widget_destroy(vorbis_configurewin);
 }
 
@@ -58,10 +86,27 @@
     gtk_widget_set_sensitive(title_desc, override);
 }
 
+#ifdef HAVE_KATE
+static void
+kate_display_cb(GtkWidget * w, gpointer data)
+{
+    gboolean display;
+    display = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(kate_display));
+    gtk_widget_set_sensitive(kate_offset_box, display);
+    gtk_widget_set_sensitive(kate_offset_label, display);
+    gtk_widget_set_sensitive(kate_offset_spin, display);
+    gtk_widget_set_sensitive(kate_all_streams, display);
+}
+#endif
+
 void
 vorbis_configure(void)
 {
     GtkWidget *title_frame, *title_tag_vbox, *title_tag_label;
+    GtkWidget *kate_frame, *kate_vbox;
+#ifdef HAVE_KATE
+    GtkObject *kate_offset_adj;
+#endif
     GtkWidget *bbox, *ok, *cancel;
 
     if (vorbis_configurewin != NULL) {
@@ -120,6 +165,57 @@
 
     gtk_box_pack_start(GTK_BOX(vbox), title_frame, TRUE, TRUE, 0);
 
+    /* Kate config.. */
+
+    kate_frame = gtk_frame_new(_("Kate lyrics:"));
+    gtk_container_border_width(GTK_CONTAINER(kate_frame), 5);
+
+    kate_vbox = gtk_vbox_new(FALSE, 10);
+    gtk_container_border_width(GTK_CONTAINER(kate_vbox), 5);
+    gtk_container_add(GTK_CONTAINER(kate_frame), kate_vbox);
+
+#ifdef HAVE_KATE
+    kate_display = gtk_check_button_new_with_label(_("Display Kate lyrics"));
+    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(kate_display), vorbis_cfg.kate_display);
+    g_signal_connect(G_OBJECT(kate_display), "clicked", G_CALLBACK(kate_display_cb), NULL);
+    gtk_box_pack_start(GTK_BOX(kate_vbox), kate_display, FALSE, FALSE, 0);
+    kate_tip_display = gtk_tooltips_new();
+    gtk_tooltips_set_tip(kate_tip_display, kate_display, _("If enabled, Kate lyrics will be displayed in sync on the player window."), NULL);
+    gtk_tooltips_enable(kate_tip_display);
+
+    kate_offset_box = gtk_hbox_new(FALSE, 5);
+    gtk_box_pack_start(GTK_BOX(kate_vbox), kate_offset_box, FALSE,
+                       FALSE, 0);
+
+    kate_offset_label = gtk_label_new(_("Offset (ms):"));
+    gtk_box_pack_start(GTK_BOX(kate_offset_box), kate_offset_label, FALSE, FALSE, 0);
+    kate_offset_adj = gtk_adjustment_new(vorbis_cfg.kate_offset, -1000, +1000, 10, 10, 10);
+    kate_offset_spin = gtk_spin_button_new(GTK_ADJUSTMENT(kate_offset_adj), 8, 0);
+    gtk_widget_set_usize(kate_offset_spin, 60, -1);
+    gtk_box_pack_start(GTK_BOX(kate_offset_box), kate_offset_spin, FALSE, FALSE, 0);
+    gtk_spin_button_set_value(GTK_SPIN_BUTTON(kate_offset_spin),
+                                 vorbis_cfg.kate_offset);
+    kate_tip_offset = gtk_tooltips_new();
+    gtk_tooltips_set_tip(kate_tip_offset, kate_offset_spin, _("The amount of time (in milliseconds) to offset lyrics display (negative values will display lyrics earlier)."), NULL);
+    gtk_tooltips_enable(kate_tip_offset);
+
+    kate_all_streams = gtk_check_button_new_with_label(_("Display all Kate streams"));
+    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(kate_all_streams), vorbis_cfg.kate_all_streams);
+    gtk_box_pack_start(GTK_BOX(kate_vbox), kate_all_streams, FALSE, FALSE, 0);
+    kate_tip_all_streams = gtk_tooltips_new();
+    gtk_tooltips_set_tip(kate_tip_all_streams, kate_all_streams, _("If enabled, all Kate streams will be displayed, not just those with a \"lyrics\" category (eg, movie subtitles, or if a lyrics Kate stream is not declared as lyrics)."), NULL);
+    gtk_tooltips_enable(kate_tip_all_streams);
+
+#else
+    kate_not_compiled_in_label = gtk_label_new(_("Kate support not compiled in"));
+    gtk_box_pack_start(GTK_BOX(kate_vbox), kate_not_compiled_in_label, FALSE, FALSE, 0);
+    kate_tip_not_compiled_in = gtk_tooltips_new();
+    gtk_tooltips_set_tip(kate_tip_not_compiled_in, kate_not_compiled_in_label, _("This plugin was not compiled with libkate, lyrics will be ignored.\nInstall libkate and rebuild this plugin for lyrics support"), NULL);
+    gtk_tooltips_enable(kate_tip_not_compiled_in);
+#endif
+
+    gtk_box_pack_start(GTK_BOX(vbox), kate_frame, TRUE, TRUE, 0);
+
     /* Buttons */
 
     bbox = gtk_hbutton_box_new();
diff -ru audacious-plugins-be718ff506c0/src/vorbis/Makefile ../audacious-plugins-be718ff506c0/src/vorbis/Makefile
--- audacious-plugins-be718ff506c0/src/vorbis/Makefile	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/Makefile	2008-07-21 19:24:41.000000000 +0100
@@ -11,5 +11,5 @@
 plugindir := ${plugindir}/${INPUT_PLUGIN_DIR}
 
 CFLAGS += ${PLUGIN_CFLAGS}
-CPPFLAGS += ${PLUGIN_CPPFLAGS} ${MOWGLI_CFLAGS}  ${OGG_VORBIS_CFLAGS} ${GTK_CFLAGS} ${GLIB_CFLAGS}  -I../..
-LIBS += ${OGG_VORBIS_LIBS} ${GTK_LIBS} ${GLIB_LIBS}  ${MOWGLI_LIBS}
+CPPFLAGS += ${PLUGIN_CPPFLAGS} ${MOWGLI_CFLAGS} ${KATE_CFLAGS} ${OGG_VORBIS_CFLAGS} ${GTK_CFLAGS} ${GLIB_CFLAGS}  -I../..
+LIBS += ${KATE_LIBS} ${OGG_VORBIS_LIBS} ${GTK_LIBS} ${GLIB_LIBS}  ${MOWGLI_LIBS}
diff -ru audacious-plugins-be718ff506c0/src/vorbis/vcedit.c ../audacious-plugins-be718ff506c0/src/vorbis/vcedit.c
--- audacious-plugins-be718ff506c0/src/vorbis/vcedit.c	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/vcedit.c	2008-10-27 19:54:52.000000000 +0000
@@ -140,6 +140,43 @@
     return ret;
 }
 
+static void
+_opcpy(ogg_page *dest, ogg_page *src)
+{
+    dest->header = _ogg_malloc(src->header_len);
+    memcpy(dest->header, src->header, src->header_len);
+    dest->header_len = src->header_len;
+    dest->body = _ogg_malloc(src->body_len);
+    memcpy(dest->body, src->body, src->body_len);
+    dest->body_len = src->body_len;
+}
+
+static void
+_opclear(ogg_page *og)
+{
+    _ogg_free(og->header);
+    _ogg_free(og->body);
+}
+
+static void
+_add_extrapage(vcedit_state *s, ogg_page *page)
+{
+    s->extrapages = (ogg_page*)g_realloc(s->extrapages, (s->nextrapages+1)*sizeof(ogg_page));
+    _opcpy(s->extrapages+s->nextrapages, page);
+    ++s->nextrapages;
+}
+
+static int
+_get_next_extrapage(vcedit_state *s, ogg_page *page)
+{
+    if (s->nextrapages == 0)
+        return 0;
+    memcpy(page, s->extrapages, sizeof(ogg_page));
+    --s->nextrapages;
+    memmove(s->extrapages, s->extrapages+1, s->nextrapages*sizeof(ogg_page));
+    return 1;
+}
+
 static int
 _fetch_next_packet(vcedit_state * s, ogg_packet * p, ogg_page * page)
 {
@@ -161,15 +198,15 @@
             if (bytes == 0)
                 return 0;
         }
-        if (ogg_page_eos(page))
-            s->eosin = 1;
-        else if (ogg_page_serialno(page) != s->serial) {
-            s->eosin = 1;
-            s->extrapage = 1;
-            return 0;
+        if (ogg_page_serialno(page) != s->serial) {
+            _add_extrapage(s, page);
+        }
+        else {
+            ogg_stream_pagein(s->os, page);
+            if (ogg_page_eos(page))
+                s->eosin = 1;
         }
 
-        ogg_stream_pagein(s->os, page);
         return _fetch_next_packet(s, p, page);
     }
 }
@@ -200,6 +237,9 @@
     state->read = read_func;
     state->write = write_func;
 
+    state->extrapages = NULL;
+    state->nextrapages = 0;
+
     state->oy = g_new(ogg_sync_state, 1);
     ogg_sync_init(state->oy);
 
@@ -254,23 +294,30 @@
             if (result == 0)
                 break;          /* Too little data so far */
             else if (result == 1) {
-                ogg_stream_pagein(state->os, &og);
-                while (i < 2) {
-                    result = ogg_stream_packetout(state->os, header);
-                    if (result == 0)
-                        break;
-                    if (result == -1) {
-                        state->lasterror = "Corrupt secondary header.";
-                        goto err;
-                    }
-                    vorbis_synthesis_headerin(&state->vi, state->vc, header);
-                    if (i == 1) {
-                        state->booklen = header->bytes;
-                        state->bookbuf = g_malloc(state->booklen);
-                        memcpy(state->bookbuf, header->packet, header->bytes);
+                if (state->serial != ogg_page_serialno(&og)) {
+                    _add_extrapage(state, &og);
+                }
+                else {
+                    ogg_stream_pagein(state->os, &og);
+                    while(i<2)
+                    {
+                        result = ogg_stream_packetout(state->os, header);
+                        if(result == 0) break;
+                        if(result == -1)
+                        {
+                            state->lasterror = "Corrupt secondary header.";
+                            goto err;
+                        }
+                        vorbis_synthesis_headerin(&state->vi, state->vc, header);
+                        if(i==1)
+                        {
+                            state->booklen = header->bytes;
+                            state->bookbuf = g_malloc(state->booklen);
+                            memcpy(state->bookbuf, header->packet, header->bytes);
+                        }
+                        i++;
+                        header = &header_codebooks;
                     }
-                    i++;
-                    header = &header_codebooks;
                 }
             }
         }
@@ -303,6 +350,33 @@
 }
 #endif
 
+static int
+write_page(vcedit_state *s, ogg_page *og, void *out)
+{
+    if(s->write(og->header,1,og->header_len, out) != (size_t) og->header_len)
+        return 0;
+    if (s->write(og->body,1,og->body_len, out) != (size_t) og->body_len)
+        return 0;
+
+    return 1;
+}
+
+static int
+_flush_extrapages(vcedit_state *s, void *out)
+{
+    ogg_page og;
+
+    if (s->nextrapages)
+    {
+        while (_get_next_extrapage(s, &og)) {
+            if (!write_page(s, &og, out))
+                return 0;
+            _opclear(&og);
+        }
+    }
+    return 1;
+}
+
 int
 vcedit_write(vcedit_state * state, void *out)
 {
@@ -321,7 +395,6 @@
     int needflush = 0, needout = 0;
 
     state->eosin = 0;
-    state->extrapage = 0;
 
     header_main.bytes = state->mainlen;
     header_main.packet = state->mainbuf;
@@ -344,36 +417,38 @@
     ogg_stream_packetin(&streamout, &header_codebooks);
 
     while ((result = ogg_stream_flush(&streamout, &ogout))) {
-        if (state->write(ogout.header, 1, ogout.header_len, out) !=
-            (size_t) ogout.header_len)
-            goto cleanup;
-        if (state->write(ogout.body, 1, ogout.body_len, out) !=
-            (size_t) ogout.body_len)
+        if (!write_page(state, &ogout, out))
             goto cleanup;
+
+            /* now, we have written the Vorbis BOS header, so it is time to write the BOS
+               header of any other stream we have - due to the Ogg spec, these are now
+               conveniently at the beginning of the extrapages list */
+            while (state->nextrapages > 0 && ogg_page_bos(state->extrapages)) {
+                _get_next_extrapage(state, &ogin);
+                if (!write_page(state, &ogin, out))
+                    goto cleanup;
+                _opclear(&ogin);
+        }
     }
 
     while (_fetch_next_packet(state, &op, &ogin)) {
         int size;
+
+        if (!_flush_extrapages(state, out))
+            goto cleanup;
+
         size = _blocksize(state, &op);
         granpos += size;
 
         if (needflush) {
             if (ogg_stream_flush(&streamout, &ogout)) {
-                if (state->write(ogout.header, 1, ogout.header_len,
-                                 out) != (size_t) ogout.header_len)
-                    goto cleanup;
-                if (state->write(ogout.body, 1, ogout.body_len,
-                                 out) != (size_t) ogout.body_len)
+                if (!write_page(state, &ogout, out))
                     goto cleanup;
             }
         }
         else if (needout) {
             if (ogg_stream_pageout(&streamout, &ogout)) {
-                if (state->write(ogout.header, 1, ogout.header_len,
-                                 out) != (size_t) ogout.header_len)
-                    goto cleanup;
-                if (state->write(ogout.body, 1, ogout.body_len,
-                                 out) != (size_t) ogout.body_len)
+                if (!write_page(state, &ogout, out))
                     goto cleanup;
             }
         }
@@ -398,13 +473,15 @@
         }
     }
 
+    while (_get_next_extrapage(state, &ogin)) {
+            if (!write_page(state, &ogin, out))
+                goto cleanup;
+            _opclear(&ogin);
+    }
+
     streamout.e_o_s = 1;
     while (ogg_stream_flush(&streamout, &ogout)) {
-        if (state->write(ogout.header, 1, ogout.header_len,
-                         out) != (size_t) ogout.header_len)
-            goto cleanup;
-        if (state->write(ogout.body, 1, ogout.body_len,
-                         out) != (size_t) ogout.body_len)
+        if (!write_page(state, &ogout, out))
             goto cleanup;
     }
 
@@ -412,15 +489,6 @@
     /* Done with this, now */
     vorbis_info_clear(&state->vi);
 
-    if (state->extrapage) {
-        if (state->write(ogin.header, 1, ogin.header_len,
-                         out) != (size_t) ogin.header_len)
-            goto cleanup;
-        if (state->write(ogin.body, 1, ogin.body_len, out) !=
-            (size_t) ogin.body_len)
-            goto cleanup;
-    }
-
     state->eosin = 0;           /* clear it, because not all paths to here do */
     while (!state->eosin) {     /* We reached eos, not eof */
         /* We copy the rest of the stream (other logical streams)
@@ -434,11 +502,7 @@
             else {
                 /* Don't bother going through the rest, we can just 
                  * write the page out now */
-                if (state->write(ogout.header, 1, ogout.header_len,
-                                 out) != (size_t) ogout.header_len)
-                    goto cleanup;
-                if (state->write(ogout.body, 1, ogout.body_len, out) !=
-                    (size_t) ogout.body_len)
+                if (!write_page(state, &ogout, out))
                     goto cleanup;
             }
         }
diff -ru audacious-plugins-be718ff506c0/src/vorbis/vcedit.h ../audacious-plugins-be718ff506c0/src/vorbis/vcedit.h
--- audacious-plugins-be718ff506c0/src/vorbis/vcedit.h	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/vcedit.h	2008-07-21 19:24:41.000000000 +0100
@@ -41,7 +41,8 @@
 	char 	         *lasterror;
 	char             *vendor;
 	int               prevW;
-	int               extrapage;
+        ogg_page         *extrapages;
+	int               nextrapages;
 	int               eosin;
 } vcedit_state;
 
diff -ru audacious-plugins-be718ff506c0/src/vorbis/vcupdate.c ../audacious-plugins-be718ff506c0/src/vorbis/vcupdate.c
--- audacious-plugins-be718ff506c0/src/vorbis/vcupdate.c	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/vcupdate.c	2008-10-27 20:18:24.000000000 +0000
@@ -42,8 +42,6 @@
 
 static gboolean write_and_pivot_files(vcedit_state * state);
 
-extern GMutex *vf_mutex;
-
 static mowgli_dictionary_t *
 dictionary_from_vorbis_comment(vorbis_comment * vc)
 {
@@ -127,11 +125,13 @@
     if(!tuple || !fd) return FALSE;
     
     g_mutex_lock(vf_mutex);
+    g_mutex_lock(kate_mutex);
 
     state = vcedit_new_state();
 
     if(vcedit_open(state, fd) < 0) {
         vcedit_clear(state);
+        g_mutex_unlock(kate_mutex);
         g_mutex_unlock(vf_mutex);
         return FALSE;
     }
@@ -154,6 +154,7 @@
     ret = write_and_pivot_files(state);
 
     vcedit_clear(state);
+    g_mutex_unlock(kate_mutex);
     g_mutex_unlock(vf_mutex);
 
     return ret;
diff -ru audacious-plugins-be718ff506c0/src/vorbis/vorbis.c ../audacious-plugins-be718ff506c0/src/vorbis/vorbis.c
--- audacious-plugins-be718ff506c0/src/vorbis/vorbis.c	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/vorbis.c	2008-10-27 20:40:06.000000000 +0000
@@ -4,6 +4,7 @@
  * Copyright (C) 2007 William Pitcock <nenolod@sacredspiral.co.uk>
  * Copyright (C) 2008 Cristi Măgherușan <majeru@gentoo.ro>
  * Copyright (C) 2008 Eugene Zagidullin <e.asphyx@gmail.com>
+ * Copyright (C) 2008 Vincent Penquerc'h <ogg.k.ogg.k@googlemail.com>
  *
  * ReplayGain processing Copyright (C) 2002 Gian-Carlo Pascutto <gcp@sjeng.org>
  *
@@ -37,8 +38,6 @@
 /*#define AUD_DEBUG
 #define DEBUG*/
 
-#define REMOVE_NONEXISTANT_TAG(x)   if (x != NULL && !*x) { x = NULL; }
-
 #include <glib.h>
 #include <gtk/gtk.h>
 
@@ -51,6 +50,9 @@
 #include <ogg/ogg.h>
 #include <vorbis/codec.h>
 #include <vorbis/vorbisfile.h>
+#ifdef HAVE_KATE
+#include <kate/kate.h>
+#endif
 
 #include <audacious/plugin.h>
 #include <audacious/output.h>
@@ -58,8 +60,6 @@
 
 #include "vorbis.h"
 
-extern vorbis_config_t vorbis_cfg;
-
 static Tuple *get_song_tuple(gchar *filename);
 static int vorbis_check_fd(char *filename, VFSFile *stream);
 static void vorbis_play(InputPlayback *data);
@@ -80,23 +80,23 @@
 static int ovcb_close(void *datasource);
 static long ovcb_tell(void *datasource);
 
-ov_callbacks vorbis_callbacks = {
+static ov_callbacks vorbis_callbacks = {
     ovcb_read,
     ovcb_seek,
     ovcb_close,
     ovcb_tell
 };
 
-ov_callbacks vorbis_callbacks_stream = {
+static ov_callbacks vorbis_callbacks_stream = {
     ovcb_read,
     NULL,
     ovcb_close,
     NULL
 };
 
-gchar *vorbis_fmts[] = { "ogg", "ogm", NULL };
+static gchar *vorbis_fmts[] = { "ogg", "oga", "ogm", NULL };
 
-InputPlugin vorbis_ip = {
+static InputPlugin vorbis_ip = {
     .description = "Ogg Vorbis Audio Plugin",  /* description */
     .init = vorbis_init,                /* init */
     .about = vorbis_aboutbox,            /* aboutbox */
@@ -112,20 +112,267 @@
     .update_song_tuple = vorbis_update_song_tuple,
 };
 
-InputPlugin *vorbis_iplist[] = { &vorbis_ip, NULL };
+static InputPlugin *vorbis_iplist[] = { &vorbis_ip, NULL };
 
 DECLARE_PLUGIN(vorbis, NULL, NULL, vorbis_iplist, NULL, NULL, NULL, NULL, NULL);
 
 static OggVorbis_File vf;
 
+#ifdef HAVE_KATE
+
+typedef struct {
+    char *text;
+    double t;
+} lyrics_event;
+
+typedef struct {
+    kate_state k;
+    ogg_stream_state kst;
+    ogg_sync_state ksy;
+    enum { kis_none, kis_sync, kis_all } kate_init_state;
+    lyrics_event *lyrics_events;
+    size_t num_lyrics_events;
+} aud_kate_state;
+
+#endif
+
+typedef struct {
+    VFSFile *fd;
+    gboolean probe;
+#ifdef HAVE_KATE
+    aud_kate_state aks;
+#endif
+} VFSVorbisFile;
+
 static GThread *thread;
 static volatile int seekneeded = -1;
 static int samplerate, channels;
+
 GMutex *vf_mutex;
+GMutex *kate_mutex;
 
-gchar **vorbis_tag_encoding_list = NULL;
 static GtkWidget *about_window;
 
+#ifdef HAVE_KATE
+
+static void
+aud_kate_state_init(aud_kate_state *aks)
+{
+    aks->kate_init_state = kis_none;
+    aks->lyrics_events = NULL;
+    aks->num_lyrics_events = 0;
+}
+
+static void
+add_lyrics_event(aud_kate_state *aks,const char *text, double t)
+{
+    lyrics_event *new_lyrics_events = (lyrics_event*)g_realloc(aks->lyrics_events, (aks->num_lyrics_events+1)*sizeof(lyrics_event));
+    if (!new_lyrics_events) {
+        /* failed to allocate */
+        return;
+    }
+    aks->lyrics_events = new_lyrics_events;
+
+    aks->lyrics_events[aks->num_lyrics_events].text = g_strdup(text);
+    aks->lyrics_events[aks->num_lyrics_events].t = t;
+
+    ++aks->num_lyrics_events;
+}
+
+static char *
+get_next_lyrics_event(aud_kate_state *aks,double t)
+{
+    char *text;
+
+    if (aks->num_lyrics_events == 0) return NULL;
+    if (aks->lyrics_events[0].t + vorbis_cfg.kate_offset/1000.0 > t) return NULL;
+
+    text = aks->lyrics_events[0].text;
+    --aks->num_lyrics_events;
+    memmove(aks->lyrics_events, aks->lyrics_events+1, sizeof(lyrics_event)*aks->num_lyrics_events);
+
+    return text; /* caller owns and must free */
+}
+
+static void
+clear_lyrics_events(aud_kate_state *aks)
+{
+    size_t n;
+    for (n=0; n<aks->num_lyrics_events; ++n) {
+        /* NULL is fine to free */
+        g_free(aks->lyrics_events[n].text);
+    }
+    g_free(aks->lyrics_events);
+    aks->lyrics_events = NULL;
+    aks->num_lyrics_events = 0;
+
+    vorbis_ip.set_info_text("");
+}
+
+static void
+shutdown_kate(aud_kate_state *aks)
+{
+    if (aks->kate_init_state == kis_all) {
+        ogg_stream_clear(&aks->kst);
+    }
+    if (aks->kate_init_state >= kis_sync) {
+        ogg_sync_clear(&aks->ksy);
+    }
+    if (aks->kate_init_state == kis_all) {
+        kate_high_decode_clear(&aks->k);
+    }
+
+    aks->kate_init_state = kis_none;
+
+    clear_lyrics_events(aks);
+}
+
+static void
+setup_kate(aud_kate_state *aks)
+{
+    ogg_sync_init(&aks->ksy);
+    aks->kate_init_state = kis_sync;
+
+    clear_lyrics_events(aks);
+}
+
+static void
+reset_kate(aud_kate_state *aks)
+{
+    if (aks->kate_init_state == kis_all) {
+        ogg_stream_clear(&aks->kst);
+        kate_high_decode_clear(&aks->k);
+    }
+
+    if (aks->kate_init_state >= kis_sync) {
+        aks->kate_init_state = kis_sync;
+    }
+
+    clear_lyrics_events(aks);
+}
+
+static int
+is_kate_bos(ogg_page *og)
+{
+    ogg_stream_state os;
+    ogg_packet op;
+    int kate_bos = 0;
+
+    if (!ogg_page_bos(og)) return 0;
+    ogg_stream_init(&os, ogg_page_serialno (og));
+    ogg_stream_pagein(&os, og);
+    if (ogg_stream_packetpeek(&os, &op) > 0) {
+        kate_bos = (op.bytes>=8 && !memcmp(op.packet,"\200kate\0\0\0",8));
+        ogg_stream_clear(&os);
+    }
+    return kate_bos;
+}
+
+static void
+process_kate(aud_kate_state *aks,void *ptr, size_t sz)
+{
+    int ret;
+    ogg_page og;
+    ogg_packet op;
+    char *buffer;
+
+    if (aks->kate_init_state < kis_sync)
+        return;
+
+    buffer = ogg_sync_buffer(&aks->ksy, sz);
+    if (buffer) {
+        memcpy(buffer, ptr, sz);
+        ogg_sync_wrote(&aks->ksy, sz);
+    }
+
+    while (ogg_sync_pageout(&aks->ksy, &og) > 0) {
+        /* if we get a Kate BOS, reset */
+        if (is_kate_bos(&og)) {
+            AUDDBG("found Kate BOS - init for %08x\n", ogg_page_serialno (&og));
+            reset_kate(aks);
+            ogg_stream_init(&aks->kst, ogg_page_serialno (&og));
+            ogg_stream_pagein(&aks->kst, &og);
+            ret = kate_high_decode_init(&aks->k);
+            if (ret < 0) {
+                AUDDBG("kate_high_decode_init failed: %d\n", ret);
+                ogg_stream_clear(&aks->kst);
+                aks->kate_init_state = kis_sync;
+            }
+            else {
+              if (ogg_stream_packetout(&aks->kst, &op) > 0) {
+                kate_packet kp;
+                kate_packet_wrap(&kp, op.bytes, op.packet);
+                ret = kate_high_decode_packetin(&aks->k, &kp, NULL);
+                if (ret < 0) {
+                    AUDDBG("kate_high_decode_packetin failed: %d\n", ret);
+                }
+                else {
+                  if (!vorbis_cfg.kate_all_streams && strcmp(aks->k.ki->category, "lyrics")) {
+                    AUDDBG("Kate stream is not lyrics (%s): ignoring\n", aks->k.ki->category);
+                    ogg_stream_clear(&aks->kst);
+                    kate_high_decode_clear(&aks->k);
+                    aks->kate_init_state = kis_sync;
+                  }
+                  else {
+                      aks->kate_init_state = kis_all;
+                  }
+                }
+              }
+              else {
+                AUDDBG("Initial Kate page did not contain Kate BOS header\n");
+                ogg_stream_clear(&aks->kst);
+                kate_high_decode_clear(&aks->k);
+                aks->kate_init_state = kis_sync;
+              }
+            }
+        }
+        else if (aks->kate_init_state == kis_all) {
+           ogg_stream_pagein(&aks->kst, &og);
+
+            while (ogg_stream_packetout(&aks->kst, &op) > 0) {
+                const kate_event *ev = NULL;
+                kate_packet kp;
+                kate_packet_wrap(&kp, op.bytes, op.packet);
+                ret = kate_high_decode_packetin(&aks->k, &kp, &ev);
+                if (ret < 0) {
+                    AUDDBG("kate_high_decode_packetin failed: %d\n", ret);
+                }
+                else {
+                    if (ev) {
+                        add_lyrics_event(aks, ev->text, ev->start_time);
+                        add_lyrics_event(aks, "", ev->end_time);
+                    }
+                    if (ret > 0) {
+                        /* eos */
+                        reset_kate(aks);
+                    }
+                }
+            }
+        }
+    }
+}
+
+static void
+update_lyrics(aud_kate_state *aks, InputPlayback *playback, char *title)
+{
+    char *text;
+
+    g_mutex_lock(vf_mutex);
+    text = get_next_lyrics_event(aks, playback->output->output_time()/1000.0);
+    if (text) {
+        if (vorbis_cfg.kate_display) {
+            vorbis_ip.set_info_text(text);
+        }
+        else {
+            vorbis_ip.set_info_text(title);
+        }
+        g_free(text);
+    }
+    g_mutex_unlock(vf_mutex);
+}
+
+#endif
+
 static int
 vorbis_check_fd(char *filename, VFSFile *stream)
 {
@@ -136,6 +383,9 @@
     fd = g_new0(VFSVorbisFile, 1);
     fd->fd = stream;
     fd->probe = TRUE;
+#ifdef HAVE_KATE
+    aud_kate_state_init(&fd->aks);
+#endif
 
     /*
      * The open function performs full stream detection and machine
@@ -147,43 +397,35 @@
     memset(&vfile, 0, sizeof(vfile));
     g_mutex_lock(vf_mutex);
 
+    g_mutex_lock(kate_mutex);
     result = ov_test_callbacks(fd, &vfile, NULL, 0, aud_vfs_is_streaming(stream) ? vorbis_callbacks_stream : vorbis_callbacks);
+    g_mutex_unlock(kate_mutex);
 
     switch (result) {
     case OV_EREAD:
-#ifdef DEBUG
-        g_message("** vorbis.c: Media read error: %s", filename);
-#endif
+        AUDDBG("** vorbis.c: Media read error: %s", filename);
         g_mutex_unlock(vf_mutex);
         return FALSE;
         break;
     case OV_ENOTVORBIS:
-#ifdef DEBUG
-        g_message("** vorbis.c: Not Vorbis data: %s", filename);
-#endif
+        AUDDBG("** vorbis.c: Not Vorbis data: %s", filename);
         g_mutex_unlock(vf_mutex);
         return FALSE;
         break;
     case OV_EVERSION:
-#ifdef DEBUG
-        g_message("** vorbis.c: Version mismatch: %s", filename);
-#endif
+        AUDDBG("** vorbis.c: Version mismatch: %s", filename);
         g_mutex_unlock(vf_mutex);
         return FALSE;
         break;
     case OV_EBADHEADER:
-#ifdef DEBUG
-        g_message("** vorbis.c: Invalid Vorbis bistream header: %s",
-                  filename);
-#endif
+        AUDDBG("** vorbis.c: Invalid Vorbis bistream header: %s",
+               filename);
         g_mutex_unlock(vf_mutex);
         return FALSE;
         break;
     case OV_EFAULT:
-#ifdef DEBUG
-        g_message("** vorbis.c: Internal logic fault while reading %s",
-                  filename);
-#endif
+        AUDDBG("** vorbis.c: Internal logic fault while reading %s",
+               filename);
         g_mutex_unlock(vf_mutex);
         return FALSE;
         break;
@@ -193,8 +435,10 @@
         break;
     }
 
+    g_mutex_lock(kate_mutex);
     ov_clear(&vfile);           /* once the ov_open succeeds, the stream belongs to
                                    vorbisfile.a.  ov_clear will fclose it */
+    g_mutex_unlock(kate_mutex);
     g_mutex_unlock(vf_mutex);
     return TRUE;
 }
@@ -263,6 +507,9 @@
     fd = g_new0(VFSVorbisFile, 1);
     fd->fd = stream;
     datasource = (void *) fd;
+#ifdef HAVE_KATE
+    aud_kate_state_init(&fd->aks);
+#endif
 
     /*char pcmout[4096];*/
     float pcmout[PCM_BUFSIZE*sizeof(float)];
@@ -281,8 +528,12 @@
      * need to change playback settings at a section boundary
      */
  
-   
     g_mutex_lock(vf_mutex);
+
+#ifdef HAVE_KATE
+    setup_kate(&fd->aks);
+#endif
+   
     if (ov_open_callbacks(datasource, &vf, NULL, 0, aud_vfs_is_streaming(fd->fd) ? vorbis_callbacks_stream : vorbis_callbacks) < 0) {
         vorbis_callbacks.close_func(datasource);
         g_mutex_unlock(vf_mutex);
@@ -430,6 +681,11 @@
             last_section = current_section;
          
         }
+
+#ifdef HAVE_KATE
+        update_lyrics(&fd->aks, playback, title);
+#endif
+
     } /* main loop */
 
     if (!playback->error) {
@@ -620,7 +876,11 @@
      * machine initialization.  If it returns zero, the stream
      * *is* Vorbis and we're fully ready to decode.
      */
+    g_mutex_lock(vf_mutex);
+    g_mutex_lock(kate_mutex);
     if (ov_open_callbacks(fd, &vfile, NULL, 0, aud_vfs_is_streaming(stream) ? vorbis_callbacks_stream : vorbis_callbacks) < 0) {
+        g_mutex_unlock(kate_mutex);
+        g_mutex_unlock(vf_mutex);
         aud_vfs_fclose(stream);
         return NULL;
     }
@@ -632,6 +892,8 @@
      * vorbisfile.a.  ov_clear will fclose it
      */
     ov_clear(&vfile);
+    g_mutex_unlock(kate_mutex);
+    g_mutex_unlock(vf_mutex);
 
     return tuple;
 }
@@ -691,7 +953,8 @@
                                         "Jorn Baayen <jorn@nl.linux.org>\n"
                                         "Haavard Kvaalen <havardk@xmms.org>\n"
                                         "Gian-Carlo Pascutto <gcp@sjeng.org>\n"
-                                        "Eugene Zagidullin <e.asphyx@gmail.com>\n\n"
+                                        "Eugene Zagidullin <e.asphyx@gmail.com>\n"
+                                        "Vincent Penquerc'h <ogg.k.ogg.k@googlemail.com>\n\n"
                                         "Visit the Xiph.org Foundation at http://www.xiph.org/\n"),
                                        _("Ok"), FALSE, NULL, NULL);
       g_signal_connect(G_OBJECT(about_window), "destroy",
@@ -715,6 +978,9 @@
     vorbis_cfg.proxy_pass = NULL;
     vorbis_cfg.tag_override = FALSE;
     vorbis_cfg.tag_format = NULL;
+    vorbis_cfg.kate_offset = 0;
+    vorbis_cfg.kate_display = TRUE;
+    vorbis_cfg.kate_all_streams = TRUE;
 
     db = aud_cfg_db_open();
     aud_cfg_db_get_int(db, "vorbis", "http_buffer_size",
@@ -744,9 +1010,14 @@
     aud_cfg_db_get_string(db, NULL, "proxy_user", &vorbis_cfg.proxy_user);
     aud_cfg_db_get_string(db, NULL, "proxy_pass", &vorbis_cfg.proxy_pass);
 
+    aud_cfg_db_get_int(db, "vorbis", "kate_offset", &vorbis_cfg.kate_offset);
+    aud_cfg_db_get_bool(db, "vorbis", "kate_display", &vorbis_cfg.kate_display);
+    aud_cfg_db_get_bool(db, "vorbis", "kate_all_streams", &vorbis_cfg.kate_all_streams);
+
     aud_cfg_db_close(db);
 
     vf_mutex = g_mutex_new();
+    kate_mutex = g_mutex_new();
 
     aud_mime_set_plugin("application/ogg", &vorbis_ip);
 }
@@ -784,8 +1055,8 @@
         vorbis_cfg.title_encoding = NULL;
     }
 
-    g_strfreev(vorbis_tag_encoding_list);
     g_mutex_free(vf_mutex);
+    g_mutex_free(kate_mutex);
 }
 
 static size_t
@@ -793,7 +1064,16 @@
 {
     VFSVorbisFile *handle = (VFSVorbisFile *) datasource;
 
-    return aud_vfs_fread(ptr, size, nmemb, handle->fd);
+    size_t bytes = aud_vfs_fread(ptr, size, nmemb, handle->fd);
+
+#ifdef HAVE_KATE
+    if (g_mutex_trylock(kate_mutex)) {
+        process_kate(&handle->aks, ptr, bytes);
+        g_mutex_unlock(kate_mutex);
+    }
+#endif
+
+    return bytes;
 }
 
 static int
@@ -801,6 +1081,16 @@
 {
     VFSVorbisFile *handle = (VFSVorbisFile *) datasource;
 
+#ifdef HAVE_KATE
+    if (g_mutex_trylock(kate_mutex)) {
+        if (handle->aks.kate_init_state >= kis_sync) {
+            ogg_sync_reset(&handle->aks.ksy);
+        }
+        clear_lyrics_events(&handle->aks);
+        g_mutex_unlock(kate_mutex);
+    }
+#endif
+
     return aud_vfs_fseek(handle->fd, offset, whence);
 }
 
@@ -813,6 +1103,12 @@
 
     if (handle->probe == FALSE)
     {
+#ifdef HAVE_KATE
+        if (g_mutex_trylock(kate_mutex)) {
+            shutdown_kate(&handle->aks);
+            g_mutex_unlock(kate_mutex);
+        }
+#endif
         ret = aud_vfs_fclose(handle->fd);
 /*        g_free(handle);  it causes double free. i'm not really sure that commenting out at here is correct. --yaz*/
     }
diff -ru audacious-plugins-be718ff506c0/src/vorbis/vorbis.h ../audacious-plugins-be718ff506c0/src/vorbis/vorbis.h
--- audacious-plugins-be718ff506c0/src/vorbis/vorbis.h	2008-07-18 10:10:11.000000000 +0100
+++ ../audacious-plugins-be718ff506c0/src/vorbis/vorbis.h	2008-10-27 20:28:31.000000000 +0000
@@ -1,23 +1,11 @@
 #ifndef __VORBIS_H__
 #define __VORBIS_H__
 
-#include <vorbis/vorbisfile.h>
-
 #include <audacious/plugin.h>
 
-typedef struct {
-    VFSFile *fd;
-    gboolean probe;
-} VFSVorbisFile;
-
-extern ov_callbacks vorbis_callbacks;
+extern void vorbis_configure(void);
 
-void vorbis_configure(void);
-
-gboolean vorbis_update_song_tuple (Tuple *tuple, VFSFile *fd);
-
-char *convert_to_utf8(const char *string);
-char *convert_from_utf8(const char *string);
+extern gboolean vorbis_update_song_tuple (Tuple *tuple, VFSFile *fd);
 
 typedef struct {
     gint http_buffer_size;
@@ -33,8 +21,14 @@
     gchar *tag_format;
     gboolean title_encoding_enabled;
     gchar *title_encoding;
+    gint kate_offset;
+    gboolean kate_display;
+    gboolean kate_all_streams;
 } vorbis_config_t;
 
-#define         ENCODING_SEPARATOR      " ,:;|/"
+extern vorbis_config_t vorbis_cfg;
+
+extern GMutex *vf_mutex;
+extern GMutex *kate_mutex;
 
 #endif                          /* __VORBIS_H__ */
