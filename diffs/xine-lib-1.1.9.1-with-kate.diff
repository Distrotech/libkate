diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/configure.ac ../xine-lib-1.1.9.1/configure.ac
--- xine-lib-1.1.9.1/configure.ac	2008-01-09 22:17:50.000000000 +0000
+++ ../xine-lib-1.1.9.1/configure.ac	2008-07-20 12:39:34.000000000 +0100
@@ -1212,6 +1212,32 @@
 AC_SUBST([THEORA_LIBS])
 
 dnl ---------------------------------------------
+dnl Kate libs.
+dnl ---------------------------------------------
+
+AC_ARG_WITH([kate],
+	AS_HELP_STRING([--without-kate], [Build without Kate text decoder]))
+
+if test "x$with_kate" != "xno"; then
+   PKG_CHECK_MODULES([KATE], [ogg oggkate kate], [have_kate=yes], [have_kate=no])
+   if test "x$have_kate" = "xno"; then
+     AC_CHECK_LIB([oggkate], [kate_ogg_decode_headerin], [have_kate=yes], [have_kate=no], -lkate -logg)
+     if test "x$have_kate" = "xyes"; then
+       KATE_LIBS="-loggkate -lkate -logg"
+     fi
+   fi
+   if test "x$with_kate" = "xyes" && test "x$have_kate" = "xno"; then
+      AC_MSG_ERROR([Kate support requested, but libkate not found])
+   elif test "x$have_kate" = "xyes"; then
+      AC_DEFINE([HAVE_KATE], [1], [Define this if you have kate])
+   fi
+fi
+AM_CONDITIONAL([HAVE_KATE], [test "x$have_kate" = "xyes"])
+
+AC_SUBST([KATE_CFLAGS])
+AC_SUBST([KATE_LIBS])
+
+dnl ---------------------------------------------
 dnl Ogg/Speex libs.
 dnl ---------------------------------------------
 AC_ARG_WITH([speex],
@@ -2691,6 +2717,7 @@
 src/libspudec/Makefile
 src/libspucc/Makefile
 src/libspucmml/Makefile
+src/libspukate/Makefile
 src/libspudvb/Makefile
 src/libsputext/Makefile
 src/libw32dll/Makefile
@@ -2961,6 +2988,9 @@
 if test "x$have_dxr3" = "xyes"; then
   echo "   - dxr3_spu"
 fi
+if test "x$have_kate" = "xyes"; then
+  echo "   - kate"
+fi
 echo ""
 
 dnl post plugins
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/include/xine.h ../xine-lib-1.1.9.1/include/xine.h
--- xine-lib-1.1.9.1/include/xine.h	2008-01-11 15:12:56.000000000 +0000
+++ ../xine-lib-1.1.9.1/include/xine.h	2008-07-20 12:50:15.000000000 +0100
@@ -1583,6 +1583,7 @@
 #define XINE_EVENT_DROPPED_FRAMES        12 /* number of dropped frames is too high */
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
+#define XINE_EVENT_SYNCED_TEXT           15 /* synced text (lyrics, etc) */
 
 
 /* input events coming from frontend */
@@ -1735,6 +1736,15 @@
   char                messages[1];
 } xine_ui_message_data_t;
 
+/*
+ * Synced text. Lyrics, subtitles, etc.
+ */
+typedef struct {
+  double              start_time; /* seconds */
+  double              end_time; /* seconds */
+  size_t              text_len;
+  const char          *text;
+} xine_synced_text_data_t;
 
 /*
  * notify frame format change
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/include/xine.h.in ../xine-lib-1.1.9.1/include/xine.h.in
--- xine-lib-1.1.9.1/include/xine.h.in	2008-01-01 15:36:02.000000000 +0000
+++ ../xine-lib-1.1.9.1/include/xine.h.in	2008-07-20 12:49:35.000000000 +0100
@@ -1583,6 +1583,7 @@
 #define XINE_EVENT_DROPPED_FRAMES        12 /* number of dropped frames is too high */
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
+#define XINE_EVENT_SYNCED_TEXT           15 /* synced text (lyrics, etc) */
 
 
 /* input events coming from frontend */
@@ -1735,6 +1736,15 @@
   char                messages[1];
 } xine_ui_message_data_t;
 
+/*
+ * Synced text. Lyrics, subtitles, etc.
+ */
+typedef struct {
+  double              start_time; /* seconds */
+  double              end_time; /* seconds */
+  size_t              text_len;
+  const char          *text;
+} xine_synced_text_data_t;
 
 /*
  * notify frame format change
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/demuxers/demux_matroska.c ../xine-lib-1.1.9.1/src/demuxers/demux_matroska.c
--- xine-lib-1.1.9.1/src/demuxers/demux_matroska.c	2008-01-01 13:30:08.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/demuxers/demux_matroska.c	2008-07-19 11:48:56.000000000 +0100
@@ -648,6 +648,61 @@
   }
 }
 
+static void init_codec_kate(demux_matroska_t *this, matroska_track_t *track) {
+  buf_element_t *buf;
+  uint8_t nb_lace;
+  int *frame;
+  int i, offset;
+  uint8_t *data;
+  int nheaders;
+
+  nb_lace = track->codec_private[0];
+  nheaders = nb_lace+1;
+  xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+    LOG_MODULE ": kate: %d headers in %d bytes\n", nheaders, track->codec_private_len);
+
+  frame = (int*)alloca(nheaders * sizeof(int));
+  offset = 1;
+  for (i=0; i<nb_lace; ++i) {
+    frame[i] = 0;
+    do {
+      frame[i] += track->codec_private[offset];
+    } while (offset < track->codec_private_len && track->codec_private[offset++]==0xff);
+    if (offset == track->codec_private_len) {
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+        "demux_matroska: kate: private decoder data is corrupt (tried to get us over the buffer end)\n");
+    }
+  }
+  frame[nheaders-1] = track->codec_private_len-offset;
+  for (i = 0; i < nb_lace; i++) frame[nheaders-1] -= frame[i];
+
+  data = track->codec_private + offset;
+  for (i = 0; i < nheaders; i++) {
+    buf = track->fifo->buffer_pool_alloc (track->fifo);
+    
+    if (frame[i]+1 > buf->max_size) {
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+              "demux_matroska: private decoder data length (%d) is greater than fifo buffer length (%" PRId32 ")\n",
+              frame[i], buf->max_size);
+      buf->free_buffer(buf);
+      return;
+    }
+    buf->size = frame[i]+1;
+
+    /* we send in one go - cheap - so each packet is also start and end */
+    buf->decoder_flags = BUF_FLAG_HEADER | BUF_FLAG_FRAME_START | BUF_FLAG_FRAME_END;
+    buf->type          = track->buf_type;
+    buf->pts           = 0;
+
+    /* first byte is "raw" - here, we send raw data (without ogg_packet) */
+    buf->content[0] = 1;
+    xine_fast_memcpy (buf->content+1, data, frame[i]);
+    data += frame[i];
+
+    track->fifo->put (track->fifo, buf);
+  }
+}
+
 
 static int aac_get_sr_index (uint32_t sample_rate) {
   if (92017 <= sample_rate)
@@ -1466,6 +1521,10 @@
       if (track->compress_algo == MATROSKA_COMPRESS_NONE) {
         track->compress_algo = MATROSKA_COMPRESS_UNKNOWN;
       }
+    } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_S_KATE)) {
+      lprintf("MATROSKA_CODEC_ID_S_KATE\n");
+      track->buf_type = BUF_SPU_KATE;
+      init_codec = init_codec_kate;
     } else {
       lprintf("unknown codec\n");
     }
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/demuxers/demux_ogg.c ../xine-lib-1.1.9.1/src/demuxers/demux_ogg.c
--- xine-lib-1.1.9.1/src/demuxers/demux_ogg.c	2008-01-01 13:30:08.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/demuxers/demux_ogg.c	2008-07-20 13:07:34.000000000 +0100
@@ -50,12 +50,17 @@
 #include <theora/theora.h>
 #endif
 
+#ifdef HAVE_KATE
+#include <kate/kate.h>
+#include <kate/oggkate.h>
+#endif
+
 #define LOG_MODULE "demux_ogg"
 #define LOG_VERBOSE
 
-/*
+///*
 #define LOG
-*/
+//*/
 
 #define DEBUG_PACKETS 0
 #define DEBUG_PREVIEWS 0
@@ -214,7 +219,8 @@
     } else
       return 0;
   } else if (this->si[stream_num]->buf_types == BUF_VIDEO_THEORA ||
-	     (this->si[stream_num]->buf_types & 0xFFFF0000) == BUF_SPU_CMML) {
+	     (this->si[stream_num]->buf_types & 0xFFFF0000) == BUF_SPU_CMML ||
+	     (this->si[stream_num]->buf_types & 0xFFFF0000) == BUF_SPU_KATE) {
     int64_t iframe, pframe;
     int granuleshift;
     granuleshift = this->si[stream_num]->granuleshift;
@@ -293,13 +299,13 @@
   }
 }
 
-#ifdef HAVE_THEORA
+#if defined HAVE_THEORA || defined HAVE_KATE
 static void send_ogg_packet (demux_ogg_t *this,
-                               fifo_buffer_t *fifo,
-                               ogg_packet *op,
-                               int64_t pts,
-                               uint32_t decoder_flags,
-                               int stream_num) {
+                             fifo_buffer_t *fifo,
+                             ogg_packet *op,
+                             int64_t pts,
+                             uint32_t decoder_flags,
+                             int stream_num) {
 
   buf_element_t *buf;
 
@@ -311,8 +317,16 @@
     buf = fifo->buffer_pool_alloc (fifo);
     buf->decoder_flags = decoder_flags;
     if (done==0) {
-      memcpy (buf->content, op, op_size);
-      offset=op_size;
+      if ((this->si[stream_num]->buf_types & 0xFFFF0000) == BUF_SPU_KATE && (decoder_flags & BUF_FLAG_HEADER)) {
+        /* first byte in the buffer is "raw" - here, we send cooked packets (with ogg_packet) */
+        buf->content[0] = 0;
+        memcpy (buf->content+1, op, op_size);
+        offset=op_size+1;
+      }
+      else {
+        memcpy (buf->content, op, op_size);
+        offset=op_size;
+      }
       buf->decoder_flags = buf->decoder_flags | BUF_FLAG_FRAME_START;
     }
 
@@ -726,6 +740,25 @@
              stream_num, op->bytes, buf->pts, str);
 
     this->video_fifo->put (this->video_fifo, buf);
+  } else if ((this->si[stream_num]->buf_types & 0xFFFF0000) == BUF_SPU_KATE) {
+    int64_t pts;
+
+    if ((op->granulepos != -1) || (this->si[stream_num]->header_granulepos != -1)) {
+      pts = get_pts(this, stream_num, op->granulepos );
+    } else
+      pts = 0;
+
+    llprintf (DEBUG_PACKETS,
+             "kate stream %d op-gpos %" PRId64 " hdr-gpos %" PRId64 " pts %" PRId64 " \n",
+             stream_num,
+             op->granulepos,
+             this->si[stream_num]->header_granulepos,
+             pts);
+
+    /* we send to the video fifo if there is one, and to the audio one if not */
+    send_ogg_packet (this, this->stream->video_out ? this->video_fifo : this->audio_fifo, op, pts, decoder_flags, stream_num);
+    //send_ogg_packet (this, this->video_fifo, op, pts, decoder_flags, stream_num);
+    //send_ogg_packet (this, this->audio_fifo, op, pts, decoder_flags, stream_num);
   } else if ((this->si[stream_num]->buf_types & 0xFF000000) == BUF_SPU_BASE) {
 
     buf_element_t *buf;
@@ -1192,6 +1225,57 @@
 #endif
 }
 
+static void decode_kate_header (demux_ogg_t *this, const int stream_num, ogg_packet *op) {
+
+#ifdef HAVE_KATE
+  kate_info ki;
+  kate_comment kc;
+
+  kate_info_init(&ki);
+  kate_comment_init(&kc);
+
+  lprintf("decode_kate_header, calling kate_decode_headerin, packet %lld\n",op->packetno);
+  if (kate_ogg_decode_headerin(&ki, &kc, op) >= 0) {
+    unsigned int channel = this->num_spu_streams++;
+
+    this->si[stream_num]->language = strdup ( ki.language );
+
+    this->si[stream_num]->factor = (int64_t) 90000 * (int64_t) ki.gps_denominator;
+    this->si[stream_num]->quotient = ki.gps_numerator;
+
+    this->frame_duration = ((int64_t) 90000*ki.gps_denominator);
+    this->frame_duration /= ki.gps_numerator;
+
+    this->si[stream_num]->granuleshift = ki.granule_shift;
+
+    this->si[stream_num]->headers=ki.num_headers;
+    this->si[stream_num]->buf_types = BUF_SPU_KATE | channel;
+
+    lprintf ("decoded kate header - bitstream v%d.%d, language %s, category %s\n",
+        ki.bitstream_version_major, ki.bitstream_version_minor,
+        ki.language, ki.category);
+    lprintf("  granule encoding: rate %d/%d, granule shift %d\n",
+        ki.gps_numerator,ki.gps_denominator,
+        ki.granule_shift);
+  } else {
+    /*Rejected stream*/
+    xprintf (this->stream->xine, XINE_VERBOSITY_DEBUG,
+             "A kate header was rejected by libkate\n");
+    this->si[stream_num]->buf_types = BUF_CONTROL_NOP;
+    this->si[stream_num]->headers = 0; /* FIXME: don't know */
+  }
+
+  kate_comment_clear(&kc);
+  kate_info_clear(&ki);
+
+#else
+  lprintf ("Found kate header, but no libkate support\n",
+  this->si[stream_num]->buf_types = BUF_SPU_KATE;
+  this->num_spu_streams++;
+  //this->unhandled_video_streams++; // TODO: needed ?
+#endif
+}
+
 static void decode_flac_header (demux_ogg_t *this, const int stream_num, ogg_packet *op) {
   xine_flac_metadata_header header;
   xine_flac_streaminfo_block streaminfo;
@@ -1409,6 +1493,8 @@
           decode_anxdata_header(this, stream_num, &op);
 	} else if (!strncmp (&op.packet[0], "CMML", 4)) {
 	  decode_cmml_header(this, stream_num, &op);
+	} else if (!strncmp (&op.packet[1], "kate\0\0\0", 7)) {
+	  decode_kate_header(this, stream_num, &op);
         } else {
           xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
                   "demux_ogg: unknown stream type (signature >%.8s<). hex dump of bos packet follows:\n",
@@ -1868,6 +1954,7 @@
 
   for (stream_num=0; stream_num<this->num_streams; stream_num++) {
     if ((this->si[stream_num]->buf_types & buf_mask) == buf_type) {
+      // TODO: set this where approproiate
       if (this->si[stream_num]->language) {
         if (snprintf (str, XINE_LANG_MAX, "%s", this->si[stream_num]->language) >= XINE_LANG_MAX)
           /* the string got truncated */
@@ -1897,6 +1984,8 @@
       strcpy( str, "none");
       return DEMUX_OPTIONAL_SUCCESS;
     } else if ((channel>=0) && (channel<this->num_streams)) {
+      if ( format_lang_string (this, 0xFFFFFFFF, BUF_SPU_KATE+channel, channel, str) == DEMUX_OPTIONAL_SUCCESS)
+        return DEMUX_OPTIONAL_SUCCESS;
       return format_lang_string (this, 0xFFFFFFFF, BUF_SPU_OGM+channel, channel, str);
     }
     return DEMUX_OPTIONAL_UNSUPPORTED;
@@ -2155,7 +2244,7 @@
 }
 
 static const char *ogg_get_extensions (demux_class_t *this_gen) {
-  return "ogg ogm spx";
+  return "ogg oga ogv ogm spx";
 }
 
 static const char *ogg_get_mimetypes (demux_class_t *this_gen) {
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/demuxers/Makefile.am ../xine-lib-1.1.9.1/src/demuxers/Makefile.am
--- xine-lib-1.1.9.1/src/demuxers/Makefile.am	2008-01-01 17:07:56.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/demuxers/Makefile.am	2008-07-19 11:48:56.000000000 +0100
@@ -51,8 +51,8 @@
 	xineplug_dmx_flv.la 
 
 xineplug_dmx_ogg_la_SOURCES = demux_ogg.c
-xineplug_dmx_ogg_la_LIBADD = $(XINE_LIB) $(VORBIS_LIBS) $(SPEEX_LIBS) $(THEORA_LIBS) $(OGG_LIBS) $(LTLIBINTL)
-xineplug_dmx_ogg_la_CFLAGS = $(AM_CFLAGS) $(VORBIS_CFLAGS) $(SPEEX_CFLAGS) $(THEORA_CFLAGS) $(OGG_CFLAGS)
+xineplug_dmx_ogg_la_LIBADD = $(XINE_LIB) $(VORBIS_LIBS) $(SPEEX_LIBS) $(THEORA_LIBS) $(KATE_LIBS) $(OGG_LIBS) $(LTLIBINTL)
+xineplug_dmx_ogg_la_CFLAGS = $(AM_CFLAGS) $(VORBIS_CFLAGS) $(SPEEX_CFLAGS) $(THEORA_CFLAGS) $(KATE_CFLAGS) $(OGG_CFLAGS)
 
 xineplug_dmx_avi_la_SOURCES = demux_avi.c
 xineplug_dmx_avi_la_LIBADD = $(XINE_LIB) $(LTLIBINTL)
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/demuxers/matroska.h ../xine-lib-1.1.9.1/src/demuxers/matroska.h
--- xine-lib-1.1.9.1/src/demuxers/matroska.h	2008-01-01 13:30:08.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/demuxers/matroska.h	2008-07-19 11:48:56.000000000 +0100
@@ -289,6 +289,7 @@
 #define MATROSKA_CODEC_ID_S_SSA          "S_SSA"         /* deprecated */
 #define MATROSKA_CODEC_ID_S_ASS          "S_ASS"         /* deprecated */
 #define MATROSKA_CODEC_ID_S_VOBSUB       "S_VOBSUB"
+#define MATROSKA_CODEC_ID_S_KATE         "S_KATE"
 
 /* block lacing */
 #define MATROSKA_NO_LACING               0x0
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/libspucmml/xine_cmml_decoder.c ../xine-lib-1.1.9.1/src/libspucmml/xine_cmml_decoder.c
--- xine-lib-1.1.9.1/src/libspucmml/xine_cmml_decoder.c	2008-01-01 13:30:08.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/libspucmml/xine_cmml_decoder.c	2008-07-19 11:48:56.000000000 +0100
@@ -140,15 +140,17 @@
   size_t i=0;
   int width=0,w,dummy;
   char letter[2]={0, 0};
+  size_t len;
 
-  while (i<=strlen(text)) {
+  len=strlen(text);
+  while (i<=len) {
     switch (text[i]) {
     case '<':
       if (!strncmp("<b>", text+i, 3)) {
         /*Do somethink to enable BOLD typeface*/
         i=i+3;
         break;
-      } else if (!strncmp("</b>", text+i, 3)) {
+      } else if (!strncmp("</b>", text+i, 4)) {
         /*Do somethink to disable BOLD typeface*/
         i=i+4;
         break;
@@ -156,16 +158,16 @@
         /*Do somethink to enable italics typeface*/
         i=i+3;
         break;
-      } else if (!strncmp("</i>", text+i, 3)) {
+      } else if (!strncmp("</i>", text+i, 4)) {
         /*Do somethink to disable italics typeface*/
         i=i+4;
         break;
-      } else if (!strncmp("<font>", text+i, 3)) {       
+      } else if (!strncmp("<font>", text+i, 6)) {       
         /*Do somethink to disable typing
           fixme - no teststreams*/
         i=i+6;
         break;
-      } else if (!strncmp("</font>", text+i, 3)) {
+      } else if (!strncmp("</font>", text+i, 7)) {
         /*Do somethink to enable typing
           fixme - no teststreams*/
         i=i+7;
@@ -184,17 +186,51 @@
   return width;
 }
 
+/* copied from libsputext - can't link against it, it's a plugin too */
+static int parse_utf8_size(unsigned char *c)
+{
+  if ( c[0]<0x80 )
+      return 1;
+  
+  if( c[1]==0 )
+    return 1;
+  if ( (c[0]>=0xC2 && c[0]<=0xDF) && (c[1]>=0x80 && c[1]<=0xBF) )
+    return 2;
+  
+  if( c[2]==0 )
+    return 2;	
+  else if ( c[0]==0xE0 && (c[1]>=0xA0 && c[1]<=0xBF) && (c[2]>=0x80 && c[1]<=0xBF) )
+    return 3;
+  else if ( (c[0]>=0xE1 && c[0]<=0xEC) && (c[1]>=0x80 && c[1]<=0xBF) && (c[2]>=0x80 && c[1]<=0xBF) )
+    return 3;
+  else if ( c[0]==0xED && (c[1]>=0x80 && c[1]<=0x9F) && (c[2]>=0x80 && c[1]<=0xBF) )
+    return 3;
+  else if ( c[0]==0xEF && (c[1]>=0xA4 && c[1]<=0xBF) && (c[2]>=0x80 && c[1]<=0xBF) )
+    return 3;
+  else
+    return 1;
+}
+
 static void render_line(spucmml_decoder_t *this, int x, int y, char* text) {
   size_t i=0;
   int w,dummy;
-  char letter[2]={0,0};
+  char letter[5]; /* utf-8 is 4 characters max, plus 1 for terminating zero */
+  size_t len;
 
-  while (i<=strlen(text)) {
-    letter[0]=text[i];
+  len=strlen(text);
+  while (i<=len) {
+    int bytes = parse_utf8_size ((unsigned char*)&text[i]);
+    if (bytes+i>len) {
+      /* malformed sequence ? zero found when expecting a non zero continuation,
+         the (wrong) character will be ignored */
+      break;
+    }
+    memcpy(letter,&text[i],bytes);
+    letter[bytes]=0;
     this->stream->osd_renderer->render_text(this->osd, x, y, letter, OSD_TEXT1);
     this->stream->osd_renderer->get_text_size(this->osd, letter, &w, &dummy);
     x=x+w;
-    i++;
+    i+=bytes;
   }
 }
 
@@ -458,7 +494,6 @@
   this->spu_decoder.dispose             = spudec_dispose;
   this->spu_decoder.get_interact_info   = NULL;
   this->spu_decoder.set_button          = NULL;
-  this->spu_decoder.dispose             = spudec_dispose;
 
   this->class  = class;
   this->stream = stream;
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/Makefile.am ../xine-lib-1.1.9.1/src/Makefile.am
--- xine-lib-1.1.9.1/src/Makefile.am	2007-08-19 00:36:44.000000000 +0100
+++ ../xine-lib-1.1.9.1/src/Makefile.am	2008-07-19 11:48:56.000000000 +0100
@@ -1,5 +1,9 @@
 include $(top_srcdir)/misc/Makefile.common
 
+if HAVE_KATE
+libspukate = libspukate
+endif
+
 # Order is important be careful changing SUBDIRS
 SUBDIRS = \
 	xine-utils \
@@ -15,6 +19,7 @@
 	libspudec \
 	libspucc \
 	libspucmml \
+	$(libspukate) \
 	libspudvb \
 	libsputext \
 	libdts \
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/xine-engine/audio_decoder.c ../xine-lib-1.1.9.1/src/xine-engine/audio_decoder.c
--- xine-lib-1.1.9.1/src/xine-engine/audio_decoder.c	2008-01-01 13:30:09.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/xine-engine/audio_decoder.c	2008-07-19 19:01:50.000000000 +0100
@@ -42,6 +42,36 @@
 #include "xine_internal.h"
 #include "xineutils.h"
 
+/* if updating SPU decoders for audio only streams, the decoders might crash
+   as they'll expect a valid video out - so only allow the ones we know are ok */
+static int is_suitable_audio_spu(int type)
+{
+  int streamtype = type & 0xFFFF0000;
+  switch (streamtype) {
+    case BUF_SPU_KATE:
+      return 1;
+    default:
+      return 0;
+  }
+}
+
+static void update_spu_decoder (xine_stream_t *stream, int type) {
+
+  int streamtype = (type>>16) & 0xFF;
+  
+  if( stream->spu_decoder_streamtype != streamtype ||
+      !stream->spu_decoder_plugin ) {
+    
+    if (stream->spu_decoder_plugin)
+      _x_free_spu_decoder (stream, stream->spu_decoder_plugin);
+          
+    stream->spu_decoder_streamtype = streamtype;
+    stream->spu_decoder_plugin = _x_get_spu_decoder (stream, streamtype);
+
+  }
+  return ;
+}
+
 static void *audio_decoder_loop (void *stream_gen) {
 
   buf_element_t   *buf = NULL;
@@ -52,11 +82,14 @@
   xine_ticket_t   *running_ticket = stream->xine->port_ticket;
   int              running = 1;
   int              prof_audio_decode = -1;
+  int              prof_spu_decode = -1;
   uint32_t         buftype_unknown = 0;
   int              audio_channel_user = stream->audio_channel_user;
 
   if (prof_audio_decode == -1)
     prof_audio_decode = xine_profiler_allocate_slot ("audio decoder/output");
+  if (!stream->video_out && prof_spu_decode == -1)
+    prof_spu_decode = xine_profiler_allocate_slot ("SPU decoder/output");
 
   while (running) {
 
@@ -96,6 +129,12 @@
 	stream->audio_type = 0;
       }
       
+      if (!stream->video_out && stream->spu_decoder_plugin) {
+        _x_free_spu_decoder (stream, stream->spu_decoder_plugin);
+        stream->spu_decoder_plugin = NULL;
+        stream->spu_track_map_entries = 0;
+      }
+
       running_ticket->release(running_ticket, 0);
       
       if( !stream->gapless_switch )
@@ -173,6 +212,11 @@
 	stream->audio_track_map_entries = 0;
 	stream->audio_type = 0;
       }
+      if (!stream->video_out && stream->spu_decoder_plugin) {
+        _x_free_spu_decoder (stream, stream->spu_decoder_plugin);
+        stream->spu_decoder_plugin = NULL;
+        stream->spu_track_map_entries = 0;
+      }
       
       running_ticket->release(running_ticket, 0);
       running = 0;
@@ -185,11 +229,14 @@
       lprintf ("reset\n");
 
       _x_extra_info_reset( stream->audio_decoder_extra_info );
+      running_ticket->acquire(running_ticket, 0);
       if (stream->audio_decoder_plugin) {
-	running_ticket->acquire(running_ticket, 0);
 	stream->audio_decoder_plugin->reset (stream->audio_decoder_plugin);
-	running_ticket->release(running_ticket, 0);
       }
+      if (stream->spu_decoder_plugin) {
+        stream->spu_decoder_plugin->reset (stream->spu_decoder_plugin);
+      }
+      running_ticket->release(running_ticket, 0);
       break;
           
     case BUF_CONTROL_DISCONTINUITY:
@@ -240,19 +287,19 @@
 
     default:
 
-      if (_x_stream_info_get(stream, XINE_STREAM_INFO_IGNORE_AUDIO))
-        break;
-
-      xine_profiler_start_count (prof_audio_decode);
-
-      running_ticket->acquire(running_ticket, 0);
-	  
       if ( (buf->type & 0xFF000000) == BUF_AUDIO_BASE ) {
 	
 	uint32_t audio_type = 0;
 	int      i,j;
 	uint32_t chan=buf->type&0x0000FFFF;
 
+        if (_x_stream_info_get(stream, XINE_STREAM_INFO_IGNORE_AUDIO))
+          break;
+
+        xine_profiler_start_count (prof_audio_decode);
+
+        running_ticket->acquire(running_ticket, 0);
+	  
 	/*
         printf("audio_decoder: buf_type=%08x auto=%08x user=%08x\n",
 	       buf->type, 
@@ -377,17 +424,81 @@
 	    }
 	  }
 	}
+
+        if (running_ticket->ticket_revoked)
+          running_ticket->renew(running_ticket, 0);
+        running_ticket->release(running_ticket, 0);
+      
+        xine_profiler_stop_count (prof_audio_decode);
+
+///
+      } else if ( (buf->type & 0xFF000000) == BUF_SPU_BASE ) {
+
+        int      i,j;
+
+        if (stream->video_out || !is_suitable_audio_spu(buf->type))
+          break;
+
+        if (_x_stream_info_get(stream, XINE_STREAM_INFO_IGNORE_SPU))
+          break;
+
+        xine_profiler_start_count (prof_spu_decode);
+
+        running_ticket->acquire(running_ticket, 0);
+      
+        update_spu_decoder(stream, buf->type);
+
+        /* update track map */
+
+        i = 0;
+        while ( (i<stream->spu_track_map_entries) && (stream->spu_track_map[i]<buf->type) ) 
+          i++;
+        
+        if ( (i==stream->spu_track_map_entries)
+             || (stream->spu_track_map[i] != buf->type) ) {
+          xine_event_t  ui_event;
+
+          j = stream->spu_track_map_entries;
+
+          if (j >= 50)
+            break;
+
+          while (j>i) {
+            stream->spu_track_map[j] = stream->spu_track_map[j-1];
+            j--;
+          }
+          stream->spu_track_map[i] = buf->type;
+          stream->spu_track_map_entries++;
+
+	  ui_event.type        = XINE_EVENT_UI_CHANNELS_CHANGED;
+	  ui_event.data_length = 0;
+	  xine_event_send (stream, &ui_event);
+        }
+
+        if (stream->spu_channel_user >= 0) {
+          if (stream->spu_channel_user < stream->spu_track_map_entries)
+            stream->spu_channel = (stream->spu_track_map[stream->spu_channel_user] & 0xFF);
+          else
+            stream->spu_channel = stream->spu_channel_auto;
+        }
+
+        if (stream->spu_decoder_plugin) {
+          stream->spu_decoder_plugin->decode_data (stream->spu_decoder_plugin, buf);
+        }
+
+        if (running_ticket->ticket_revoked)
+          running_ticket->renew(running_ticket, 0);
+        running_ticket->release(running_ticket, 0);
+      
+        xine_profiler_stop_count (prof_spu_decode);
+
+///
+
       } else if( buf->type != buftype_unknown ) {
 	  xine_log (stream->xine, XINE_LOG_MSG, 
 		    _("audio_decoder: error, unknown buffer type: %08x\n"), buf->type );
 	  buftype_unknown = buf->type;
       }
-
-      if (running_ticket->ticket_revoked)
-        running_ticket->renew(running_ticket, 0);
-      running_ticket->release(running_ticket, 0);
-      
-      xine_profiler_stop_count (prof_audio_decode);
     }
 
     /* some decoders require a full reinitialization when audio
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/xine-engine/buffer.h ../xine-lib-1.1.9.1/src/xine-engine/buffer.h
--- xine-lib-1.1.9.1/src/xine-engine/buffer.h	2008-01-05 22:15:37.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/xine-engine/buffer.h	2008-07-19 11:48:56.000000000 +0100
@@ -270,6 +270,7 @@
 #define BUF_SPU_CVD             0x04050000
 #define BUF_SPU_OGM             0x04060000
 #define BUF_SPU_CMML            0x04070000
+#define BUF_SPU_KATE            0x04080000
 
 /* demuxer block types: */
 
diff -x 'configure.h*' -x config.guess -x config.sub -x SlackBuild -x configure -x '*.m4' -x ltmain.sh -x libtool -x Makefile -x Makefile.in -ru xine-lib-1.1.9.1/src/xine-engine/osd.c ../xine-lib-1.1.9.1/src/xine-engine/osd.c
--- xine-lib-1.1.9.1/src/xine-engine/osd.c	2008-01-01 13:30:09.000000000 +0000
+++ ../xine-lib-1.1.9.1/src/xine-engine/osd.c	2008-07-19 11:48:56.000000000 +0100
@@ -942,7 +942,7 @@
 	  ret = osd_renderer_load_font(osd->renderer, osd->font->filename);
 	if(!ret)
 	  osd->font = NULL;
-      }      
+      }
     }
 
   pthread_mutex_unlock (&osd->renderer->osd_mutex);
@@ -1528,6 +1528,14 @@
 
   lprintf("osd=%p at (%d,%d) %dx%d\n",osd, x1,y1, width,height );
 
+  /* prevent overflowing to right and bottom */
+  if (x1+width > osd->width) {
+    width = osd->width-x1;
+  }
+  if (y1+height > osd->height) {
+    height = osd->height-y1;
+  }
+
   /* update clipping area */
   osd->x1 = MIN( osd->x1, x1 );
   osd->x2 = MAX( osd->x2, x1+width );
